// Decompiled with JetBrains decompiler
// Type: TenTec.Windows.iGridLib.iGrid
// Assembly: TenTec.Windows.iGridLib.iGrid.v6.0, Version=6.0.37.0, Culture=neutral, PublicKeyToken=9d47002745f2416c
// MVID: 417E314E-0FBF-4E4F-8CBF-B713726278B4
// Assembly location: C:\10Tec\iGrid.NET 6.0\Bin\TenTec.Windows.iGridLib.iGrid.v6.0.dll

using Microsoft.Win32;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Data;
using System.Drawing;
using System.Drawing.Design;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Text;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace TenTec.Windows.iGridLib
{
  /// <summary>Represents an iGrid.NET grid control which allows you to display and edit tabular data. This is the core class that represents 10Tec Grid for .NET.</summary>
  [DesignerSerializer("TenTec.Windows.iGridLib.Design.iGSerializer, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design")]
  [Designer("TenTec.Windows.iGridLib.Design.iGDesigner, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
  //[Designer("TenTec.Windows.iGridLib.Design.iGDesigner")]
  [ToolboxBitmap(typeof (iGrid), "Resources.ToolBoxiGrid.bmp")]
  [Description("Represents the iGrid grid control. Allows you to display and edit tabular data.")]
  public class iGrid : Control, ISupportInitialize
  {
    private static Cursor fCursorColResize = new Cursor(iGrid.GetResourceStream("ResizeCol.cur"));
    internal static Cursor fCursorRowResize = new Cursor(iGrid.GetResourceStream("ResizeRow.cur"));
    private static readonly System.Drawing.Color cDefaultBorderColor = SystemColors.ControlDark;
    internal static readonly System.Drawing.Color cDefaultBackColor = SystemColors.Window;
    internal static readonly System.Drawing.Color cDefaultForeColor = SystemColors.WindowText;
    private static readonly Size cDefaultSize = new Size(200, 200);
    private static readonly System.Drawing.Color cDefaultForeColorDisabled = SystemColors.GrayText;
    private static readonly System.Drawing.Color cDefaultBackColorEvenRows = System.Drawing.Color.Empty;
    private static readonly System.Drawing.Color cDefaultBackColorOddRows = System.Drawing.Color.Empty;
    private static readonly System.Drawing.Color cDefaultFocusRectColor1 = SystemColors.ControlText;
    private static readonly System.Drawing.Color cDefaultFocusRectColor2 = SystemColors.Window;
    internal static readonly System.Drawing.Color cDefaultSelCellsBackColor = SystemColors.Highlight;
    internal static readonly System.Drawing.Color cDefaultSelCellsForeColor = SystemColors.HighlightText;
    private static readonly System.Drawing.Color cDefaultSelCellsBackColorNoFocus = SystemColors.Control;
    private static readonly System.Drawing.Color cDefaultSelCellsForeColorNoFocus = SystemColors.WindowText;
    private static readonly System.Drawing.Color cDefaultSelRowsBackColor = System.Drawing.Color.Empty;
    private static readonly System.Drawing.Color cDefaultSelRowsForeColor = System.Drawing.Color.Empty;
    private static readonly System.Drawing.Color cDefaultSelRowsBackColorNoFocus = System.Drawing.Color.Empty;
    private static readonly System.Drawing.Color cDefaultSelRowsForeColorNoFocus = System.Drawing.Color.Empty;
    private static readonly System.Drawing.Color cDefaultCurCellBackColor = System.Drawing.Color.Empty;
    private static readonly System.Drawing.Color cDefaultCurCellForeColor = System.Drawing.Color.Empty;
    private static readonly System.Drawing.Color cDefaultCurCellBackColorNoFocus = System.Drawing.Color.Empty;
    private static readonly System.Drawing.Color cDefaultCurCellForeColorNoFocus = System.Drawing.Color.Empty;
    private static int fInvokeMemberFlags = 0;
    internal iGPage[] fPages = new iGPage[5];
    internal iGColData[] fColDatas = new iGColData[5];
    internal int[] fColIdxFromOrd = new int[5];
    internal int fPageCapacity = 100;
    private bool fDefaultRowHeightAutoSet = true;
    private iGKeyManager fColKeys = new iGKeyManager(5);
    private iGKeyManager fRowKeys = new iGKeyManager(100);
    internal iGRowNavigator[] fRowsMap = new iGRowNavigator[100];
    internal Stack fDeletedRows = new Stack();
    private int fDefaultAutoGroupRowHeight = 17;
    private bool fDefaultAutoGroupRowExpanded = true;
    private iGTreeButtonState fDefaultAutoGroupRowTreeButton = iGTreeButtonState.Visible;
    internal bool fCreateRowCellStyleDynamically = true;
    internal int fFooterRowCount = 1;
    internal System.Drawing.Color fFooterBackColor = iGFooter.cDefaultBackColor;
    internal System.Drawing.Color fFooterForeColor = iGFooter.cDefaultForeColor;
    internal iGPenStyle fFooterSeparatingLine = iGFooter.cDefaultSeparatingLine.Clone();
    internal iGAutoHeightEvents fFooterAutoHeightEvents = iGAutoHeightEvents.OnAddCol | iGAutoHeightEvents.OnContentsChange | iGAutoHeightEvents.OnThemeChange | iGAutoHeightEvents.OnRemoveRow;
    private bool fCalculateTotals = true;
    internal System.Drawing.Color fHeaderForeColor = System.Drawing.Color.Empty;
    private bool fHeaderVisible = true;
    internal int fHeaderRowCount = 1;
    private bool fHeaderDrawSystem = true;
    internal iGHdrHotTrackFlags fHotTrackFlags = iGHdrHotTrackFlags.Text;
    internal System.Drawing.Color fHotTrackForeColor = iGHeader.cDefaultHotTrackForeColor;
    internal int fHotTrackIconDegree = -5;
    internal iGPenStyle fHeaderSeparatingLine = iGHeader.cDefaultSeparatingLine.Clone();
    internal bool fHeaderHotTracking = true;
    internal iGHdrHotTrackFlags fHotTrackFlagsXPStyles = iGHdrHotTrackFlags.Background;
    internal bool fHeaderAllowPress = true;
    internal System.Drawing.Color fGroupBoxHintForeColor = iGGroupBox.cDefaultHintForeColor;
    internal System.Drawing.Color fGroupBoxHintBackColor = iGGroupBox.cDefaultHintBackColor;
    internal System.Drawing.Color fGroupBoxBackColor = iGGroupBox.cDefaultBackColor;
    internal System.Drawing.Color fGroupBoxColHdrBorderColor = iGGroupBox.cDefaultColHdrBorderColor;
    internal iGAutoHeightEvents fHeaderAutoHeightEvents = iGAutoHeightEvents.OnAddCol | iGAutoHeightEvents.OnContentsChange | iGAutoHeightEvents.OnThemeChange | iGAutoHeightEvents.OnRemoveRow;
    private float fDisplayVerticalResolution = 96f;
    private bool fColorizeRowLevelIndent = true;
    private int fLevelIndent = 19;
    private bool fTreeLinesShowRootLines = true;
    private bool fHotTracking = true;
    private iGCellNavigator fEditCell = iGCellNavigator.Empty;
    private iGColHdrNavigator fColHdrDrawnHot = iGColHdrNavigator.Empty;
    private bool fHideDropDownOnDeactivate = true;
    private bool fProcessTab = true;
    private bool fProcessEnter = true;
    internal iGMouseEventsData fMouseData = iGMouseEventsData.Empty;
    private int fStartDragCellDelta = 4;
    internal bool fImmediateRowResizing = true;
    private iGRowResizeMode fRowResizeMode = iGRowResizeMode.RowHdr;
    internal iGCellNavigator fCurCell = iGCellNavigator.Empty;
    private int fEnterMergedCellRowIndex = -1;
    private int fEnterMergedCellColOrder = -1;
    private iGSelectionMode fSelectionMode = iGSelectionMode.One;
    internal iGCellNavigator fBeginSelectWithShiftCell = iGCellNavigator.Empty;
    private bool fFocusRect = true;
    private System.Drawing.Color fFocusRectColor1 = iGrid.cDefaultFocusRectColor1;
    private System.Drawing.Color fFocusRectColor2 = iGrid.cDefaultFocusRectColor2;
    private System.Drawing.Color fSelCellsBackColor = iGrid.cDefaultSelCellsBackColor;
    private System.Drawing.Color fSelCellsForeColor = iGrid.cDefaultSelCellsForeColor;
    private System.Drawing.Color fSelCellsBackColorNoFocus = iGrid.cDefaultSelCellsBackColorNoFocus;
    private System.Drawing.Color fSelCellsForeColorNoFocus = iGrid.cDefaultSelCellsForeColorNoFocus;
    private System.Drawing.Color fSelRowsBackColor = iGrid.cDefaultSelRowsBackColor;
    private System.Drawing.Color fSelRowsForeColor = iGrid.cDefaultSelRowsForeColor;
    private System.Drawing.Color fSelRowsBackColorNoFocus = iGrid.cDefaultSelRowsBackColorNoFocus;
    private System.Drawing.Color fSelRowsForeColorNoFocus = iGrid.cDefaultSelRowsForeColorNoFocus;
    private System.Drawing.Color fCurCellBackColor = iGrid.cDefaultCurCellBackColor;
    private System.Drawing.Color fCurCellForeColor = iGrid.cDefaultCurCellForeColor;
    private System.Drawing.Color fCurCellBackColorNoFocus = iGrid.cDefaultCurCellBackColorNoFocus;
    private System.Drawing.Color fCurCellForeColorNoFocus = iGrid.cDefaultCurCellForeColorNoFocus;
    private bool fHighlightSelCells = true;
    private int fLastSelectedInCellModeRowIndex = -1;
    private int cComboIndent = 1;
    private iGPressedMouseMoveMode fPressedMouseMoveMode = iGPressedMouseMoveMode.Selection;
    internal iGSpecifiedColors fSpecifiedColors = iGSpecifiedColors.ScrollBackColor | iGSpecifiedColors.ScrollForeColor | iGSpecifiedColors.CellsBackColor | iGSpecifiedColors.CellsForeColor;
    private iGBorderStyle fBorderStyle = iGBorderStyle.System;
    private int fBorderWidth = 1;
    private System.Drawing.Color fBorderColor = iGrid.cDefaultBorderColor;
    private System.Drawing.Color fForeColorDisabled = iGrid.cDefaultForeColorDisabled;
    private System.Drawing.Color fBackColorEvenRows = iGrid.cDefaultBackColorEvenRows;
    private System.Drawing.Color fBackColorOddRows = iGrid.cDefaultBackColorOddRows;
    internal bool fRedraw = true;
    private bool fImmediateColResizing = true;
    private bool fShowControlsInAllCells = true;
    private int fRowTextStartColNear = 1;
    private bool fEnsureVisibleAutoHScroll = true;
    private bool fEnsureVisibleAutoVScroll = true;
    private bool fAdjustScrollBarValuesRedrawOff = true;
    private iGPenStyle fHeaderVGridLinesStyle = iGHeader.cDefaultGridLinesStyle.Clone();
    private iGPenStyle fHeaderHGridLinesStyle = iGHeader.cDefaultGridLinesStyle.Clone();
    internal iGPenStyle fVGridLinesStyle = iGGridLines.cDefaultGridLineStyle.Clone();
    internal iGPenStyle fHGridLinesStyle = iGGridLines.cDefaultGridLineStyle.Clone();
    internal iGPenStyle fFrozenRowsSeparatingLineStyle = iGGridLines.cDefaultFrozenEdgeSeparatingLineStyle.Clone();
    internal iGPenStyle fFrozenColsSeparatingLineStyle = iGGridLines.cDefaultFrozenEdgeSeparatingLineStyle.Clone();
    internal iGPenStyle fGroupRowsGridLinesStyle = iGGridLines.cDefaultGroupRows.Clone();
    internal iGPenStyle fVLastColGridLineStyle = iGGridLines.cDefaultGridLineStyle.Clone();
    internal iGPenStyle fHLastRowGridLineStyle = iGGridLines.cDefaultGridLineStyle.Clone();
    internal iGPenStyle fVExtendedGridLineStyle = iGGridLines.cDefaultGridLineStyle.Clone();
    internal iGPenStyle fHExtendedGridLineStyle = iGGridLines.cDefaultGridLineStyle.Clone();
    internal iGGridLinesMode fGridLinesMode = iGGridLinesMode.Both;
    private bool fVScrollBarVisible = true;
    private bool fHScrollBarVisible = true;
    internal double fScrollBarOpacity = 1.0;
    private int fLastVisibleRowIndex = -1;
    private int fLastVisibleColIndex = -1;
    private int fFrozenColCount = 1;
    private bool fPrefixGroupValues = true;
    private iGAutoWidthColMode fAutoWidthColMode = iGAutoWidthColMode.HeaderAndCells;
    private iGAutoHeightRowMode fAutoHeightRowMode = iGAutoHeightRowMode.RowHdrAndCells;
    private int fTreeColIndex = -1;
    private const int cDefaultPagesCapacity = 5;
    private const int cDefaultColsCapacity = 5;
    private const int cDefaultPageCapacity = 100;
    internal const int cExtraColCount = 1;
    internal const int cRowTextColOrder = 0;
    internal const int cRowTextColIndex = 0;
    private const bool cDefaultCreateRowCellStyleDynamically = true;
    private const bool cDefaultDefaultRowHeightAutoSet = true;
    internal const int cKeyNotFoundItemIndex = -1;
    internal int fColCount;
    internal int fRowCount;
    internal int fPageCount;
    internal iGCellData[] fDefaultCells;
    internal iGColPattern fDefaultCol;
    internal iGRowPattern fDefaultRow;
    private iGColCollection fColCollection;
    private iGRowCollection fRowCollection;
    private iGCellCollection fCellCollection;
    private iGCol fRowTextColObject;
    private iGDefaultAutoGroupRow fDefaultAutoGroupRow;
    private iGCellStyle[] fAutoGroupRowLevelStyles;
    private int fNotSortableRowCount;
    private int fMergedCellCountAll;
    private int fMergedCellCountVert;
    private int fMergedCellCountHorz;
    private const bool cDefaultCalculateTotals = true;
    private iGFooter fFooter;
    private int[] fFooterSpanMap;
    private iGFooterRowData[] fFooterRows;
    private iGFooterCellData[] fFooterCells;
    internal iGFooterRowCollection fFooterRowCollection;
    internal iGFooterCellCollection fFooterCellCollection;
    private bool fFooterVisible;
    internal Font fFooterFont;
    internal ImageList fFooterImageList;
    private bool fAutoHeightFooterWhenSetRedrawToTrue;
    private int fAggregateFunctionCount;
    private iGHeader fHeader;
    private int[] fHeaderSpanMap;
    private iGHdrRowData[] fHeaderRows;
    private iGColHdrData[] fColHdrs;
    private static Icon fArrowsIcon;
    internal iGControlPaintStyle fHeaderControlPaintStyle;
    internal iGColHdrCollection fColHdrCollection;
    internal iGHdrRowCollection fHeaderRowCollection;
    internal ImageList fHeaderImageList;
    internal ImageAttributes fHighlightIconAttributes;
    internal Font fHeaderFont;
    internal bool fCurColHeaderAllowPress;
    private bool fClosingColHdrDropDown;
    private bool fGroupBoxVisible;
    private bool fAutoHeightHeaderWhenSetRedrawToTrue;
    private iGInternalOrderedCellCollection fMergedCells;
    private iGSelectedCellsCollection fMergedCellsPublicCollection;
    private Point _ptFirst;
    private Point _ptSecond;
    private const int WM_GESTURENOTIFY = 282;
    private const int WM_GESTURE = 281;
    private const int GC_ALLGESTURES = 1;
    private const int GC_PAN = 1;
    private const int GC_PAN_WITH_SINGLE_FINGER_VERTICALLY = 2;
    private const int GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY = 4;
    private const int GC_PAN_WITH_GUTTER = 8;
    private const int GC_PAN_WITH_INTERTIA = 16;
    private const int GID_BEGIN = 1;
    private const int GID_END = 2;
    private const int GID_ZOOM = 3;
    private const int GID_PAN = 4;
    private const int GID_ROTATE = 5;
    private const int GID_TWOFINGERTAP = 6;
    private const int GID_PRESSANDTAP = 7;
    private const int GF_BEGIN = 1;
    private const int GF_INERTIA = 2;
    private const int GF_END = 4;
    private const bool cDefaultColorizeRowLevelIndent = true;
    private const bool cDefaultStretchComboButton = false;
    private const bool cDefaultDrawCustomBackground = false;
    private const int cDefaultLevelIndent = 19;
    private const int cCellImageDistanceFromText = 2;
    internal bool fAdjustDrawingForPrinter;
    private bool fFontForPrinterAdjusted;
    private bool fStretchComboButton;
    internal IiGControlPaint fCustomControlPaint;
    private bool fDrawCustomBackground;
    private Pen fTreeBranchPen;
    private bool fTreeLinesVisible;
    private iGTreeLines fTreeLines;
    private const bool cDefaultReadOnly = false;
    private const bool cDefaultMouseDownLocked = false;
    private const bool cDefaultDrawAsFocused = false;
    private const bool cDefaultHotTracking = true;
    private const bool cDefaultCurCellComboPressed = false;
    private const bool cDefaultSilentValidation = false;
    private const bool cDefaultSingleClickEdit = false;
    private const bool cDefaultHideDropDownOnDeactivate = true;
    private iGCellEditorBase fCellEditor;
    private Control fCellEditControl;
    private iGCellEditorBase fDefaultCellEditor;
    private iGTextBox fTextBoxObject;
    private bool fReadOnly;
    private bool fMouseDownLocked;
    private bool fDrawAsFocused;
    private bool fCurCellComboPressed;
    private bool fSilentValidation;
    private bool fSingleClickEdit;
    private bool fSaveTextAsIs;
    private iGEditType fEditType;
    private bool fColHdrDropDownActive;
    private iGDropDownManager fDropDownManager;
    private IiGDropDownControl fDropDownControl;
    private iGDropDownManager fAutoCompleteManager;
    private IiGAutoCompleteControl fAutoCompleteControl;
    private Control fAutoCompleteControlControl;
    private const bool cDefaultProcessTab = true;
    private const bool cDefaultProcessEnter = true;
    private iGSearchAsType fSearchAsTypeObject;
    private const bool cDefaultImmediateRowResizing = true;
    private const iGRowResizeMode cDefaultRowResizeMode = iGRowResizeMode.RowHdr;
    private static Bitmap fAutoScrollCenterBitmap;
    private static Bitmap fAutoScrollCenterBitmapHorz;
    private static Bitmap fAutoScrollCenterBitmapVert;
    private Timer fAutoScrollTimer;
    private bool fLockFirstMouseDown;
    private Timer fAutoScrollSetCaptureTimer;
    private bool fIsAutoScrollCapture;
    private bool fStartDragCellWasRaised;
    private bool fIsColResizing;
    private bool fIsRowResizing;
    private Timer fRefreshMouseDataTimer;
    private iGRowHeader fRowHeader;
    private iGInternalOrderedCellCollection fSelectedCells;
    private iGSelectedCellsCollection fSelectedCellsPublicCollection;
    private iGInternalOrderedRowCollection fSelectedRows;
    private iGSelectedRowsCollection fSelectedRowsPublicCollection;
    internal bool fRowMode;
    internal bool fSelectInvisibleCells;
    private bool fRowModeHasCurCell;
    private iGHighlightSelCellItems fHighlightSelCellItems;
    internal iGRowSelectionInCellModeTypes fRowSelectionInCellMode;
    private bool fChangeSelectionOnMouseUp;
    private bool fCtrlWasPressedWhenMouseDown;
    private const int cSortAreaIndent = 3;
    private const bool cDefaultRowModeHasCurCell = false;
    private const bool cDefaultSelectInvisibleCells = false;
    private const bool cDefaultAutoResizeCols = false;
    private const bool cDefaultStaySorted = false;
    private const iGPressedMouseMoveMode cDefaultPressedMouseMoveMode = iGPressedMouseMoveMode.Selection;
    private const int cDefaultRedrawCounter = 0;
    private const bool cDefaultRedraw = true;
    private const int cDefaultBorderWidth = 1;
    private const iGBorderStyle cDefaultBorderStyle = iGBorderStyle.System;
    internal const int cDefaultVScrollSmallChange = 16;
    internal const int cDefaultHScrollSmallChange = 10;
    internal const int cDefaultFrozenRowCount = 0;
    internal const int cDefaultFrozenColCount = 0;
    internal const int cMinHeaderRowCount = 1;
    internal const int cMinFooterRowCount = 1;
    private const bool cDefaultImmediateColResizing = true;
    private const iGSelectionMode cDefaultSelectionMode = iGSelectionMode.One;
    private const bool cDefaultRowMode = false;
    private const bool cDefaultFocusRect = true;
    private const bool cDefaultShowControlsInAllCells = true;
    private const iGAutoWidthColMode cDefaultAutoWidthColMode = iGAutoWidthColMode.HeaderAndCells;
    private const bool cDefaultRowTextVisible = false;
    private const int cDefaultRowTextStartColNear = 0;
    private const int cDefaultRowTextEndColFar = 0;
    internal const bool cDefaultSortFrozenRows = false;
    private const int cGroupCellDY = 10;
    private const int cGroupCellDX = 4;
    private const int cGroupCellsIndent = 6;
    private const int cGroupCellsConnectionLineBottomIndent = 6;
    private const int cGroupCellsConnectionLineWidth = 10;
    private const int cGroupCellsConnectionLineHeight = 4;
    private const bool cDefaultScrollGroupRows = false;
    private const bool cDefaultSortByLevels = false;
    private const bool cDefaultHighlightSelCells = true;
    private const iGHighlightSelCellItems cDefaultHighlightSelCellItems = iGHighlightSelCellItems.None;
    private const bool cPrefixGroupValues = true;
    private const iGSpecifiedColors cDefaultSpecifiedColors = iGSpecifiedColors.ScrollBackColor | iGSpecifiedColors.ScrollForeColor | iGSpecifiedColors.CellsBackColor | iGSpecifiedColors.CellsForeColor;
    private const int cDefaultStartDragCellDelta = 4;
    private const iGAutoHeightRowMode cDefaultAutoHeightRowMode = iGAutoHeightRowMode.RowHdrAndCells;
    private const iGRowSelectionInCellModeTypes cDefaultRowSelectionInCellMode = iGRowSelectionInCellModeTypes.None;
    private const int cTreeButtonIndent = 3;
    private const int cDefaultTreeColIndex = -1;
    private const char cDefaultPasswordChar = '\0';
    private const bool cDefaultEnsureVisibleAutoHScroll = true;
    private const bool cDefaultEnsureVisibleAutoVScroll = true;
    private const int cTipTextCharLimitOSWorkaround = 300;
    private const char cHorizontalEllipsisUnicodeChar = '…';
    private const int cGetPreferredRowHeightSpecialRowIndex = -1;
    private const int cGetPreferredRowHeightSpecialColIndex = -2147483648;
    private const int cGetPreferredRowHeightSpecialColOrder = -2147483648;
    private const int cDefaultMarginAfterLastRow = 0;
    private const int cDefaultMarginAfterLastCol = 0;
    private const bool cDefaultAdjustScrollBarValuesRedrawOff = true;
    private const TextRenderingHint cDefaultTextRenderingHint = TextRenderingHint.SystemDefault;
    internal const int cDefaultSpanRows = 1;
    internal const int cDefaultSpanCols = 1;
    internal static int fCreateTickCount;
    private const int cInvokeMemberBindingFlags = 8;
    private bool fWatermarkWasDrawn;
    private bool fDoNotFocusOnMouseDown;
    private ImageList fImageList;
    internal iGControlPaintStyle fCellControlPaintStyle;
    private int fBeginUpdateCounter;
    private int fRedrawOffVScrollBarMaxValue;
    private int fRedrawOffHScrollBarMaxValue;
    private bool fIgnoreAdjustViewportFirstRowVars;
    private Cursor fCursor;
    private bool fRowTextVisible;
    private int fRowTextEndColFar;
    private iGLayout fLayout;
    private Image fEllipsisButtonGlyph;
    private bool fDisposed;
    internal iGUIStrings fUIStrings;
    private string fToolTipTextForCell;
    private bool fToolTipTextForCellControlDiffers;
    private char fPasswordChar;
    private char fPasswordCharEffective;
    private int fMarginAfterLastRow;
    private int fMarginAfterLastCol;
    private TextRenderingHint fTextRenderingHint;
    internal iGGridLinesMode fExtendGridLinesMode;
    private iGGridLines fGridLines;
    internal iGVScrollBar fVScrollBar;
    internal iGHScrollBar fHScrollBar;
    private int fOldVScrollValue;
    private int fOldHScrollValue;
    private iGScrollBar fVScrollObject;
    private iGScrollBar fHScrollObject;
    private iGScrollBarSettings fScrollBarSettings;
    internal iGScrollBarVisibility fHScrollBarVisibility;
    internal iGScrollBarVisibility fVScrollBarVisibility;
    internal bool fAreCellsSrollableVert;
    internal bool fAreCellsSrollableHorz;
    private bool fProhibitNativeScrollWindow;
    private bool fScrollWindowVert;
    internal int fVisibleRowsHeight;
    private int fVisibleRowCount;
    private int fViewportFirstRowIndex;
    private int fViewportFirstRowHiddenHeight;
    private int fViewportFirstRowVisibleCountBefore;
    private int fVisibleColCount;
    private int fVisibleColsWidthPlusGroupObjectLevelArea;
    private iGFrozenArea fFrozenArea;
    private int fFrozenRowCount;
    private int fFrozenRowsHeight;
    private int fFrozenColsWidth;
    private int fFrozenVisibleColCount;
    private iGSortObject fSortObject;
    private iGSortObject fGroupObject;
    private iGSortObject fLastGroupObject;
    private bool fSortFrozenRows;
    private bool fStaySorted;
    private int[] fGroupColsWidths;
    private iGGroupBox fGroupBoxObject;
    private static Icon fArrowUpIcon;
    private bool fScrollGroupRows;
    private bool fIsOneOfTheGroupRowsVisible;
    private int fGroupRowCount;
    private bool fSortByLevels;
    internal bool fAutoResizeCols;
    private int[] fOldColsWidths;
    private int fOldColsWidth;
    private int fVisibleAllowSizeCount;
    private ToolTip fGridToolTip;

    private bool DoTwoCellRangesIntersect(int startRow1, int startCol1, int endRow1, int endCol1, int startRow2, int startCol2, int endRow2, int endCol2)
    {
      if (startCol2 <= endCol1 && startCol1 <= endCol2 && startRow2 <= endRow1)
        return startRow1 <= endRow2;
      return false;
    }

    private void GetMinMax(int value1, int value2, out int min, out int max)
    {
      if (value1 > value2)
      {
        max = value1;
        min = value2;
      }
      else
      {
        max = value2;
        min = value1;
      }
    }

    internal static bool IsStringNullOrWhiteSpace(string value)
    {
      if (value == null)
        return true;
      return string.IsNullOrEmpty(value.Trim());
    }

    private bool IsGroupRow(int rowIndex)
    {
      return this.IsGroupRow(this.GetRowDataInternal(rowIndex));
    }

    private bool IsGroupRow(iGRowData rowData)
    {
      return this.IsGroupRow(rowData.Type);
    }

    private bool IsGroupRow(iGRowType rowType)
    {
      if (rowType != iGRowType.AutoGroupRow)
        return rowType == iGRowType.ManualGroupRow;
      return true;
    }

    internal bool IsEvenRowInternal(int rowIndex)
    {
      int num1;
      bool flag;
      int num2;
      if (rowIndex < this.fFrozenRowCount)
      {
        num1 = 1;
        flag = false;
        num2 = 0;
      }
      else
      {
        num1 = rowIndex >= this.fViewportFirstRowIndex ? 1 : -1;
        flag = this.fViewportFirstRowVisibleCountBefore % 2 == 1;
        num2 = this.fViewportFirstRowIndex;
      }
      int rowIndex1 = num2;
      while (rowIndex1 != rowIndex && rowIndex1 >= 0 && rowIndex1 < this.fRowCount)
      {
        if (this.IsRowVisibleInternal(rowIndex1))
          flag = !flag;
        rowIndex1 += num1;
      }
      return flag;
    }

    internal void SetRowVisibleParentExpanded(int rowIndex, bool value)
    {
      this.RefreshGridAndScrollBarsIfRedraw(this.SetRowVisibleParentExpandedInternal(rowIndex, value));
    }

    private bool SetRowVisibleParentExpandedInternal(int rowIndex, bool value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      iGRowData rowData = this.fPages[fRows.PageIndex].GetRowData(fRows.RowIndex);
      if (rowData.VisibleParentExpanded == value)
        return false;
      this.fPages[fRows.PageIndex].SetRowVisibleParentExpanded(fRows.RowIndex, value);
      return this.RowHeightOrVisibleChanged(rowIndex, this.IsRowVisibleInternal(rowData.Visible, rowData.VisibleParentExpanded), this.IsRowVisibleInternal(rowData.Visible, value), rowData.Height, rowData.Height);
    }

    internal bool IsRowVisibleInternal(int rowIndex)
    {
      iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
      return this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded);
    }

    internal bool IsRowVisibleInternal(bool rowDataVisible, bool rowDataVisibleParentExpanded)
    {
      return rowDataVisible & rowDataVisibleParentExpanded;
    }

    private bool IsRowFirstVisible(int rowIndex)
    {
      this.CheckRowIndex(rowIndex);
      for (int rowIndex1 = rowIndex - 1; rowIndex1 >= 0; --rowIndex1)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          return false;
      }
      return true;
    }

    internal void MoveRows(int srcIndex, int count, int rowBefore)
    {
      this.CheckRowIndexAndCount(srcIndex, count, nameof (count));
      if (rowBefore != this.fRowCount)
        this.CheckRowIndex(rowBefore);
      if (rowBefore > srcIndex && rowBefore < srcIndex + count)
        throw new ArgumentException();
      if (this.fStaySorted)
        throw new InvalidOperationException("Cannot move rows in stay sorted mode");
      if (srcIndex > 0 && !this.CanSeparateRows(srcIndex))
        throw new ArgumentException("Cannot break merged cells");
      if (srcIndex + count < this.fRowCount && !this.CanSeparateRows(srcIndex + count))
        throw new ArgumentException("Cannot break merged cells");
      if (0 < rowBefore && rowBefore < this.fRowCount && !this.CanSeparateRows(rowBefore))
        throw new ArgumentException("Cannot break merged cells");
      this.MoveRowsInternal(srcIndex, count, this.GetDstIndexFromRowBefore(srcIndex, count, rowBefore), true);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private bool CanSeparateRows(int rowIndex2)
    {
      if (this.fMergedCellCountVert > 0)
      {
        for (int colIndex = 1; colIndex < this.fColCount; ++colIndex)
        {
          if (this.GetCellDataInternal(rowIndex2, colIndex).SpanRows < 0)
            return false;
        }
      }
      return true;
    }

    private int GetDstIndexFromRowBefore(int srcIndex, int count, int rowBefore)
    {
      if (srcIndex < rowBefore)
        return rowBefore - count;
      return rowBefore;
    }

    private void MoveRowsInternal(int srcIndex, int count, int dstIndex, bool adjustScrollBars)
    {
      this.CancelAnyEdit();
      if (srcIndex == dstIndex)
        return;
      iGArrayManager.MoveElement((Array) this.fRowsMap, srcIndex, dstIndex, count);
      this.fMergedCells.OnRowRangeMoved(srcIndex, dstIndex, count);
      this.fSelectedCells.OnRowRangeMoved(srcIndex, dstIndex, count);
      this.fSelectedRows.OnRowRangeMoved(srcIndex, dstIndex, count);
      this.fLastSelectedInCellModeRowIndex = -1;
      this.CurCellAfterRowsMove(srcIndex, count, dstIndex);
      this.fRowKeys.AfterItemIndicesChanged(this.fRowCount, srcIndex, count, dstIndex);
      if (this.fRedraw)
      {
        this.NullViewportFirstRowVars();
        if (this.fVisibleRowCount != 0)
          this.AdjustViewportFirstRowVars_Plus(0);
      }
      if (this.fLastVisibleRowIndex >= srcIndex && this.fLastVisibleRowIndex < srcIndex + count)
      {
        if (dstIndex > srcIndex)
          this.fLastVisibleRowIndex = this.fLastVisibleRowIndex + (dstIndex - srcIndex);
        else
          this.fLastVisibleRowIndex = this.GetLastVisibleRowIndex(srcIndex + count - 1);
      }
      else if (this.fLastVisibleRowIndex > srcIndex && this.fLastVisibleRowIndex < dstIndex + count)
      {
        int lastVisibleRowIndex = this.GetLastVisibleRowIndex(dstIndex + count - 1, dstIndex);
        if (lastVisibleRowIndex >= 0)
          this.fLastVisibleRowIndex = lastVisibleRowIndex;
        else
          this.fLastVisibleRowIndex = this.fLastVisibleRowIndex - count;
      }
      else
      {
        if (this.fLastVisibleRowIndex >= srcIndex || this.fLastVisibleRowIndex < dstIndex)
          return;
        this.fLastVisibleRowIndex = this.fLastVisibleRowIndex + count;
      }
    }

    internal int RowKeyToIndex(string key, bool throwException)
    {
      if (!iGKeyManager.IsKeySpecified(key))
      {
        if (throwException)
          throw new ArgumentNullException();
        return -1;
      }
      int rowIndexFromKey = this.GetRowIndexFromKey(key);
      int num = -1;
      if (!(rowIndexFromKey == num & throwException))
        return rowIndexFromKey;
      throw new ArgumentException("Invalid key");
    }

    internal void SetRowKey(int rowIndex, string key, bool checkUnique)
    {
      this.CheckRowIndex(rowIndex);
      this.fRowKeys.SetItemKey(rowIndex, key, this.GetRowDataInternal(rowIndex).Key, this.fRowCount);
      this.SetRowKeyInternal(rowIndex, key);
    }

    private int GetRowIndexFromKey(string key)
    {
      return this.fRowKeys.GetItemIndexFromKey(key);
    }

    internal bool RowKeyExists(string key)
    {
      if (!iGKeyManager.IsKeySpecified(key))
        throw new ArgumentNullException();
      return this.GetRowIndexFromKey(key) != -1;
    }

    private void SetRowKeyInternal(int rowIndex, string value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetRowKey(fRows.RowIndex, value);
    }

    private void GetRowCells(int rowIndex, iGCellData[] cells)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].GetRowCells(fRows.RowIndex, cells);
    }

    internal void SetRowCellsFromPatterns(int rowIndex, iGCellPattern[] cellPatterns, int startIndex)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      iGPage fPage = this.fPages[fRows.PageIndex];
      for (int colIndex = 0; colIndex < this.fColCount; ++colIndex)
      {
        iGCellData fData = cellPatterns[startIndex + colIndex].fData;
        this.CorrectCellPatternDataToSet(rowIndex, colIndex, ref fData);
        fPage.SetCellData(fRows.RowIndex, colIndex, fData);
      }
    }

    internal int AddRowRange(int rowBefore, int count)
    {
      return this.AddRowRange(rowBefore, count, this.fDefaultRow.fRowData, true);
    }

    internal int AddRowRange(int rowBefore, int count, iGRowPattern rowPattern)
    {
      if (rowPattern == null)
        throw new ArgumentNullException();
      return this.AddRowRange(rowBefore, count, rowPattern.fRowData, true);
    }

    internal int AddRowRange(int rowBefore, int count, iGRowData rowData, bool checkGroupAndSortParams)
    {
      if (rowBefore < 0 || rowBefore > this.fRowCount)
        throw new ArgumentOutOfRangeException(nameof (rowBefore));
      if (count <= 0)
        throw new ArgumentOutOfRangeException(nameof (count), "Value cannot be less than or equal to zero");
      iGrid.CheckRowData(rowData.Height, rowData.Level);
      if (iGKeyManager.IsKeySpecified(rowData.Key) && (count > 1 || this.fRowKeys.GetItemIndexFromKey(rowData.Key) != -1))
        throw new ArgumentException("Key already exists");
      if (checkGroupAndSortParams)
      {
        if (this.fStaySorted)
          rowBefore = this.GetRowBeforeToInsert(rowData.Type, rowData.CellStyle, rowBefore);
        rowData.VisibleParentExpanded = this.GetRowBeforeVisibleParentExpanded(rowBefore, rowData.Level);
      }
      if (rowBefore > 0 && rowBefore < this.fRowCount && !this.CanSeparateRows(rowBefore))
        throw new ArgumentException("Cannot break merged cells");
      if (this.fFrozenRowCount > 0 && rowBefore + count < this.FrozenRowCount && !this.CanSeparateRows(this.FrozenRowCount - count))
        throw new ArgumentException("Frozen area edge cannot break merged cells");
      int num1 = this.IsGroupRow(rowData) ? 1 : 0;
      if (num1 != 0)
      {
        if (this.fStaySorted)
          throw new InvalidOperationException("Cannot create group rows in stay sorted mode");
        if (this.IsTreeColSpecified())
          throw new InvalidOperationException("Cannot create group rows when the tree column is different from the first");
      }
      this.CancelAnyEdit();
      this.CancelSearchAsType();
      this.AdjustMouseDataBeforeRowAdded(rowBefore, count);
      if (num1 != 0)
        this.fGroupRowCount = this.fGroupRowCount + count;
      if (!rowData.Sortable)
        this.fNotSortableRowCount = this.fNotSortableRowCount + count;
      int borderSize = 0;
      int headerSize = 0;
      bool flag1 = false;
      if (this.fAutoResizeCols)
      {
        borderSize = this.GetBorderSize();
        headerSize = this.GetHeaderAreaHeight();
        flag1 = this.GetVScrollBarVisible(headerSize, borderSize);
      }
      this.fRowKeys.BeforeAddItems(rowBefore, count);
      this.fRowsMap = (iGRowNavigator[]) iGArrayManager.ExtendArray((Array) this.fRowsMap, typeof (iGRowNavigator), rowBefore, count, this.fRowCount, false);
      int num2 = count;
      int itemIndex = rowBefore;
      for (; this.fDeletedRows.Count > 0 && num2 > 0; --num2)
      {
        iGRowNavigator iGrowNavigator = (iGRowNavigator) this.fDeletedRows.Pop();
        this.fRowsMap[itemIndex] = iGrowNavigator;
        iGPage fPage = this.fPages[iGrowNavigator.PageIndex];
        fPage.SetRowCells(iGrowNavigator.RowIndex, this.fDefaultCells);
        fPage.SetRowData(iGrowNavigator.RowIndex, rowData);
        ++itemIndex;
      }
      int num3 = num2;
      if (this.fPageCount > 0)
        num3 -= this.fPageCapacity - this.fPages[this.fPageCount - 1].fRowCount;
      int num4 = num3 >= 0 ? (num3 - 1) / this.fPageCapacity + 1 : 0;
      if (num4 + this.fPageCount > this.fPages.Length)
      {
        int length = 2 * this.fPages.Length;
        if (length < num4 + this.fPageCount)
          length = num4 + this.fPageCount;
        iGPage[] iGpageArray = new iGPage[length];
        if (this.fPageCount > 0)
          Array.Copy((Array) this.fPages, 0, (Array) iGpageArray, 0, this.fPageCount);
        this.fPages = iGpageArray;
      }
      int pageIndex;
      for (pageIndex = this.fPageCount + num4 - 1; pageIndex >= this.fPageCount; --pageIndex)
        this.fPages[pageIndex] = new iGPage(this.fPageCapacity, this.fColCount);
      this.fPageCount = this.fPageCount + num4;
      if (pageIndex < 0)
        pageIndex = 0;
      while (num2 > 0)
      {
        iGPage fPage = this.fPages[pageIndex];
        int count1 = this.fPageCapacity - fPage.fRowCount;
        if (count1 > num2)
          count1 = num2;
        if (count1 > 0)
        {
          int num5 = fPage.AddRows(count1, this.fDefaultCells, rowData);
          for (int index = 0; index < count1; ++index)
            this.fRowsMap[itemIndex++] = new iGRowNavigator(pageIndex, num5++);
          num2 -= count1;
        }
        ++pageIndex;
      }
      this.fRowCount = this.fRowCount + count;
      if (iGKeyManager.IsKeySpecified(rowData.Key))
        this.fRowKeys.SetItemKey(itemIndex, rowData.Key, (string) null, this.fRowCount);
      bool flag2 = this.IsRowVisibleInternal(rowData.Visible, rowData.VisibleParentExpanded);
      if (flag2)
      {
        this.fVisibleRowsHeight = this.fVisibleRowsHeight + count * rowData.Height;
        this.fVisibleRowCount = this.fVisibleRowCount + count;
      }
      if (rowBefore > this.fLastVisibleRowIndex)
      {
        if (flag2)
          this.fLastVisibleRowIndex = rowBefore + count - 1;
      }
      else
        this.fLastVisibleRowIndex = this.fLastVisibleRowIndex + count;
      this.fMergedCells.OnRowRangeAdded(rowBefore, count);
      this.fSelectedCells.OnRowRangeAdded(rowBefore, count);
      this.fSelectedRows.OnRowRangeAdded(rowBefore, count);
      this.fLastSelectedInCellModeRowIndex = -1;
      this.CurCellOnRowAdded(rowBefore, count);
      if (this.fAutoResizeCols && flag1 != this.GetVScrollBarVisible(headerSize, borderSize))
        this.DoAutoResizeCols(0, 0, false, true, true);
      this.OnRowsAdded(new iGRowSetChangeEventArgs(rowBefore, count));
      this.RecalcTotals();
      if (this.fRedraw && this.fViewportFirstRowIndex >= rowBefore && this.IsScrollableVert())
      {
        int num5;
        int num6;
        if (rowBefore < this.fFrozenRowCount)
        {
          num5 = rowBefore + count - this.fFrozenRowCount;
          if (num5 < 0)
            num5 = 0;
          num6 = this.fFrozenRowCount - rowBefore;
          if (count < num6)
            num6 = count;
        }
        else
        {
          num5 = count;
          num6 = 0;
        }
        this.fViewportFirstRowIndex = this.fViewportFirstRowIndex + count;
        int num7 = 0;
        if (this.IsRowVisibleInternal(rowData.Visible, rowData.VisibleParentExpanded))
        {
          this.fViewportFirstRowVisibleCountBefore = this.fViewportFirstRowVisibleCountBefore + count;
          num7 += num5 * rowData.Height;
        }
        if (num6 > 0)
        {
          int num8 = rowBefore + count;
          if (num8 < this.fFrozenRowCount)
            num8 = this.fFrozenRowCount;
          for (int rowIndex = num8 + num6 - 1; rowIndex >= num8; --rowIndex)
          {
            iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
            if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
              num7 += rowDataInternal.Height;
          }
        }
        if (num7 > 0)
          this.AdjustViewportFirstRowVars_Minus(this.fVScrollBar.Value - this.fViewportFirstRowHiddenHeight + num7);
      }
      this.RefreshGridAndScrollBarsIfRedraw();
      return rowBefore;
    }

    internal void RemoveRowRange(int rowIndex, int count)
    {
      this.CheckRowIndexAndCount(rowIndex, count, nameof (count));
      if (rowIndex > 0 && !this.CanSeparateRows(rowIndex))
        throw new ArgumentException("Cannot break merged cells");
      if (rowIndex + count < this.fRowCount && !this.CanSeparateRows(rowIndex + count))
        throw new ArgumentException("Cannot break merged cells");
      if (this.fFrozenRowCount > 0 && rowIndex < this.FrozenRowCount && (this.FrozenRowCount + count < this.fRowCount && !this.CanSeparateRows(this.FrozenRowCount + count)))
        throw new ArgumentException("Frozen area edge cannot break merged cells");
      iGRowSetChangeEventArgs e = new iGRowSetChangeEventArgs(rowIndex, count);
      this.OnRowsRemoving(e);
      this.CancelAnyEdit();
      this.CancelSearchAsType();
      bool flag = false;
      int borderSize = 0;
      int headerSize = 0;
      if (this.fAutoResizeCols)
      {
        borderSize = this.GetBorderSize();
        headerSize = this.GetHeaderAreaHeight();
        flag = this.GetVScrollBarVisible(headerSize, borderSize);
      }
      this.AdjustMouseDataBeforeRowRemoved(rowIndex, count);
      this.fRowKeys.BeforeRemoveItems(rowIndex, count);
      int top = this.fVScrollBar.Value - this.fViewportFirstRowHiddenHeight;
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      int num4 = 0;
      int num5 = rowIndex + count;
      if (num5 < this.fFrozenRowCount)
        num5 = this.fFrozenRowCount;
      for (int index = rowIndex + count - 1; index >= rowIndex; --index)
      {
        iGRowNavigator fRows = this.fRowsMap[index];
        this.fDeletedRows.Push((object) fRows);
        iGRowData rowData = this.fPages[fRows.PageIndex].GetRowData(fRows.RowIndex);
        if (this.IsGroupRow(rowData))
          this.fGroupRowCount = this.fGroupRowCount - 1;
        if (!rowData.Sortable)
          this.fNotSortableRowCount = this.fNotSortableRowCount - 1;
        if (this.IsRowVisibleInternal(rowData.Visible, rowData.VisibleParentExpanded))
        {
          num1 += rowData.Height;
          ++num2;
          if (index < this.fViewportFirstRowIndex)
          {
            ++num3;
            ++num4;
            if (index >= this.fFrozenRowCount)
              top -= rowData.Height;
          }
        }
        else if (index <= this.fViewportFirstRowIndex)
          ++num4;
        if (this.IsScrollableVert() && index < this.fFrozenRowCount && num5 < this.fRowCount)
        {
          iGRowData rowDataInternal = this.GetRowDataInternal(num5++);
          if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
            top -= rowDataInternal.Height;
        }
      }
      this.fVisibleRowsHeight = this.fVisibleRowsHeight - num1;
      this.fVisibleRowCount = this.fVisibleRowCount - num2;
      int length = this.fRowCount - count - rowIndex;
      if (length > 0)
        Array.Copy((Array) this.fRowsMap, rowIndex + count, (Array) this.fRowsMap, rowIndex, length);
      this.fRowCount = this.fRowCount - count;
      if (this.fLastVisibleRowIndex >= rowIndex && this.fLastVisibleRowIndex < rowIndex + count)
        this.fLastVisibleRowIndex = this.GetLastVisibleRowIndex(rowIndex - 1);
      else if (this.fLastVisibleRowIndex > rowIndex)
        this.fLastVisibleRowIndex = this.fLastVisibleRowIndex - count;
      this.fMergedCells.OnRowRangeRemoved(rowIndex, count);
      this.fSelectedCells.OnRowRangeRemoved(rowIndex, count);
      this.fSelectedRows.OnRowRangeRemoved(rowIndex, count);
      this.fLastSelectedInCellModeRowIndex = -1;
      this.CurCellOnRowRemoved(rowIndex, count);
      if (this.fAutoResizeCols && flag != this.GetVScrollBarVisible(headerSize, borderSize))
        this.DoAutoResizeCols(0, 0, false, true, true);
      this.OnRowsRemoved(e);
      this.RecalcTotals();
      if (this.fRedraw && rowIndex <= this.fViewportFirstRowIndex && this.IsScrollableVert())
      {
        this.fViewportFirstRowIndex = this.fViewportFirstRowIndex - num4;
        this.fViewportFirstRowVisibleCountBefore = this.fViewportFirstRowVisibleCountBefore - num3;
        if (this.fRowCount > this.fFrozenRowCount)
        {
          if (this.fViewportFirstRowIndex < this.fFrozenRowCount)
            this.NullViewportFirstRowVars();
          this.AdjustViewportFirstRowVars_Plus(top);
        }
      }
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal void ClearRows()
    {
      this.CancelAnyEdit();
      this.EmptyMouse();
      this.CancelSearchAsType();
      this.fRowKeys.Clear();
      this.fGroupRowCount = 0;
      this.fNotSortableRowCount = 0;
      bool flag = false;
      if (this.fAutoResizeCols)
        flag = this.GetVScrollBarVisible(this.GetHeaderAreaHeight(), this.GetBorderSize());
      this.fRowCount = 0;
      for (int index = 0; index < this.fPageCount; ++index)
        this.fPages[index] = (iGPage) null;
      this.fPageCount = 0;
      this.fDeletedRows.Clear();
      this.fVisibleRowsHeight = 0;
      this.fVisibleRowCount = 0;
      this.fLastVisibleRowIndex = -1;
      this.fMergedCells.Clear();
      this.fSelectedCells.Clear();
      this.fSelectedRows.Clear();
      this.CurCellOnRowsClear();
      if (flag)
        this.DoAutoResizeCols(false);
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal iGRowData GetRowData(int rowIndex)
    {
      this.CheckRowIndex(rowIndex);
      return this.GetRowDataInternal(rowIndex);
    }

    internal iGRowData GetRowDataInternal(int rowIndex)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      return this.fPages[fRows.PageIndex].GetRowData(fRows.RowIndex);
    }

    internal iGRow GetParentRow(int rowIndex)
    {
      int num = this.GetRowDataInternal(rowIndex).Level - 1;
      if (num < 0)
        return (iGRow) null;
      for (int index = rowIndex - 1; index >= 0; --index)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(index);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded) && rowDataInternal.Level == num)
          return new iGRow(this, index);
      }
      return (iGRow) null;
    }

    internal void SetRowHeight(int rowIndex, int value)
    {
      this.CheckRowIndex(rowIndex);
      iGrid.CheckRowHeight(value);
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      iGPage fPage = this.fPages[fRows.PageIndex];
      iGRowData rowData = fPage.GetRowData(fRows.RowIndex);
      if (rowData.Height == value)
        return;
      int borderSize = 0;
      int headerSize = 0;
      bool flag = false;
      if (this.fAutoResizeCols)
      {
        borderSize = this.GetBorderSize();
        headerSize = this.GetHeaderAreaHeight();
        flag = this.GetVScrollBarVisible(headerSize, borderSize);
      }
      int height = rowData.Height;
      rowData.Height = value;
      fPage.SetRowData(fRows.RowIndex, rowData);
      if (!this.IsRowVisibleInternal(rowData.Visible, rowData.VisibleParentExpanded))
        return;
      bool adjustScrollBars = this.RowHeightChanged(rowIndex, value - height);
      if (this.fAutoResizeCols && flag != this.GetVScrollBarVisible(headerSize, borderSize))
        this.DoAutoResizeCols(0, 0, false, true, true);
      this.RefreshGridAndScrollBarsIfRedraw(adjustScrollBars);
    }

    internal void SetRowType(int rowIndex, iGRowType value)
    {
      this.CheckRowIndex(rowIndex);
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      iGRowType type = this.fPages[fRows.PageIndex].GetRowData(fRows.RowIndex).Type;
      if (type == value)
        return;
      if (!this.IsGroupRow(type))
      {
        if (this.IsGroupRow(value))
        {
          if (this.fStaySorted)
            throw new InvalidOperationException("Cannot create group rows in stay sorted mode");
          if (this.IsTreeColSpecified())
            throw new InvalidOperationException("Cannot create group rows when the tree column is different from the first");
          this.fGroupRowCount = this.fGroupRowCount + 1;
        }
      }
      else if (!this.IsGroupRow(value))
        this.fGroupRowCount = this.fGroupRowCount - 1;
      this.fPages[fRows.PageIndex].SetRowType(fRows.RowIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void SetRowDataNoVisibleHeightTypeSortableChange(int rowIndex, iGRowData value)
    {
      this.CheckRowIndex(rowIndex);
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetRowData(fRows.RowIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private bool RowHeightChanged(int rowIndex, int deltaHeight)
    {
      this.fVisibleRowsHeight = this.fVisibleRowsHeight + deltaHeight;
      if (!this.fRedraw)
        return false;
      if (rowIndex <= this.fViewportFirstRowIndex && rowIndex >= this.fFrozenRowCount)
      {
        if (rowIndex < this.fViewportFirstRowIndex)
          this.fViewportFirstRowHiddenHeight = this.fViewportFirstRowHiddenHeight - deltaHeight;
        if (deltaHeight > 0)
          this.AdjustViewportFirstRowVars_Minus(this.fVScrollBar.Value - this.fViewportFirstRowHiddenHeight);
        else
          this.AdjustViewportFirstRowVars_Plus(this.fVScrollBar.Value - this.fViewportFirstRowHiddenHeight);
      }
      return true;
    }

    internal bool RowHeightOrVisibleChanged(int rowIndex, bool oldVisible, bool newVisible, int oldHeight, int newHeight)
    {
      if (newVisible)
      {
        if (oldVisible)
        {
          int deltaHeight = newHeight - oldHeight;
          if (deltaHeight != 0 && this.RowHeightChanged(rowIndex, deltaHeight))
            return true;
        }
        else
        {
          this.fVisibleRowsHeight = this.fVisibleRowsHeight + newHeight;
          this.fVisibleRowCount = this.fVisibleRowCount + 1;
          if (rowIndex > this.fLastVisibleRowIndex)
            this.fLastVisibleRowIndex = rowIndex;
          if (this.fRedraw)
          {
            if (rowIndex < this.fViewportFirstRowIndex)
            {
              if (rowIndex >= this.fFrozenRowCount)
                this.AdjustViewportFirstRowVars_Minus(this.fVScrollBar.Value - this.fViewportFirstRowHiddenHeight + newHeight);
              this.fViewportFirstRowVisibleCountBefore = this.fViewportFirstRowVisibleCountBefore + 1;
            }
            return true;
          }
        }
      }
      else if (oldVisible)
      {
        this.fVisibleRowsHeight = this.fVisibleRowsHeight - oldHeight;
        this.fVisibleRowCount = this.fVisibleRowCount - 1;
        if (rowIndex == this.fLastVisibleRowIndex)
          this.fLastVisibleRowIndex = this.GetLastVisibleRowIndex(rowIndex - 1);
        if (this.fRedraw)
        {
          if (rowIndex <= this.fViewportFirstRowIndex)
          {
            if (rowIndex >= this.fFrozenRowCount)
              this.AdjustViewportFirstRowVars_Plus(this.fVScrollBar.Value - this.fViewportFirstRowHiddenHeight - oldHeight);
            this.fViewportFirstRowVisibleCountBefore = this.fViewportFirstRowVisibleCountBefore - 1;
          }
          return true;
        }
      }
      return false;
    }

    internal void SetRowData(int rowIndex, iGRowData value)
    {
      this.CheckRowIndex(rowIndex);
      iGrid.CheckRowData(value.Height, value.Level);
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      iGPage fPage = this.fPages[fRows.PageIndex];
      iGRowData rowData = fPage.GetRowData(fRows.RowIndex);
      this.fRowKeys.SetItemKey(rowIndex, value.Key, rowData.Key, this.fRowCount);
      if (!this.IsGroupRow(rowData))
      {
        if (this.IsGroupRow(value))
        {
          if (this.fStaySorted)
            throw new InvalidOperationException("Cannot create group rows in stay sorted mode");
          if (this.IsTreeColSpecified())
            throw new InvalidOperationException("Cannot create group rows when the tree column is different from the first");
          this.fGroupRowCount = this.fGroupRowCount + 1;
        }
      }
      else if (!this.IsGroupRow(value))
        this.fGroupRowCount = this.fGroupRowCount - 1;
      if (rowData.Sortable != value.Sortable)
        this.fNotSortableRowCount = !value.Sortable ? this.fNotSortableRowCount + 1 : this.fNotSortableRowCount - 1;
      int borderSize = 0;
      int headerSize = 0;
      bool flag = false;
      if (this.fAutoResizeCols)
      {
        borderSize = this.GetBorderSize();
        headerSize = this.GetHeaderAreaHeight();
        flag = this.GetVScrollBarVisible(headerSize, borderSize);
      }
      if (value.Visible)
        fPage.SetRowData(fRows.RowIndex, value);
      bool adjustScrollBars = this.RowHeightOrVisibleChanged(rowIndex, this.IsRowVisibleInternal(rowData.Visible, rowData.VisibleParentExpanded), this.IsRowVisibleInternal(value.Visible, value.VisibleParentExpanded), rowData.Height, value.Height);
      if (!value.Visible)
        fPage.SetRowData(fRows.RowIndex, value);
      if (this.fAutoResizeCols && flag != this.GetVScrollBarVisible(headerSize, borderSize))
        this.DoAutoResizeCols(0, 0, false, true, true);
      this.RefreshGridAndScrollBarsIfRedraw(adjustScrollBars);
    }

    internal void SetRowVisible(int rowIndex, bool value)
    {
      this.CheckRowIndex(rowIndex);
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      iGPage fPage = this.fPages[fRows.PageIndex];
      iGRowData rowData = fPage.GetRowData(fRows.RowIndex);
      if (rowData.Visible == value)
        return;
      int borderSize = 0;
      int headerSize = 0;
      bool flag = false;
      if (this.fAutoResizeCols)
      {
        borderSize = this.GetBorderSize();
        headerSize = this.GetHeaderAreaHeight();
        flag = this.GetVScrollBarVisible(headerSize, borderSize);
      }
      if (value)
      {
        rowData.Visible = value;
        fPage.SetRowData(fRows.RowIndex, rowData);
      }
      bool adjustScrollBars = this.RowHeightOrVisibleChanged(rowIndex, this.IsRowVisibleInternal(!value, rowData.VisibleParentExpanded), this.IsRowVisibleInternal(value, rowData.VisibleParentExpanded), rowData.Height, rowData.Height);
      if (!value)
      {
        rowData.Visible = value;
        fPage.SetRowData(fRows.RowIndex, rowData);
      }
      if (this.fAutoResizeCols && flag != this.GetVScrollBarVisible(headerSize, borderSize))
        this.DoAutoResizeCols(0, 0, false, true, true);
      this.OnRowVisibleChanged(new iGRowVisibleChangedEventArgs(rowIndex, value));
      this.RecalcTotals();
      this.RefreshGridAndScrollBarsIfRedraw(adjustScrollBars);
    }

    internal void CheckRowIndex(int rowIndex)
    {
      if (rowIndex < 0 || rowIndex >= this.fRowCount)
        throw new ArgumentOutOfRangeException();
    }

    private void CheckRowIndexAndCount(int rowIndex, int count, string countParamName)
    {
      if (count <= 0)
        throw new ArgumentOutOfRangeException(countParamName, "Value cannot be less than or equal to zero");
      if (rowIndex < 0 || rowIndex >= this.fRowCount)
        throw new ArgumentOutOfRangeException(nameof (rowIndex));
      if (rowIndex + count > this.fRowCount)
        throw new ArgumentException("Invalid row index or count");
    }

    internal static void CheckRowHeight(int height)
    {
      if (height < 0)
        throw new ArgumentOutOfRangeException("value", "Height cannot be negative");
    }

    internal static void CheckRowData(int height, int level)
    {
      iGrid.CheckRowHeight(height);
      iGrid.CheckRowLevel(level);
    }

    internal static void CheckRowLevel(int level)
    {
      if (level < 0)
        throw new ArgumentOutOfRangeException("value", "Level cannot be negative");
    }

    internal void SetRowLevel(int rowIndex, int value)
    {
      this.CheckRowIndex(rowIndex);
      iGrid.CheckRowLevel(value);
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetRowLevel(fRows.RowIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void SetRowSortable(int rowIndex, bool value)
    {
      this.CheckRowIndex(rowIndex);
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      if (this.fPages[fRows.PageIndex].GetRowData(fRows.RowIndex).Sortable == value)
        return;
      this.fNotSortableRowCount = !value ? this.fNotSortableRowCount + 1 : this.fNotSortableRowCount - 1;
      this.fPages[fRows.PageIndex].SetRowSortable(fRows.RowIndex, value);
    }

    internal void SetRowSelectable(int rowIndex, bool value)
    {
      this.CheckRowIndex(rowIndex);
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      if (this.fPages[fRows.PageIndex].GetRowData(fRows.RowIndex).Selectable == value)
        return;
      this.fPages[fRows.PageIndex].SetRowSelectable(fRows.RowIndex, value);
    }

    internal void SetRowTreeButton(int rowIndex, iGTreeButtonState value)
    {
      this.CheckRowIndex(rowIndex);
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetRowTreeButton(fRows.RowIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void SetRowLevelAndExpandedInternal(int rowIndex, int level, bool expanded)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetRowLevelAndExpanded(fRows.RowIndex, level, expanded);
    }

    internal void SetRowExpandedInternal(int rowIndex, bool value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetRowExpanded(fRows.RowIndex, value);
    }

    internal void SetRowCellStyle(int rowIndex, iGCellStyle value)
    {
      this.CheckRowIndex(rowIndex);
      this.SetRowCellStyleInternal(rowIndex, value);
    }

    internal void SetRowCellStyleInternal(int rowIndex, iGCellStyle value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetRowCellStyle(fRows.RowIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void CheckCellIndices(int rowIndex, int colIndex)
    {
      this.CheckRowIndex(rowIndex);
      this.CheckColIndex(colIndex);
    }

    internal iGCellData GetCellDataInternal(int rowIndex, int colIndex)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      return this.fPages[fRows.PageIndex].GetCellData(fRows.RowIndex, colIndex);
    }

    internal iGCellData GetCellData(int rowIndex, int colIndex)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      return this.GetCellDataInternal(rowIndex, colIndex);
    }

    internal iGCellData GetCellDataPublicSpanProps(int rowIndex, int colIndex)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      if (cellDataInternal.SpanCols < 1)
        cellDataInternal.SpanCols = 1;
      if (cellDataInternal.SpanRows < 1)
        cellDataInternal.SpanRows = 1;
      return cellDataInternal;
    }

    internal void SetCellDataInternal(int rowIndex, int colIndex, iGCellData value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetCellData(fRows.RowIndex, colIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void CorrectCellPatternDataToSet(int rowIndex, int colIndex, ref iGCellData newCellData)
    {
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      if (cellDataInternal.SpanCols >= 1 && cellDataInternal.SpanRows >= 1)
      {
        if (newCellData.SpanCols != cellDataInternal.SpanCols)
        {
          this.CheckCellSpanColsValueCanSet(rowIndex, colIndex, newCellData.SpanCols);
          this.SetCellSpanColsCore(rowIndex, colIndex, newCellData.SpanCols);
        }
        if (newCellData.SpanRows == cellDataInternal.SpanRows)
          return;
        this.CheckCellSpanRowsValueCanSet(rowIndex, colIndex, newCellData.SpanRows);
        this.SetCellSpanRowsCore(rowIndex, colIndex, newCellData.SpanRows);
      }
      else
      {
        if (newCellData.SpanCols != 1 || newCellData.SpanRows != 1)
          throw new ArgumentException("Merged cells cannot overlap");
        newCellData.SpanCols = cellDataInternal.SpanCols;
        newCellData.SpanRows = cellDataInternal.SpanRows;
      }
    }

    internal void SetCellPattern(int rowIndex, int colIndex, iGCellData cellData)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      if (this.NeedIndexAdjustAfterValueChange(rowIndex, colIndex, iGSortType.ByValue | iGSortType.ByText | iGSortType.ByTextNoCase | iGSortType.ByImageIndex | iGSortType.ByForeColor | iGSortType.ByBackColor | iGSortType.ByFont | iGSortType.Custom))
        this.OnCellSortParamChanged(ref rowIndex, colIndex, cellData, this.GetRowDataInternal(rowIndex).CellStyle);
      this.CorrectCellPatternDataToSet(rowIndex, colIndex, ref cellData);
      this.SetCellDataInternal(rowIndex, colIndex, cellData);
    }

    internal void OnCellSortParamChanged(ref int rowIndex, int colIndex, iGCellData newCellData, iGCellStyle newRowStyle)
    {
      iGCellData[] cells = new iGCellData[this.fColCount];
      this.GetRowCells(rowIndex, cells);
      if (colIndex >= 0)
        cells[colIndex] = newCellData;
      int indexFromRowBefore = this.GetDstIndexFromRowBefore(rowIndex, 1, this.GetRowBeforeToInsert(this.GetRowDataInternal(rowIndex).Type, newRowStyle, cells, rowIndex, this.fFrozenRowCount, this.fSortFrozenRows));
      this.MoveRowsInternal(rowIndex, 1, indexFromRowBefore, true);
      rowIndex = indexFromRowBefore;
    }

    internal void SetCellValueInternal(int rowIndex, int colIndex, object value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetCellValue(fRows.RowIndex, colIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal int SetCellValue(int rowIndex, int colIndex, object value, bool ensureVisible, bool modifyAuxValueAndImageIndex, bool recalcTotals)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      if (this.NeedIndexAdjustAfterValueChange(rowIndex, colIndex, iGSortType.ByValue | iGSortType.ByText | iGSortType.ByTextNoCase | iGSortType.Custom))
      {
        iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
        cellDataInternal.Value = value;
        iGCellStyle cellStyle = this.GetRowDataInternal(rowIndex).CellStyle;
        this.OnCellSortParamChanged(ref rowIndex, colIndex, cellDataInternal, cellStyle);
      }
      this.SetCellValueInternal(rowIndex, colIndex, value);
      if (recalcTotals)
        this.RecalcTotals();
      if (modifyAuxValueAndImageIndex)
        this.SetAuxValueAndImageIndexAfterValueChanged(rowIndex, colIndex, value, ensureVisible);
      if (ensureVisible)
        this.EnsureVisibleRow(rowIndex);
      return rowIndex;
    }

    internal void SetAuxValueAndImageIndexAfterValueChanged(int rowIndex, int colIndex, object value, bool ensureVisible)
    {
      iGCellStyle style = this.GetCellDataInternal(rowIndex, colIndex).Style;
      iGCellStyle cellStyle1 = this.GetRowDataInternal(rowIndex).CellStyle;
      iGCellStyle cellStyle2 = this.GetColData(colIndex).CellStyle;
      IiGDropDownControl cellDropDownControl = this.GetUniCellDropDownControl(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2, false);
      if (!this.CanEditCellWithDropDown(this.GetPropFromStyles_DrawType((iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2), cellDropDownControl))
        return;
      object itemByValue = cellDropDownControl.GetItemByValue(value, false);
      this.SetCellAuxValue(rowIndex, colIndex, itemByValue, ensureVisible);
      if (itemByValue == null)
        return;
      this.SetCellImageIndex(rowIndex, colIndex, cellDropDownControl.GetItemImageIndex(itemByValue), ensureVisible);
    }

    internal void SetCellAuxValueInternal(int rowIndex, int colIndex, object value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetCellAuxValue(fRows.RowIndex, colIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal int SetCellAuxValue(int rowIndex, int colIndex, object value, bool ensureVisible)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      bool flag = this.NeedIndexAdjustAfterValueChange(rowIndex, colIndex, iGSortType.ByAuxValue | iGSortType.Custom);
      if (!flag && this.NeedIndexAdjustAfterValueChange(rowIndex, colIndex, iGSortType.ByText | iGSortType.ByTextNoCase) && this.CanEditCellWithDropDown(rowIndex, colIndex))
        flag = true;
      if (flag)
      {
        iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
        cellDataInternal.AuxValue = value;
        iGCellStyle cellStyle = this.GetRowDataInternal(rowIndex).CellStyle;
        this.OnCellSortParamChanged(ref rowIndex, colIndex, cellDataInternal, cellStyle);
      }
      this.SetCellAuxValueInternal(rowIndex, colIndex, value);
      if (ensureVisible)
        this.EnsureVisibleRow(rowIndex);
      return rowIndex;
    }

    internal void SetCellImageIndexInternal(int rowIndex, int colIndex, int value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetCellImageIndex(fRows.RowIndex, colIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal int SetCellImageIndex(int rowIndex, int colIndex, int value, bool ensureVisible)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      if (this.NeedIndexAdjustAfterValueChange(rowIndex, colIndex, iGSortType.ByImageIndex | iGSortType.Custom))
      {
        iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
        cellDataInternal.ImageIndex = value;
        iGCellStyle cellStyle = this.GetRowDataInternal(rowIndex).CellStyle;
        this.OnCellSortParamChanged(ref rowIndex, colIndex, cellDataInternal, cellStyle);
      }
      this.SetCellImageIndexInternal(rowIndex, colIndex, value);
      if (ensureVisible)
        this.EnsureVisibleRow(rowIndex);
      return rowIndex;
    }

    internal void SetCellStyleInternal(int rowIndex, int colIndex, iGCellStyle value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetCellStyle(fRows.RowIndex, colIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal int SetCellStyle(int rowIndex, int colIndex, iGCellStyle value, bool ensureVisible)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      if (this.NeedIndexAdjustAfterValueChange(rowIndex, colIndex, iGSortType.ByForeColor | iGSortType.ByBackColor | iGSortType.ByFont | iGSortType.Custom))
      {
        iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
        cellDataInternal.Style = value;
        iGCellStyle cellStyle = this.GetRowDataInternal(rowIndex).CellStyle;
        this.OnCellSortParamChanged(ref rowIndex, colIndex, cellDataInternal, cellStyle);
      }
      this.SetCellStyleInternal(rowIndex, colIndex, value);
      if (ensureVisible)
        this.EnsureVisibleRow(rowIndex);
      return rowIndex;
    }

    internal void SetCellSpanCols(int rowIndex, int colIndex, int value)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      iGrid.CheckSpanColsValue(value);
      if (this.GetCellDataInternal(rowIndex, colIndex).SpanCols == value)
        return;
      this.CheckCellSpanColsValueCanSet(rowIndex, colIndex, value);
      this.SetCellSpanColsCore(rowIndex, colIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void CheckCellSpanColsValueCanSet(int rowIndex, int colIndex, int value)
    {
      int colOrder = this.GetColOrder(colIndex);
      iGCellData cellDataInternal1 = this.GetCellDataInternal(rowIndex, colIndex);
      if (colOrder + value - 1 >= this.fColCount)
        throw new ArgumentException("Invalid column index or count");
      if (cellDataInternal1.SpanCols < 1 || cellDataInternal1.SpanRows < 1)
        throw new ArgumentException("Merged cells cannot overlap");
      if (this.fFrozenColCount > 1 && value > 1 && (colOrder < this.fFrozenColCount && colOrder + value - 1 >= this.fFrozenColCount))
        throw new ArgumentException("Frozen area edge cannot break merged cells");
      if (value > 1 && value > cellDataInternal1.SpanCols)
      {
        for (int spanCols = cellDataInternal1.SpanCols; spanCols < value; ++spanCols)
        {
          for (int index = 0; index < cellDataInternal1.SpanRows; ++index)
          {
            iGCellData cellDataInternal2 = this.GetCellDataInternal(rowIndex + index, this.fColIdxFromOrd[colOrder + spanCols]);
            if (cellDataInternal2.SpanCols != 1 || cellDataInternal2.SpanRows != 1)
              throw new ArgumentException("Merged cells cannot overlap");
          }
        }
      }
      if (value <= 1 || !this.IsRowTextDisplayed())
        return;
      int num = colOrder + value - 1;
      if (colOrder < this.fRowTextStartColNear && this.fRowTextStartColNear <= num)
        throw new ArgumentException("Row text cells and merged cells cannot overlap");
      int rowTextEndColOrder = this.GetRowTextEndColOrder();
      if (colOrder <= rowTextEndColOrder && rowTextEndColOrder < num)
        throw new ArgumentException("Row text cells and merged cells cannot overlap");
    }

    private void SetCellSpanColsCore(int rowIndex, int colIndex, int value)
    {
      int colOrder = this.GetColOrder(colIndex);
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      if (value < cellDataInternal.SpanCols)
      {
        for (int index1 = value; index1 < cellDataInternal.SpanCols; ++index1)
        {
          int colIndex1 = this.fColIdxFromOrd[colOrder + index1];
          for (int index2 = 0; index2 < cellDataInternal.SpanRows; ++index2)
            this.SetCellSpanColsRowsInternalNoRedraw(rowIndex + index2, colIndex1, 1, 1);
        }
      }
      else
      {
        for (int spanCols = cellDataInternal.SpanCols; spanCols < value; ++spanCols)
        {
          int colIndex1 = this.fColIdxFromOrd[colOrder + spanCols];
          for (int index = 0; index < cellDataInternal.SpanRows; ++index)
            this.SetCellSpanColsRowsInternalNoRedraw(rowIndex + index, colIndex1, -spanCols, -index);
        }
      }
      this.SetCellSpanColsInternalNoRedraw(rowIndex, colIndex, value);
      if (cellDataInternal.SpanRows == 1)
      {
        if (cellDataInternal.SpanCols == 1)
        {
          this.fMergedCellCountAll = this.fMergedCellCountAll + 1;
          this.fMergedCells.Add(new iGCellNavigator(rowIndex, colIndex));
        }
        else if (value == 1)
        {
          this.fMergedCellCountAll = this.fMergedCellCountAll - 1;
          this.fMergedCells.Remove(new iGCellNavigator(rowIndex, colIndex));
        }
      }
      if (cellDataInternal.SpanCols == 1)
      {
        this.fMergedCellCountHorz = this.fMergedCellCountHorz + 1;
      }
      else
      {
        if (value != 1)
          return;
        this.fMergedCellCountHorz = this.fMergedCellCountHorz - 1;
      }
    }

    internal void SetCellSpanRows(int rowIndex, int colIndex, int value)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      iGrid.CheckSpanRowsValue(value);
      if (this.GetCellDataInternal(rowIndex, colIndex).SpanRows == value)
        return;
      this.CheckCellSpanRowsValueCanSet(rowIndex, colIndex, value);
      this.SetCellSpanRowsCore(rowIndex, colIndex, value);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void CheckCellSpanRowsValueCanSet(int rowIndex, int colIndex, int value)
    {
      int colOrder = this.GetColOrder(colIndex);
      iGCellData cellDataInternal1 = this.GetCellDataInternal(rowIndex, colIndex);
      if (rowIndex + value - 1 >= this.fRowCount)
        throw new ArgumentException("Invalid row index or count");
      if (cellDataInternal1.SpanCols < 1 || cellDataInternal1.SpanRows < 1)
        throw new ArgumentException("Merged cells cannot overlap");
      if (this.fFrozenRowCount > 0 && value > 1 && (rowIndex < this.fFrozenRowCount && rowIndex + value - 1 >= this.fFrozenRowCount))
        throw new ArgumentException("Frozen area edge cannot break merged cells");
      if (value > 1 && value > cellDataInternal1.SpanRows)
      {
        for (int spanRows = cellDataInternal1.SpanRows; spanRows < value; ++spanRows)
        {
          int rowIndex1 = rowIndex + spanRows;
          if (this.IsGroupRow(rowIndex1))
            throw new ArgumentException("Group rows cannot break merged cells");
          for (int index = 0; index < cellDataInternal1.SpanCols; ++index)
          {
            iGCellData cellDataInternal2 = this.GetCellDataInternal(rowIndex1, this.fColIdxFromOrd[colOrder + index]);
            if (cellDataInternal2.SpanCols != 1 || cellDataInternal2.SpanRows != 1)
              throw new ArgumentException("Merged cells cannot overlap");
          }
        }
      }
      if (value > 1 && this.IsRowTextDisplayed() && (colOrder >= this.fRowTextStartColNear && colOrder <= this.GetRowTextEndColOrder()))
        throw new ArgumentException("Row text cells and merged cells cannot overlap");
    }

    private void SetCellSpanRowsCore(int rowIndex, int colIndex, int value)
    {
      int colOrder = this.GetColOrder(colIndex);
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      if (value < cellDataInternal.SpanRows)
      {
        for (int index1 = 0; index1 < cellDataInternal.SpanCols; ++index1)
        {
          int num = this.fColIdxFromOrd[colOrder + index1];
          for (int index2 = value; index2 < cellDataInternal.SpanRows; ++index2)
            this.SetCellSpanColsRowsInternalNoRedraw(rowIndex + index2, this.fColIdxFromOrd[colOrder + index1], 1, 1);
        }
      }
      else
      {
        for (int index = 0; index < cellDataInternal.SpanCols; ++index)
        {
          int colIndex1 = this.fColIdxFromOrd[colOrder + index];
          for (int spanRows = cellDataInternal.SpanRows; spanRows < value; ++spanRows)
            this.SetCellSpanColsRowsInternalNoRedraw(rowIndex + spanRows, colIndex1, -index, -spanRows);
        }
      }
      this.SetCellSpanRowsInternalNoRedraw(rowIndex, colIndex, value);
      if (cellDataInternal.SpanCols == 1)
      {
        if (cellDataInternal.SpanRows == 1)
        {
          this.fMergedCellCountAll = this.fMergedCellCountAll + 1;
          this.fMergedCells.Add(new iGCellNavigator(rowIndex, colIndex));
        }
        else if (value == 1)
        {
          this.fMergedCellCountAll = this.fMergedCellCountAll - 1;
          this.fMergedCells.Remove(new iGCellNavigator(rowIndex, colIndex));
        }
      }
      if (cellDataInternal.SpanRows == 1)
      {
        this.fMergedCellCountVert = this.fMergedCellCountVert + 1;
      }
      else
      {
        if (value != 1)
          return;
        this.fMergedCellCountVert = this.fMergedCellCountVert - 1;
      }
    }

    private void SetCellSpanColsInternalNoRedraw(int rowIndex, int colIndex, int value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetCellSpanCols(fRows.RowIndex, colIndex, value);
    }

    private void SetCellSpanRowsInternalNoRedraw(int rowIndex, int colIndex, int value)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetCellSpanRows(fRows.RowIndex, colIndex, value);
    }

    private void SetCellSpanColsRowsInternalNoRedraw(int rowIndex, int colIndex, int valueCols, int valueRows)
    {
      iGRowNavigator fRows = this.fRowsMap[rowIndex];
      this.fPages[fRows.PageIndex].SetCellSpanColsRows(fRows.RowIndex, colIndex, valueCols, valueRows);
    }

    private void OnColAllowSizingChanged(bool allowSizingNew, bool allowSizingOld)
    {
      if (!this.fAutoResizeCols || allowSizingNew == allowSizingOld)
        return;
      this.NullOldColWidths();
    }

    private void CheckColData(int colIndex, iGColData value)
    {
      iGrid.CheckColWidth(value.Width, value.MinWidth, value.MaxWidth);
      if (value.CellStyle == null || value.ColHdrStyle == null)
        throw new ArgumentNullException("Style cannot be null");
    }

    private void CheckColIndexAndCount(int colIndex, int count, string colIndexParamName)
    {
      if (count <= 0)
        throw new ArgumentOutOfRangeException(nameof (count), "Value cannot be less than or equal to zero");
      if (colIndex < 0 || colIndex >= this.fColCount)
        throw new ArgumentOutOfRangeException(colIndexParamName);
      if (colIndex + count > this.fColCount)
        throw new ArgumentException("Invalid column index or count", colIndexParamName);
    }

    private void MoveColsInColIdxFromOrdArray(int[] colIdxFromOrd, int srcOrder, int dstOrder, int count)
    {
      int[] numArray = new int[count];
      Array.Copy((Array) colIdxFromOrd, srcOrder, (Array) numArray, 0, count);
      if (srcOrder > dstOrder)
        Array.Copy((Array) colIdxFromOrd, dstOrder, (Array) colIdxFromOrd, dstOrder + count, srcOrder - dstOrder);
      else
        Array.Copy((Array) colIdxFromOrd, srcOrder + count, (Array) colIdxFromOrd, srcOrder, dstOrder - srcOrder);
      Array.Copy((Array) numArray, 0, (Array) colIdxFromOrd, dstOrder, count);
    }

    private void MoveColsInternal(int srcOrder, int dstOrder, int count)
    {
      this.CancelAnyEdit();
      this.MoveColsInColIdxFromOrdArray(this.fColIdxFromOrd, srcOrder, dstOrder, count);
      this.NullOldColWidths();
      this.fLastVisibleColIndex = this.GetLastVisibleColIndex();
      this.RefreshGridAndScrollBarsIfRedraw();
      this.DoColOrderChanged(srcOrder, dstOrder, count);
    }

    internal void MoveCols(int srcOrder, int dstOrder, int count)
    {
      this.CheckColIndexAndCount(srcOrder, count, nameof (srcOrder));
      this.CheckColIndexAndCount(dstOrder, count, nameof (dstOrder));
      if (srcOrder == dstOrder)
        return;
      int dstStartOrder;
      int dstEndOrder;
      bool[] rowsMap;
      string reasonCantMove;
      if (!this.CanMoveCols(srcOrder, count, out dstStartOrder, out dstEndOrder, out rowsMap, out reasonCantMove))
        throw new ArgumentException(reasonCantMove);
      if (dstStartOrder != -1 && (dstOrder < dstStartOrder || dstEndOrder < dstOrder))
        throw new ArgumentException("Invalid source or destination order");
      string reasonCantPlace;
      if (!this.CanPlaceColsTo(srcOrder, dstOrder, count, rowsMap, out reasonCantPlace))
        throw new ArgumentException(reasonCantPlace);
      this.MoveColsInternal(srcOrder, dstOrder, count);
    }

    internal void CheckColIndex(int colIndex)
    {
      if (colIndex < 0 || colIndex >= this.fColCount)
        throw new ArgumentOutOfRangeException();
    }

    private void DoColOrderChanged(int srcOrder, int dstOrder, int count)
    {
      this.OnColOrderChanged(new iGColOrderChangedEventArgs(srcOrder, dstOrder, count));
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColOrderChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColOrderChangedEventArgs" /> that contains the event data.</param>
    protected virtual void OnColOrderChanged(iGColOrderChangedEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColOrderChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColOrderChanged((object) this, e);
    }

    private int ColOrderToDrawColOrder(int colOrder)
    {
      if (colOrder < 0)
        return colOrder;
      if (colOrder == 0)
        return this.fColCount - 1;
      return colOrder - 1;
    }

    internal int DrawColOrderToColOrder(int colDrawOrder)
    {
      if (colDrawOrder < 0)
        return colDrawOrder;
      if (colDrawOrder == this.fColCount - 1)
        return 0;
      return colDrawOrder + 1;
    }

    private bool IsExtraCol(int colOrderOrIndex)
    {
      return colOrderOrIndex < 1;
    }

    private iGColDisposition GetColDisposition(int colOrder, bool isRowTextDrawn)
    {
      if (colOrder < 1)
        return isRowTextDrawn ? iGColDisposition.RowText : iGColDisposition.Auxiliary;
      return isRowTextDrawn && colOrder >= this.fRowTextStartColNear && colOrder <= this.GetRowTextEndColOrder() ? iGColDisposition.AboveRowText : iGColDisposition.Normal;
    }

    private iGColDisposition GetColDisposition(int colOrder)
    {
      return this.GetColDisposition(colOrder, this.IsRowTextDisplayed());
    }

    private bool IsRowTextEnabled(bool rowMode, bool rowTextVisible)
    {
      return rowMode & rowTextVisible;
    }

    private bool IsRowTextEnabled()
    {
      return this.IsRowTextEnabled(this.fRowMode, this.fRowTextVisible);
    }

    private bool IsRowTextDisplayed(bool rowMode, bool rowTextVisible, int rowTextStartColNear, int rowTextEndColFar, int colCount)
    {
      if (this.IsRowTextEnabled(rowMode, rowTextVisible) && rowTextStartColNear < colCount)
        return rowTextStartColNear <= this.GetRowTextEndColOrder(rowTextEndColFar, colCount);
      return false;
    }

    private bool IsRowTextDisplayed()
    {
      if (this.IsRowTextEnabled() && this.fRowTextStartColNear < this.fColCount)
        return this.fRowTextStartColNear <= this.GetRowTextEndColOrder();
      return false;
    }

    private int GetRowTextEndColOrder(int rowTextEndColFar, int colCount)
    {
      return colCount - rowTextEndColFar - 1;
    }

    private int GetRowTextEndColOrder()
    {
      return this.fColCount - this.fRowTextEndColFar - 1;
    }

    private int GetRowTextEndVisibleColOrder()
    {
      if (this.fLastVisibleColIndex <= 0)
        return 0;
      int rowTextEndColOrder = this.GetRowTextEndColOrder();
      int colOrder = this.GetColOrder(this.fLastVisibleColIndex);
      if (rowTextEndColOrder > colOrder)
        return colOrder;
      return rowTextEndColOrder;
    }

    private int GetRowTextStartVisibleColOrder()
    {
      int rowTextEndColOrder = this.GetRowTextEndColOrder();
      for (int textStartColNear = this.fRowTextStartColNear; textStartColNear <= rowTextEndColOrder; ++textStartColNear)
      {
        if (this.IsColVisible(this.GetColIndex(textStartColNear)))
          return textStartColNear;
      }
      return int.MinValue;
    }

    internal bool IsColVisible(int colIndex)
    {
      return this.IsColVisible(this.fColDatas[colIndex].Visible, this.fColDatas[colIndex].ShowWhenGrouped, colIndex, true);
    }

    internal bool IsColVisible(bool colDataVisible, bool colDataShowWhenGrouped, int colIndex)
    {
      return this.IsColVisible(colDataVisible, colDataShowWhenGrouped, colIndex, true);
    }

    internal bool IsColVisible(bool colDataVisible, bool colDataShowWhenGrouped, int colIndex, bool takeIntoAccountGrouping)
    {
      if (colDataVisible && (colDataShowWhenGrouped || !takeIntoAccountGrouping || !this.IsColGrouped(colIndex)))
        return !this.IsExtraCol(colIndex);
      return false;
    }

    internal bool IsCellColVisible(int colIndex)
    {
      if (this.IsExtraCol(colIndex))
        return this.IsRowTextDisplayed();
      iGColData fColData = this.fColDatas[colIndex];
      if (!fColData.Visible)
        return false;
      if (!fColData.ShowWhenGrouped)
        return !this.IsColGrouped(colIndex);
      return true;
    }

    internal void SetColKey(int colIndex, string key, bool checkUnique)
    {
      this.CheckColIndex(colIndex);
      this.fColKeys.SetItemKey(colIndex, key, this.fColDatas[colIndex].Key, this.fColCount);
      this.fColDatas[colIndex].Key = key;
    }

    internal void SetColWidth(int colIndex, int value)
    {
      this.CheckColIndex(colIndex);
      iGColData fColData = this.fColDatas[colIndex];
      iGrid.CheckColWidth(value, fColData.MinWidth, fColData.MaxWidth);
      if (!this.SetColWidthInternal(colIndex, value))
        return;
      if (this.fAutoResizeCols)
      {
        this.NullOldColWidths();
        this.DoAutoResizeCols(0, this.GetColOrder(colIndex), false, false, false);
      }
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnResizeCol, false);
      this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnResizeCol, false);
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal void SetColAllowSizing(int colIndex, bool value)
    {
      this.CheckColIndex(colIndex);
      bool allowSizing = this.fColDatas[colIndex].AllowSizing;
      this.fColDatas[colIndex].AllowSizing = value;
      this.OnColAllowSizingChanged(value, allowSizing);
    }

    internal void SetColDataNoWidthNoIsRowTextNoAllowSizingChange(int colIndex, iGColData value)
    {
      this.CheckColData(colIndex, value);
      this.fColDatas[colIndex] = value;
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void SetColCellStyle(int colIndex, iGCellStyle value)
    {
      this.CheckColIndex(colIndex);
      if (value == null)
        throw new ArgumentNullException();
      if (this.fRedraw)
        this.Invalidate();
      this.fColDatas[colIndex].CellStyle = value;
    }

    internal void SetColColHdrStyle(int colIndex, iGColHdrStyle value)
    {
      this.CheckColIndex(colIndex);
      if (value == null)
        throw new ArgumentNullException();
      this.fColDatas[colIndex].ColHdrStyle = value;
      if (this.fRedraw)
        this.Invalidate();
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnContentsChange, true);
    }

    internal void SetColData(int colIndex, iGColData value)
    {
      this.CheckColIndex(colIndex);
      this.CheckColData(colIndex, value);
      iGColData fColData = this.fColDatas[colIndex];
      this.fColDatas[colIndex] = value;
      this.fColKeys.SetItemKey(colIndex, value.Key, fColData.Key, this.fColCount);
      this.OnColAllowSizingChanged(value.AllowSizing, fColData.AllowSizing);
      bool flag1 = false;
      bool flag2 = false;
      if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
      {
        if (this.IsColVisible(value.Visible, value.ShowWhenGrouped, colIndex))
        {
          int num = value.Width - fColData.Width;
          if (num != 0)
          {
            this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea + num;
            flag2 = true;
          }
        }
        else
        {
          if (colIndex == this.fLastVisibleColIndex)
            this.fLastVisibleColIndex = this.GetLastVisibleColIndex();
          this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea - fColData.Width;
          this.fVisibleColCount = this.fVisibleColCount - 1;
          flag1 = true;
        }
      }
      else if (this.IsColVisible(value.Visible, value.ShowWhenGrouped, colIndex))
      {
        if (this.fLastVisibleColIndex < 0 || this.GetColOrder(colIndex) > this.GetColOrder(this.fLastVisibleColIndex))
          this.fLastVisibleColIndex = colIndex;
        this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea + value.Width;
        this.fVisibleColCount = this.fVisibleColCount + 1;
        flag1 = true;
      }
      bool adjustScrollBars = flag1 | flag2;
      iGAutoHeightEvents @event = iGAutoHeightEvents.None;
      if (flag1)
      {
        if (value.Visible)
          @event |= iGAutoHeightEvents.OnShowCol;
        else
          @event |= iGAutoHeightEvents.OnHideCol;
      }
      if (flag2)
        @event |= iGAutoHeightEvents.OnResizeCol;
      if (this.fAutoResizeCols && flag1 | flag2)
      {
        this.NullOldColWidths();
        this.DoAutoResizeCols(this.GetColOrder(colIndex), 1, !adjustScrollBars, !this.ShallHeaderAutoHeightOnEvent(@event), !this.ShallFooterAutoHeightOnEvent(@event));
      }
      this.AutoHeightHeaderOnEvent(@event, !adjustScrollBars);
      this.AutoHeightFooterOnEvent(@event, !adjustScrollBars);
      this.RefreshGridAndScrollBarsIfRedraw(adjustScrollBars);
    }

    internal iGColData GetColData(int colIndex)
    {
      this.CheckColIndex(colIndex);
      return this.GetColDataInternal(colIndex);
    }

    internal iGColData GetColDataInternal(int colIndex)
    {
      return this.fColDatas[colIndex];
    }

    internal int GetColOrder(int colIndex)
    {
      this.CheckColIndex(colIndex);
      for (int index = 0; index < this.fColCount; ++index)
      {
        if (this.fColIdxFromOrd[index] == colIndex)
          return index;
      }
      throw new Exception();
    }

    private int GetColOrder(int colIndex, int[] colIdxFromOrd)
    {
      for (int index = 0; index < this.fColCount; ++index)
      {
        if (colIdxFromOrd[index] == colIndex)
          return index;
      }
      throw new Exception();
    }

    internal int GetColIndex(int colOrder)
    {
      this.CheckColIndex(colOrder);
      return this.fColIdxFromOrd[colOrder];
    }

    internal int AddColRange(int colBeforeIndex, iGColPattern[] colPatterns, int count)
    {
      return this.AddColRange(colBeforeIndex, colPatterns, count, false);
    }

    internal int AddColRange(int colBeforeIndex, iGColPattern[] colPatterns, int count, bool init)
    {
      this.CancelAnyEdit();
      this.EmptyMouse();
      this.CancelSearchAsType();
      this.NullOldColWidths();
      if (count <= 0)
        throw new ArgumentOutOfRangeException(nameof (count), "Value cannot be less than or equal to zero");
      if (colBeforeIndex != this.fColCount)
        this.CheckColIndex(colBeforeIndex);
      if (!init && colBeforeIndex < 1)
        throw new ArgumentOutOfRangeException("Cannnot insert columns before the row text column");
      int num1;
      if (colBeforeIndex == this.fColCount)
      {
        num1 = this.fColCount;
      }
      else
      {
        num1 = this.GetColOrder(colBeforeIndex);
        if (1 < num1 && num1 < this.fColCount && !this.CanSeparateCols(this.fColIdxFromOrd[num1 - 1], colBeforeIndex, (bool[]) null))
          throw new ArgumentException("Cannot break merged cells");
        if (this.fFrozenColCount > 1 && num1 + count < this.fFrozenColCount && !this.CanSeparateCols(this.fColIdxFromOrd[this.fFrozenColCount - count - 1], this.fColIdxFromOrd[this.fFrozenColCount - count], (bool[]) null))
          throw new ArgumentException("Frozen area edge cannot break merged cells");
      }
      if (colPatterns != null)
      {
        if (colPatterns.Length != count)
          throw new ArgumentException();
        for (int index1 = 0; index1 < count; ++index1)
        {
          iGColPattern colPattern = colPatterns[index1];
          if (colPattern == null)
            throw new ArgumentException("Array element cannot be null");
          string key = colPattern.Key;
          if (iGKeyManager.IsKeySpecified(key))
          {
            for (int index2 = 0; index2 < index1; ++index2)
            {
              if (iGKeyManager.IsKeySpecified(colPatterns[index2].Key) && colPatterns[index2].Key == key)
                throw new ArgumentException("Key already exists");
            }
            if (this.fColKeys.GetItemIndexFromKey(key) != -1)
              throw new ArgumentException("Key already exists");
          }
        }
      }
      if (this.IsRowTextDisplayed(this.fRowMode, this.fRowTextVisible, this.fRowTextStartColNear, this.fRowTextEndColFar, this.fColCount + count) && this.WillMergedCellsIntersectRowTexts(this.fRowTextStartColNear, this.fRowTextEndColFar, this.fColIdxFromOrd, num1, count))
        throw new ArgumentException("Row text cells and merged cells cannot overlap");
      this.fColKeys.BeforeAddItems(colBeforeIndex, count);
      int num2 = this.fLastVisibleColIndex >= 0 ? this.GetColOrder(this.fLastVisibleColIndex) : -1;
      this.fDefaultCells = (iGCellData[]) iGArrayManager.ExtendArray((Array) this.fDefaultCells, typeof (iGCellData), colBeforeIndex, count, this.fColCount, true);
      if (colBeforeIndex < this.fColCount)
      {
        for (int index = 0; index < this.fColCount; ++index)
        {
          if (this.fColIdxFromOrd[index] >= colBeforeIndex)
            this.fColIdxFromOrd[index] += count;
        }
      }
      this.fColDatas = (iGColData[]) iGArrayManager.ExtendArray((Array) this.fColDatas, typeof (iGColData), colBeforeIndex, count, this.fColCount, false);
      this.fColIdxFromOrd = (int[]) iGArrayManager.ExtendArray((Array) this.fColIdxFromOrd, typeof (int), num1, count, this.fColCount, false);
      this.fColCount = this.fColCount + count;
      for (int index = 0; index < count; ++index)
      {
        this.fColIdxFromOrd[num1 + index] = colBeforeIndex + index;
        if (colPatterns == null)
        {
          if (!this.IsExtraCol(num1 + index))
          {
            if (this.fDefaultCol.fColData.Visible && num1 + index > num2)
              this.fLastVisibleColIndex = colBeforeIndex + index;
            else if (colBeforeIndex <= this.fLastVisibleColIndex)
              this.fLastVisibleColIndex = this.fLastVisibleColIndex + 1;
            if (this.fDefaultCol.fColData.Visible)
            {
              this.fVisibleColCount = this.fVisibleColCount + 1;
              this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea + this.fDefaultCol.ColData.Width;
            }
          }
          this.fColDatas[colBeforeIndex + index] = this.fDefaultCol.ColData;
          this.fDefaultCells[colBeforeIndex + index] = this.fDefaultCol.DefaultCell;
          this.SetNewColumnsCellStyle(colBeforeIndex + index);
          this.SetNewColumnsHeaderStyle(colBeforeIndex + index);
        }
        else
        {
          iGColPattern colPattern = colPatterns[index];
          if (!this.IsExtraCol(num1 + index))
          {
            if (colPattern.fColData.Visible && num1 + index > num2)
              this.fLastVisibleColIndex = colBeforeIndex + index;
            else if (colBeforeIndex + index <= this.fLastVisibleColIndex)
              this.fLastVisibleColIndex = this.fLastVisibleColIndex + 1;
            if (colPattern.fColData.Visible)
            {
              this.fVisibleColCount = this.fVisibleColCount + 1;
              this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea + colPattern.Width;
            }
          }
          string key = colPattern.Key;
          if (iGKeyManager.IsKeySpecified(key))
            this.fColKeys.SetItemKey(colBeforeIndex + index, key, (string) null, this.fColCount);
          this.fColDatas[colBeforeIndex + index] = colPattern.ColData;
          this.fDefaultCells[colBeforeIndex + index] = colPattern.DefaultCell;
          if (colPatterns[index].fColData.CellStyle == null)
            this.SetNewColumnsCellStyle(colBeforeIndex + index);
          if (colPatterns[index].ColHdrStyle == null)
            this.SetNewColumnsHeaderStyle(colBeforeIndex + index);
        }
      }
      if (this.fPageCount > 0)
      {
        for (int index = 0; index < this.fPageCount; ++index)
          this.fPages[index].AddCol(colBeforeIndex, count, this.fDefaultCells);
      }
      iGColHdrData[] cells = new iGColHdrData[count];
      if (colPatterns != null)
      {
        for (int index = 0; index < count; ++index)
          cells[index] = colPatterns[index].ColHdr;
      }
      else
      {
        for (int index = 0; index < count; ++index)
          cells[index] = this.fDefaultCol.ColHdr;
      }
      this.HeaderOnColAdded(cells, colBeforeIndex, count);
      this.FooterOnColAdded(colBeforeIndex, count);
      if (this.fGroupObject != null)
      {
        this.fGroupObject.OnGridAddCol(colBeforeIndex, count);
        if (this.fLastGroupObject != null)
          this.fLastGroupObject.OnGridAddCol(colBeforeIndex, count);
      }
      if (this.fSortObject != null)
        this.fSortObject.OnGridAddCol(colBeforeIndex, count);
      this.fMergedCells.OnColRangeAdded(colBeforeIndex, count);
      this.fSelectedCells.OnColRangeAdded(colBeforeIndex, count);
      this.CurCellOnColAdded(colBeforeIndex, count);
      this.AdjustSearchAsTypeObject();
      if (this.fSearchAsTypeObject.fManager != null)
        this.fSearchAsTypeObject.fManager.OnColAdded(colBeforeIndex, count);
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(0, 0, false, !this.ShallHeaderAutoHeightOnEvent(iGAutoHeightEvents.OnAddCol), !this.ShallFooterAutoHeightOnEvent(iGAutoHeightEvents.OnAddCol));
      if (!init)
      {
        this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnAddCol, false);
        this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnAddCol, false);
      }
      if (this.IsTreeColSpecified() && colBeforeIndex <= this.fTreeColIndex)
        this.fTreeColIndex = this.fTreeColIndex + count;
      this.OnColsAdded(new iGColSetChangeEventArgs(colBeforeIndex - 1, count));
      this.RefreshGridAndScrollBarsIfRedraw();
      return colBeforeIndex;
    }

    internal void RemoveColRange(int colIndex, int count)
    {
      bool flag1 = false;
      if (this.fStaySorted && this.fSortObject != null)
      {
        for (int index = colIndex + count - 1; index >= colIndex; --index)
        {
          if (this.fSortObject.fParams[index].SortIndex >= 0)
          {
            flag1 = true;
            break;
          }
        }
      }
      bool flag2 = false;
      if (this.fGroupObject != null && this.fLastGroupObject != null)
      {
        for (int index = colIndex + count - 1; index >= colIndex; --index)
        {
          if (this.fLastGroupObject.fParams[index].SortOrder != iGSortOrder.None)
          {
            flag2 = true;
            break;
          }
        }
      }
      this.CheckColIndexAndCount(colIndex, count, nameof (colIndex));
      if (colIndex < 1)
        throw new ArgumentOutOfRangeException("Cannot remove the row text column");
      int colOrder = this.GetColOrder(colIndex);
      if (this.IsRowTextDisplayed(this.fRowMode, this.fRowTextVisible, this.fRowTextStartColNear, this.fRowTextEndColFar, this.fColCount - count) && this.WillMergedCellsIntersectRowTexts(this.fRowTextStartColNear, this.fRowTextEndColFar, this.fColIdxFromOrd, colOrder, -count))
        throw new ArgumentException("Row text cells and merged cells cannot overlap");
      if (flag1 | flag2)
        this.CheckSortGroupBreakMergedCells();
      bool[] flagArray = new bool[this.fColCount];
      for (int index = 1; index < this.fColCount; ++index)
      {
        int num = this.fColIdxFromOrd[index];
        flagArray[index] = num < colIndex || num >= colIndex + count;
      }
      bool flag3 = flagArray[1];
      for (int index = 2; index < this.fColCount; ++index)
      {
        if (flag3 != flagArray[index])
        {
          if (!this.CanSeparateCols(this.fColIdxFromOrd[index - 1], this.fColIdxFromOrd[index], (bool[]) null))
            throw new ArgumentException("Cannot break merged cells");
          flag3 = flagArray[index];
        }
      }
      int[] numArray = new int[this.fColCount - count];
      int index1 = 0;
      for (int index2 = 0; index2 < this.fColCount; ++index2)
      {
        int num = this.fColIdxFromOrd[index2];
        if (num < colIndex || num >= colIndex + count)
        {
          numArray[index1] = num;
          ++index1;
        }
      }
      if (this.fFrozenColCount > 1 && colOrder < this.fFrozenColCount && (this.fFrozenColCount + count < this.fColCount && !this.CanSeparateCols(numArray[this.fFrozenColCount - 1], numArray[this.fFrozenColCount], (bool[]) null)))
        throw new ArgumentException("Frozen area edge cannot break merged cells");
      this.OnColsRemoving(new iGColSetChangeEventArgs(colIndex - 1, count));
      this.CancelAnyEdit();
      this.EmptyMouse();
      this.CancelSearchAsType();
      this.NullOldColWidths();
      this.NullGroupColsWidths();
      this.fColKeys.BeforeRemoveItems(colIndex, count);
      for (int index2 = 0; index2 < this.fPageCount; ++index2)
        this.fPages[index2].RemoveCol(colIndex, count);
      for (int index2 = numArray.Length - 1; index2 >= 0; --index2)
      {
        int num = numArray[index2];
        if (num >= colIndex)
          num -= count;
        this.fColIdxFromOrd[index2] = num;
      }
      this.fDefaultCells = (iGCellData[]) iGArrayManager.ShortenArray((Array) this.fDefaultCells, typeof (iGCellData), colIndex, count, this.fColCount, true);
      for (int colIndex1 = colIndex + count - 1; colIndex1 >= colIndex; --colIndex1)
      {
        iGColData fColData = this.fColDatas[colIndex1];
        if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex1))
        {
          this.fVisibleColCount = this.fVisibleColCount - 1;
          this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea - fColData.Width;
        }
      }
      this.fColDatas = (iGColData[]) iGArrayManager.ShortenArray((Array) this.fColDatas, typeof (iGColData), colIndex, count, this.fColCount, false);
      this.fColCount = this.fColCount - count;
      this.HeaderOnColRemoved(colIndex, count);
      this.FooterOnColRemoved(colIndex, count);
      this.fMergedCells.OnColRangeRemoved(colIndex, count);
      this.fSelectedCells.OnColRangeRemoved(colIndex, count);
      this.CurCellOnColRemoved(colIndex, count);
      this.AdjustSearchAsTypeObject();
      if (this.fSearchAsTypeObject.fManager != null)
        this.fSearchAsTypeObject.fManager.OnColRemoved(colIndex, count);
      if (this.fGroupObject != null)
      {
        if (this.fLastGroupObject != null)
        {
          for (int index2 = colIndex + count - 1; index2 >= colIndex; --index2)
          {
            if (this.fLastGroupObject.fParams[index2].SortOrder != iGSortOrder.None)
              this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea - this.fLevelIndent;
          }
          this.fLastGroupObject.OnGridRemoveCol(colIndex, count);
        }
        this.fGroupObject.OnGridRemoveCol(colIndex, count);
      }
      if (this.fSortObject != null)
        this.fSortObject.OnGridRemoveCol(colIndex, count);
      if (flag2)
        this.Group();
      else if (flag1)
        this.SortInternal();
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(0, 0, false, !this.ShallHeaderAutoHeightOnEvent(iGAutoHeightEvents.OnRemoveCol), !this.ShallFooterAutoHeightOnEvent(iGAutoHeightEvents.OnRemoveCol));
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnRemoveCol, false);
      this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnRemoveCol, false);
      if (this.fLastVisibleColIndex >= colIndex && this.fLastVisibleColIndex < colIndex + count)
        this.fLastVisibleColIndex = this.GetLastVisibleColIndex();
      else if (this.fLastVisibleColIndex > colIndex)
        this.fLastVisibleColIndex = this.fLastVisibleColIndex - count;
      if (this.IsTreeColSpecified())
      {
        if (colIndex <= this.fTreeColIndex && colIndex + count > this.fTreeColIndex)
          this.ClearTreeColIndex();
        else if (colIndex < this.fTreeColIndex)
          this.fTreeColIndex = this.fTreeColIndex - count;
      }
      this.OnColsRemoved(new iGColSetChangeEventArgs(colIndex - 1, count));
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal void ClearCols()
    {
      if (this.fColCount == 1)
        return;
      this.RemoveColRange(1, this.fColCount - 1);
    }

    internal iGCellData GetDefaultCell(int colIndex)
    {
      this.CheckColIndex(colIndex);
      return this.fDefaultCells[colIndex];
    }

    internal void SetDefaultCell(int colIndex, iGCellData cellData)
    {
      this.CheckColIndex(colIndex);
      this.fDefaultCells[colIndex] = cellData;
    }

    internal void SetDefaultCellImageIndex(int colIndex, int value)
    {
      this.CheckColIndex(colIndex);
      this.fDefaultCells[colIndex].ImageIndex = value;
    }

    internal void SetDefaultCellValue(int colIndex, object value)
    {
      this.CheckColIndex(colIndex);
      this.fDefaultCells[colIndex].Value = value;
    }

    internal void SetDefaultCellAuxValue(int colIndex, object value)
    {
      this.CheckColIndex(colIndex);
      this.fDefaultCells[colIndex].AuxValue = value;
    }

    internal int ColKeyToIndex(string key, bool throwException)
    {
      if (!iGKeyManager.IsKeySpecified(key))
      {
        if (throwException)
          throw new ArgumentNullException();
        return -1;
      }
      int colIndexFromKey = this.GetColIndexFromKey(key);
      int num = -1;
      if (!(colIndexFromKey == num & throwException))
        return colIndexFromKey;
      throw new ArgumentException("Invalid key");
    }

    internal bool ColKeyExists(string key)
    {
      if (!iGKeyManager.IsKeySpecified(key))
        throw new ArgumentNullException();
      return this.GetColIndexFromKey(key) != -1;
    }

    private int GetColIndexFromKey(string key)
    {
      return this.fColKeys.GetItemIndexFromKey(key);
    }

    internal static void CheckColWidth(int value, int minWidth, int maxWidth)
    {
      if (value < 0)
        throw new ArgumentOutOfRangeException(nameof (value), "Width cannot be negative");
      if (minWidth >= 0 && value < minWidth || maxWidth >= 0 && value > maxWidth)
        throw new ArgumentException("Column width is out of min/max range");
    }

    internal static void CheckColWidthMinMaxValues(int minWidth, int maxWidth)
    {
      if (minWidth >= 0 && maxWidth >= 0 && minWidth > maxWidth)
        throw new ArgumentException("The maximum column width cannot exceed the minimum column width");
    }

    internal static bool AdjustColWidthAfterMinMaxWidthChange(ref int width, int minWidth, int maxWidth)
    {
      if (maxWidth >= 0 && width > maxWidth)
      {
        width = maxWidth;
        return true;
      }
      if (minWidth >= 0)
      {
        if (width < minWidth)
        {
          width = minWidth;
          return true;
        }
      }
      else if (width < 0)
      {
        width = 0;
        return true;
      }
      return false;
    }

    private bool SetColWidthInternal(int colIndex, int value)
    {
      iGColData fColData = this.fColDatas[colIndex];
      iGrid.AdjustColWidthAfterMinMaxWidthChange(ref value, fColData.MinWidth, fColData.MaxWidth);
      int num = value - fColData.Width;
      this.fColDatas[colIndex].Width = value;
      if (!this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex) || num == 0)
        return false;
      this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea + num;
      return true;
    }

    private void SetNewColumnsCellStyle(int colIndex)
    {
      if (this.fDefaultCol.CellStyle != null)
      {
        this.fColDatas[colIndex].CellStyle = this.fDefaultCol.CellStyle.Clone();
      }
      else
      {
        iGCellStyle iGcellStyle = new iGCellStyle(true);
        this.fColDatas[colIndex].CellStyle = iGcellStyle;
      }
    }

    private void SetNewColumnsHeaderStyle(int colIndex)
    {
      if (this.fDefaultCol.ColHdrStyle != null)
      {
        this.fColDatas[colIndex].ColHdrStyle = this.fDefaultCol.ColHdrStyle.Clone();
      }
      else
      {
        iGColHdrStyle iGcolHdrStyle = new iGColHdrStyle(true);
        this.fColDatas[colIndex].ColHdrStyle = iGcolHdrStyle;
      }
    }

    /// <summary>Specifies whether a row's <see cref="P:TenTec.Windows.iGridLib.iGRow.CellStyle" /> object is created on the fly on the first access if it was not initialized.</summary>
    /// <value>A Boolean value that indicates whether to create the row cell style object dynamically. The default is True.</value>
    [DefaultValue(true)]
    [Category("Behavior")]
    [Description("Determines whether iGrid automatically creates the row's cell style object if it was not set.")]
    public bool CreateRowCellStyleDynamically
    {
      get
      {
        return this.fCreateRowCellStyleDynamically;
      }
      set
      {
        this.fCreateRowCellStyleDynamically = value;
      }
    }

    /// <summary>Gets or sets the capacity of the cell pages.</summary>
    /// <value>The number of rows per page. The default is 100.</value>
    [DefaultValue(100)]
    [Category("Behavior")]
    [Description("The capacity of the cell pages.")]
    public int PageCapacity
    {
      get
      {
        return this.fPageCapacity;
      }
      set
      {
        if (this.fPageCapacity == value)
          return;
        if (this.fPageCount > 0)
          throw new ArgumentException("Cannot set page capacity after rows are added");
        this.fPageCapacity = value;
        this.fRowsMap = new iGRowNavigator[this.fPageCapacity];
      }
    }

    /// <summary>Gets the collection of the columns.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGColCollection" /> object that allows you to access the columns.</value>
    [Category("Data")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [RefreshProperties(RefreshProperties.All)]
    [Description("The collection of the columns.")]
    public iGColCollection Cols
    {
      get
      {
        return this.fColCollection;
      }
    }

    /// <summary>Gets or sets the collection of the rows.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGRowCollection" /> object that allows you to access the rows.</value>
    [Category("Data")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Description("The collection of the rows.")]
    public iGRowCollection Rows
    {
      get
      {
        return this.fRowCollection;
      }
    }

    /// <summary>Indicates whether iGrid automatically calculates the default row height in the Windows Forms designer <see cref="M:System.ComponentModel.ISupportInitialize.EndInit" /> call.</summary>
    /// <value>A Boolean value which indicates whether igrid will determine the optimal row height automatically.</value>
    [Category("Default Settings")]
    [Description("Determines whether DefaultRow.Height and DefaultRow.NormalCellHeight are rewritten with optimal values to display 1 line of cell text after initialization in ISupportInitialize.EndInit().")]
    [DefaultValue(true)]
    public bool DefaultRowHeightAutoSet
    {
      get
      {
        return this.fDefaultRowHeightAutoSet;
      }
      set
      {
        this.fDefaultRowHeightAutoSet = value;
      }
    }

    /// <summary>Gets or sets the default parameters of the rows.</summary>
    /// <value>An <see cref="T:TenTec.Windows.iGridLib.iGRowPattern" /> object that stores the default row properties.</value>
    [Category("Default Settings")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGDesignTimeDefaultRowPatternConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Description("The default parameters of the rows.")]
    public iGRowPattern DefaultRow
    {
      get
      {
        if (this.DesignMode && !(this.fDefaultRow is iGDesignTimeDefaultRowPattern))
          this.fDefaultRow = (iGRowPattern) new iGDesignTimeDefaultRowPattern(this);
        return this.fDefaultRow;
      }
      set
      {
        if (value == null)
          throw new ArgumentNullException();
        this.fDefaultRow = value;
      }
    }

    /// <summary>Gets or sets the default parameters of the columns.</summary>
    /// <value>An <see cref="T:TenTec.Windows.iGridLib.iGColPattern" /> object that stores the default column properties.</value>
    [Category("Default Settings")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGDesignTimeDefaultColPatternConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The default parameters of the columns.")]
    public iGColPattern DefaultCol
    {
      get
      {
        if (this.DesignMode && !(this.fDefaultCol is iGDesignTimeDefaultColPattern))
          this.fDefaultCol = (iGColPattern) new iGDesignTimeDefaultColPattern(this);
        return this.fDefaultCol;
      }
      set
      {
        if (value == null)
          throw new ArgumentNullException();
        this.fDefaultCol = value;
      }
    }

    /// <summary>Gets the collection of the grid's cells.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGCellCollection" /> object which provides access to the grid's cells.</value>
    [Browsable(false)]
    public iGCellCollection Cells
    {
      get
      {
        return this.fCellCollection;
      }
    }

    /// <summary>Gets the object which represents the row text column. The cells of this column are displayed in the group rows and under the normal cells in the normal rows.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGCol" /> object that represents the row text column.</value>
    [Category("Data")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGRowTextColObjectConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The parameters of the row text column. The cells of this column are displayed in the group rows and under the normal cells in the normal rows.")]
    public iGCol RowTextCol
    {
      get
      {
        return this.fRowTextColObject;
      }
    }

    /// <summary>Gets the object that represents the default parameters of the automatically created group rows.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGDefaultAutoGroupRow" /> object that exposes the default properties of the group rows created automatically.</value>
    [Category("Default Settings")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The default parameters of the automatically created group rows.")]
    public iGDefaultAutoGroupRow DefaultAutoGroupRow
    {
      get
      {
        if (this.fDefaultAutoGroupRow == null)
          this.fDefaultAutoGroupRow = new iGDefaultAutoGroupRow(this);
        return this.fDefaultAutoGroupRow;
      }
    }

    internal int DefaultAutoGroupRowHeight
    {
      get
      {
        return this.fDefaultAutoGroupRowHeight;
      }
      set
      {
        this.fDefaultAutoGroupRowHeight = value;
      }
    }

    internal bool DefaultAutoGroupRowExpanded
    {
      get
      {
        return this.fDefaultAutoGroupRowExpanded;
      }
      set
      {
        this.fDefaultAutoGroupRowExpanded = value;
      }
    }

    internal iGTreeButtonState DefaultAutoGroupRowTreeButton
    {
      get
      {
        return this.fDefaultAutoGroupRowTreeButton;
      }
      set
      {
        this.fDefaultAutoGroupRowTreeButton = value;
      }
    }

    /// <summary>Gets or sets the array of styles used for the automatically created group rows.</summary>
    /// <value>An array of <see cref="T:TenTec.Windows.iGridLib.iGCellStyle" /> objects. By default this array contains one cell style object with the default color setting for all group rows (the <see cref="T:System.Drawing.SystemColors" />.<see cref="P:System.Drawing.SystemColors.Control" /> background color).</value>
    [Category("Appearance")]
    [Editor("TenTec.Windows.iGridLib.Design.iGCellStyleArrayEditor, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0", typeof (UITypeEditor))]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGCellStyleArrayConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("Determines the array of styles used for the automatically created group rows.")]
    public iGCellStyle[] GroupRowLevelStyles
    {
      get
      {
        return this.fAutoGroupRowLevelStyles;
      }
      set
      {
        if (value == null)
          throw new ArgumentNullException();
        if (value.Length < 1)
          throw new ArgumentException();
        this.fAutoGroupRowLevelStyles = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Occurs after the columns have been physically reordered in the grid.</summary>
    [Category("Columns")]
    [Description("Occurs just after a set of columns has changed their visible order.")]
    public event iGColOrderChangedEventHandler ColOrderChanged;

    /// <summary>Gets the object that allows you to set up the footer.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGFooter" /> object that represents the footer.</value>
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Category("iGrid Areas")]
    [Description("The set of properties which allow you to set up the footer.")]
    public iGFooter Footer
    {
      get
      {
        if (this.fFooter == null)
          this.fFooter = new iGFooter(this);
        return this.fFooter;
      }
    }

    private bool ShouldSerializeFooter()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.Footer);
    }

    private void ResetFooter()
    {
      this.Footer.SeparatingLine = iGFooter.cDefaultSeparatingLine.Clone();
    }

    /// <summary>Gets or sets a value indicating whether iGrid automatically calculate totals in the footer section.</summary>
    /// <value>A Boolean value that indicates whether totals are calculated. The default value is True.</value>
    [DefaultValue(true)]
    [Category("Behavior")]
    [Description("Determines whether totals are recalculated on appropriate events")]
    public bool CalculateTotals
    {
      get
      {
        return this.fCalculateTotals;
      }
      set
      {
        this.fCalculateTotals = value;
      }
    }

    private void UpdateAggregateFunctionCount()
    {
      this.fAggregateFunctionCount = 0;
      for (int colIndex = 0; colIndex < this.fColCount; ++colIndex)
      {
        for (int rowIndex = 0; rowIndex < this.fFooterRowCount; ++rowIndex)
        {
          if (this.GetFooterCellDataInternal(rowIndex, colIndex).AggregateFunction != iGAggregateFunction.None)
            this.fAggregateFunctionCount = this.fAggregateFunctionCount + 1;
        }
      }
    }

    private void RecalcTotals()
    {
      this.OnRecalculateTotals(EventArgs.Empty);
      if (this.fAggregateFunctionCount == 0 || !this.fCalculateTotals || (!this.fRedraw || this.DesignMode))
        return;
      iGIncludeRowInTotalsCalculationEventArgs e = new iGIncludeRowInTotalsCalculationEventArgs(0, 0, 0);
      for (int colIndex = 0; colIndex < this.fColCount; ++colIndex)
      {
        iGAggregateFunction[] gaggregateFunctionArray = new iGAggregateFunction[this.fFooterRowCount];
        bool flag = false;
        for (int rowIndex = 0; rowIndex < this.fFooterRowCount; ++rowIndex)
        {
          gaggregateFunctionArray[rowIndex] = this.GetFooterCellDataInternal(rowIndex, colIndex).AggregateFunction;
          if (gaggregateFunctionArray[rowIndex] != iGAggregateFunction.None)
            flag = true;
        }
        if (flag)
        {
          int[] numArray1 = new int[this.fFooterRowCount];
          Decimal[] numArray2 = new Decimal[this.fFooterRowCount];
          int[] numArray3 = new int[this.fFooterRowCount];
          for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
          {
            iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
            if (rowDataInternal.Visible && rowDataInternal.Type == iGRowType.Normal)
            {
              for (int index = 0; index < this.fFooterRowCount; ++index)
              {
                Decimal result = new Decimal();
                bool? nullable = new bool?();
                iGAggregateFunction gaggregateFunction = gaggregateFunctionArray[index];
                if (gaggregateFunction != iGAggregateFunction.None)
                {
                  e.fRowIndex = rowIndex;
                  e.fColIndex = colIndex;
                  e.fFooterRowIndex = index;
                  e.fDoDefault = true;
                  this.OnIncludeRowInTotalsCalculation(e);
                  if (e.fDoDefault)
                  {
                    if (gaggregateFunction == iGAggregateFunction.Count)
                    {
                      ++numArray1[index];
                    }
                    else
                    {
                      if (!nullable.HasValue)
                      {
                        object obj = this.GetCellDataInternal(rowIndex, colIndex).Value;
                        if (obj == null || obj == DBNull.Value)
                          nullable = new bool?(false);
                        else if (obj.GetType() == typeof (string))
                        {
                          nullable = new bool?(Decimal.TryParse((string) obj, out result));
                        }
                        else
                        {
                          try
                          {
                            result = Convert.ToDecimal(obj);
                            nullable = new bool?(true);
                          }
                          catch (Exception ex)
                          {
                            nullable = new bool?(false);
                          }
                        }
                      }
                      if (nullable.Value)
                      {
                        ++numArray3[index];
                        switch (gaggregateFunction)
                        {
                          case iGAggregateFunction.Sum:
                          case iGAggregateFunction.Average:
                            numArray2[index] += result;
                            continue;
                          case iGAggregateFunction.Minimum:
                            if (numArray3[index] == 1)
                            {
                              numArray2[index] = result;
                              continue;
                            }
                            if (result < numArray2[index])
                            {
                              numArray2[index] = result;
                              continue;
                            }
                            continue;
                          case iGAggregateFunction.Maximum:
                            if (numArray3[index] == 1)
                            {
                              numArray2[index] = result;
                              continue;
                            }
                            if (result > numArray2[index])
                            {
                              numArray2[index] = result;
                              continue;
                            }
                            continue;
                          default:
                            continue;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          for (int rowIndex = 0; rowIndex < this.fFooterRowCount; ++rowIndex)
          {
            switch (gaggregateFunctionArray[rowIndex])
            {
              case iGAggregateFunction.Count:
                this.SetFooterCellValueInternal(rowIndex, colIndex, (object) numArray1[rowIndex]);
                break;
              case iGAggregateFunction.Sum:
              case iGAggregateFunction.Minimum:
              case iGAggregateFunction.Maximum:
                this.SetFooterCellValueInternal(rowIndex, colIndex, (object) numArray2[rowIndex]);
                break;
              case iGAggregateFunction.Average:
                if (numArray3[rowIndex] > 0)
                {
                  this.SetFooterCellValueInternal(rowIndex, colIndex, (object) (numArray2[rowIndex] / (Decimal) numArray3[rowIndex]));
                  break;
                }
                this.SetFooterCellValueInternal(rowIndex, colIndex, (object) null);
                break;
            }
          }
        }
      }
      this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnContentsChange, true);
      this.RefreshGridAndScrollBarsIfRedraw(false);
    }

    internal int FooterVisibleRowsTotalHeight
    {
      get
      {
        int num = 0;
        for (int index = 0; index < this.fFooterRowCount; ++index)
        {
          if (this.fFooterRows[index].Visible)
            num += this.fFooterRows[index].Height;
        }
        return num;
      }
      set
      {
        if (value <= 0)
          throw new ArgumentOutOfRangeException(nameof (value), "Value cannot be less than or equal to zero");
        int visibleRowsTotalHeight = this.FooterVisibleRowsTotalHeight;
        if (value == visibleRowsTotalHeight)
          return;
        int num1 = 0;
        for (int index = 0; index < this.fFooterRowCount; ++index)
        {
          if (this.fFooterRows[index].Visible)
            ++num1;
        }
        if (num1 == 0)
          return;
        int num2 = (value - visibleRowsTotalHeight) / num1;
        bool flag = true;
        for (int index = 0; index < this.fFooterRowCount; ++index)
        {
          if (this.fFooterRows[index].Visible)
          {
            if (flag)
            {
              this.fFooterRows[index].Height += (value - visibleRowsTotalHeight) % num1;
              flag = false;
            }
            this.fFooterRows[index].Height += num2;
          }
        }
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    internal void CheckFooterCellIndices(int rowIndex, int colIndex)
    {
      this.CheckFooterRowIndex(rowIndex);
      this.CheckColIndex(colIndex);
    }

    internal void CheckFooterRowIndex(int rowIndex)
    {
      if (rowIndex < 0 || rowIndex >= this.fFooterRowCount)
        throw new ArgumentOutOfRangeException();
    }

    private void CheckFooterRowIndexAndCount(int rowIndex, int rowCount)
    {
      if (rowIndex < 0 || rowCount <= 0)
        throw new ArgumentOutOfRangeException();
      if (rowIndex + rowCount > this.fFooterRowCount)
        throw new ArgumentException("Invalid row index or count");
    }

    private void CreateFooterData()
    {
      this.fFooterRowCount = 1;
      this.fFooterRows = new iGFooterRowData[this.fFooterRowCount];
      for (int index = 0; index < this.fFooterRowCount; ++index)
        this.fFooterRows[index] = new iGFooterRowData(17, true);
      int capacity = this.fColCount * this.fFooterRowCount;
      this.fFooterCells = iGFooterCellData.DefaultArrayFactory(capacity);
      this.fFooterSpanMap = new int[capacity];
      for (int index = 0; index < capacity; ++index)
        this.fFooterSpanMap[index] = index;
    }

    internal void SetFooterRowCount(int newRowCount)
    {
      if (newRowCount < 0)
        throw new ArgumentOutOfRangeException();
      if (this.fFooterRowCount == newRowCount)
        return;
      this.CancelAnyEdit();
      this.CancelSearchAsType();
      if (newRowCount > this.fFooterRowCount)
      {
        Array.Resize<iGFooterRowData>(ref this.fFooterRows, newRowCount);
        for (int fFooterRowCount = this.fFooterRowCount; fFooterRowCount < newRowCount; ++fFooterRowCount)
          this.fFooterRows[fFooterRowCount] = new iGFooterRowData(17, true);
        int newSize = newRowCount * this.fColCount;
        Array.Resize<iGFooterCellData>(ref this.fFooterCells, newSize);
        iGFooterCellData iGfooterCellData = iGFooterCellData.DefaultFactory();
        for (int index = this.fFooterRowCount * this.fColCount; index < newSize; ++index)
          this.fFooterCells[index] = iGfooterCellData;
        Array.Resize<int>(ref this.fFooterSpanMap, newSize);
        for (int index = this.fFooterRowCount * this.fColCount; index < newSize; ++index)
          this.fFooterSpanMap[index] = index;
        this.fFooterRowCount = newRowCount;
      }
      else
      {
        Array.Resize<iGFooterRowData>(ref this.fFooterRows, newRowCount);
        int newSize = newRowCount * this.fColCount;
        Array.Resize<iGFooterCellData>(ref this.fFooterCells, newSize);
        Array.Resize<int>(ref this.fFooterSpanMap, newSize);
        this.fFooterRowCount = newRowCount;
        this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnRemoveRow, false);
      }
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal void RemoveFooterRowRange(int rowIndex, int count)
    {
      if (count < 0)
        throw new ArgumentOutOfRangeException();
      if (rowIndex < 1)
        throw new ArgumentOutOfRangeException();
      this.CheckFooterRowIndexAndCount(rowIndex, count);
      if (count == 0)
        return;
      int length1 = this.fFooterRowCount - count;
      iGFooterRowData[] iGfooterRowDataArray = new iGFooterRowData[length1];
      Array.Copy((Array) this.fFooterRows, (Array) iGfooterRowDataArray, rowIndex);
      for (int index = 0; index < this.fFooterRowCount - rowIndex - count; ++index)
        iGfooterRowDataArray[rowIndex + index] = this.fFooterRows[rowIndex + index + count];
      this.fFooterRows = iGfooterRowDataArray;
      int length2 = length1 * this.fColCount;
      iGFooterCellData[] iGfooterCellDataArray = new iGFooterCellData[length2];
      Array.Copy((Array) this.fFooterCells, (Array) iGfooterCellDataArray, rowIndex * this.fColCount);
      for (int index1 = 0; index1 < this.fFooterRowCount - rowIndex - count; ++index1)
      {
        for (int index2 = 0; index2 < this.fColCount; ++index2)
          iGfooterCellDataArray[(rowIndex + index1) * this.fColCount + index2] = this.fFooterCells[(rowIndex + index1 + count) * this.fColCount + index2];
      }
      this.fFooterCells = iGfooterCellDataArray;
      int[] numArray = new int[length2];
      Array.Copy((Array) this.fFooterSpanMap, (Array) numArray, rowIndex * this.fColCount);
      int num = (rowIndex + count) * this.fColCount;
      for (int index1 = 0; index1 < this.fFooterRowCount - rowIndex - count; ++index1)
      {
        for (int index2 = 0; index2 < this.fColCount; ++index2)
        {
          int fFooterSpan = this.fFooterSpanMap[(rowIndex + index1 + count) * this.fColCount + index2];
          if (fFooterSpan >= num)
            fFooterSpan -= count * this.fColCount;
          numArray[(rowIndex + index1) * this.fColCount + index2] = fFooterSpan;
        }
      }
      this.fFooterSpanMap = numArray;
      this.fFooterRowCount = length1;
      this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnRemoveRow, false);
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal void FooterResetData()
    {
      this.CreateFooterData();
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    private void FooterOnColAdded(int colBefore, int count)
    {
      iGFooterCellData iGfooterCellData = iGFooterCellData.DefaultFactory();
      int length = this.fColCount * this.fFooterRowCount;
      int[] numArray = new int[length];
      iGFooterCellData[] iGfooterCellDataArray = new iGFooterCellData[length];
      int num1 = this.fColCount - count;
      int index1 = 0;
      int index2 = 0;
      int num2 = num1 - colBefore;
      for (int index3 = 0; index3 < this.fFooterRowCount; ++index3)
      {
        for (int index4 = 0; index4 < this.fColCount; ++index4)
        {
          if (this.fFooterSpanMap == null || index4 >= colBefore && index4 < colBefore + count)
          {
            numArray[index1] = index1;
            iGfooterCellDataArray[index1] = iGfooterCellData;
          }
          else
          {
            int fFooterSpan = this.fFooterSpanMap[index2];
            int num3 = fFooterSpan + (fFooterSpan + num2) / num1 * count;
            numArray[index1] = num3;
            iGfooterCellDataArray[index1] = this.fFooterCells[index2];
            ++index2;
          }
          ++index1;
        }
      }
      this.fFooterSpanMap = numArray;
      this.fFooterCells = iGfooterCellDataArray;
    }

    private void FooterOnColRemoved(int colIndex, int count)
    {
      int length = this.fColCount * this.fFooterRowCount;
      int[] numArray = new int[length];
      iGFooterCellData[] iGfooterCellDataArray = new iGFooterCellData[length];
      int num1 = colIndex + count;
      int num2 = this.fColCount + count;
      int index1 = 0;
      int index2 = 0;
      if (this.fColCount > 0)
      {
        for (int index3 = 0; index3 < this.fFooterRowCount; ++index3)
        {
          int num3 = 0;
          while (true)
          {
            if (num3 == colIndex)
              index2 += count;
            if (num3 < this.fColCount)
            {
              int fFooterSpan = this.fFooterSpanMap[index2];
              int num4 = fFooterSpan % num2;
              if (num4 >= colIndex && num4 < num1)
              {
                if (num3 == colIndex)
                  iGfooterCellDataArray[index1] = this.fFooterCells[fFooterSpan];
                fFooterSpan -= num4 - colIndex;
              }
              else
              {
                iGfooterCellDataArray[index1] = this.fFooterCells[index2];
                if (num4 >= num1)
                  fFooterSpan -= count;
              }
              int num5 = fFooterSpan - fFooterSpan / num2 * count;
              numArray[index1] = num5;
              ++index1;
              ++index2;
              ++num3;
            }
            else
              break;
          }
        }
      }
      this.fFooterSpanMap = numArray;
      this.fFooterCells = iGfooterCellDataArray;
    }

    internal iGFooterRowData GetFooterRowData(int rowIndex)
    {
      this.CheckFooterRowIndex(rowIndex);
      return this.fFooterRows[rowIndex];
    }

    internal void SetFooterRowHeight(int rowIndex, int value, bool adjustScrollBarsIfRedraw)
    {
      this.CheckFooterRowIndex(rowIndex);
      if (value < 0)
        throw new ArgumentOutOfRangeException(nameof (value), "Height cannot be negative");
      if (this.fFooterRows[rowIndex].Height == value)
        return;
      this.fFooterRows[rowIndex].Height = value;
      this.RefreshGridAndScrollBarsIfRedraw(adjustScrollBarsIfRedraw);
    }

    internal void SetFooterRowVisible(int rowIndex, bool value)
    {
      this.CheckFooterRowIndex(rowIndex);
      if (this.fFooterRows[rowIndex].Visible == value)
        return;
      this.fFooterRows[rowIndex].Visible = value;
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(0, 0, false, false, false);
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal iGFooterCellData GetFooterCellDataInternal(int rowIndex, int colIndex)
    {
      return this.fFooterCells[rowIndex * this.fColCount + colIndex];
    }

    internal iGFooterCellData GetFooterCellData(int rowIndex, int colIndex)
    {
      this.CheckFooterCellIndices(rowIndex, colIndex);
      return this.GetFooterCellDataInternal(rowIndex, colIndex);
    }

    private void SetFooterCellValueInternal(int rowIndex, int colIndex, object value)
    {
      this.fFooterCells[rowIndex * this.fColCount + colIndex].Value = value;
    }

    internal void SetFooterCellValue(int rowIndex, int colIndex, object value)
    {
      this.CheckFooterCellIndices(rowIndex, colIndex);
      this.SetFooterCellValueInternal(rowIndex, colIndex, value);
      this.AutoHeightFooterRowOnEvent(rowIndex, iGAutoHeightEvents.OnContentsChange, true);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void SetFooterCellAuxValue(int rowIndex, int colIndex, object value)
    {
      this.CheckFooterCellIndices(rowIndex, colIndex);
      this.fFooterCells[rowIndex * this.fColCount + colIndex].AuxValue = value;
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void SetFooterCellImageIndex(int rowIndex, int colIndex, int imageIndex)
    {
      this.CheckFooterCellIndices(rowIndex, colIndex);
      this.fFooterCells[rowIndex * this.fColCount + colIndex].ImageIndex = imageIndex;
      this.AutoHeightFooterRowOnEvent(rowIndex, iGAutoHeightEvents.OnContentsChange, true);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void SetFooterCellStyle(int rowIndex, int colIndex, iGFooterCellStyle value)
    {
      this.CheckFooterCellIndices(rowIndex, colIndex);
      this.fFooterCells[rowIndex * this.fColCount + colIndex].Style = value;
      this.AutoHeightFooterRowOnEvent(rowIndex, iGAutoHeightEvents.OnContentsChange, true);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void SetFooterCellAggregateFunction(int rowIndex, int colIndex, iGAggregateFunction value)
    {
      this.CheckFooterCellIndices(rowIndex, colIndex);
      this.fFooterCells[rowIndex * this.fColCount + colIndex].AggregateFunction = value;
      this.UpdateAggregateFunctionCount();
      this.RecalcTotals();
      this.AutoHeightFooterRowOnEvent(rowIndex, iGAutoHeightEvents.OnContentsChange, true);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private int GetFooterAreaHeight()
    {
      if (this.fFooterVisible)
        return this.FooterVisibleRowsTotalHeight;
      return 0;
    }

    internal Rectangle GetFooterAreaBounds()
    {
      int footerAreaHeight = this.GetFooterAreaHeight();
      int borderSize = this.GetBorderSize();
      int x = borderSize;
      int width = this.Width - 2 * borderSize;
      if (this.fVScrollBar.Visible)
      {
        width -= this.fVScrollBar.Width;
        if (this.RightToLeft == RightToLeft.Yes)
          x += this.Width - width;
      }
      int y = this.Height - borderSize - footerAreaHeight;
      if (this.fHScrollBar.Visible)
        y -= this.fHScrollBar.Height;
      return new Rectangle(x, y, width, footerAreaHeight);
    }

    private Rectangle GetFooterAreaBoundsNoRowHdr(bool rightToLeft)
    {
      Rectangle footerAreaBounds = this.GetFooterAreaBounds();
      int num = this.fRowHeader.EffectiveWidth();
      if (!rightToLeft)
        footerAreaBounds.X += num;
      footerAreaBounds.Width -= num;
      return footerAreaBounds;
    }

    private Rectangle GetFooterRowHdrBounds()
    {
      int rowHeaderAreaLeft = this.GetRowHeaderAreaLeft(this.RightToLeft == RightToLeft.Yes);
      int num = this.fRowHeader.EffectiveWidth();
      Rectangle footerAreaBounds = this.GetFooterAreaBounds();
      int top = footerAreaBounds.Top;
      int width = num;
      int height = footerAreaBounds.Height;
      return new Rectangle(rowHeaderAreaLeft, top, width, height);
    }

    private Rectangle GetFooterExtraCellBounds()
    {
      int borderSize = this.GetBorderSize();
      int num = this.fRowHeader.EffectiveWidth();
      int vscrollBarWidth = this.GetVScrollBarWidth();
      int footerAreaHeight = this.GetFooterAreaHeight();
      int y = this.Height - borderSize - footerAreaHeight;
      int width = this.Width - 2 * borderSize - num - vscrollBarWidth - this.fVisibleColsWidthPlusGroupObjectLevelArea;
      if (this.RightToLeft == RightToLeft.Yes)
        return new Rectangle(vscrollBarWidth + borderSize, y, width, footerAreaHeight);
      return new Rectangle(borderSize + num + this.fVisibleColsWidthPlusGroupObjectLevelArea, y, width, footerAreaHeight);
    }

    internal bool FooterVisible
    {
      get
      {
        return this.fFooterVisible;
      }
      set
      {
        if (this.fFooterVisible == value)
          return;
        this.fFooterVisible = value;
        if (this.fAutoResizeCols)
          this.DoAutoResizeCols(0, 0, false, false, value);
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    internal Font GetFooterFont()
    {
      if (this.fFooterFont == null)
        return this.Font;
      return this.fFooterFont;
    }

    internal System.Drawing.Color GetFooterBackColor()
    {
      if (this.fFooterBackColor.IsEmpty)
        return this.BackColor;
      return this.fFooterBackColor;
    }

    internal System.Drawing.Color GetFooterForeColor()
    {
      if (this.fFooterForeColor.IsEmpty)
        return this.ForeColor;
      return this.fFooterForeColor;
    }

    private bool ShallFooterAutoHeightOnEvent(iGAutoHeightEvents @event)
    {
      return (uint) (this.fFooterAutoHeightEvents & @event) > 0U;
    }

    internal void AutoHeightFooterRowOnEvent(int rowIndex, iGAutoHeightEvents @event, bool adjustScrollBarsIfRedraw)
    {
      if (!this.ShallFooterAutoHeightOnEvent(@event))
        return;
      if (this.fRedraw)
        this.AutoHeightFooterRow(rowIndex, adjustScrollBarsIfRedraw);
      else
        this.fAutoHeightFooterWhenSetRedrawToTrue = true;
    }

    internal void AutoHeightFooterOnEvent(iGAutoHeightEvents @event, bool adjustScrollBarsIfRedraw)
    {
      if (!this.ShallFooterAutoHeightOnEvent(@event))
        return;
      if (this.fRedraw)
        this.AutoHeightFooter(adjustScrollBarsIfRedraw);
      else
        this.fAutoHeightFooterWhenSetRedrawToTrue = true;
    }

    internal void InvalidateFooterIfRedraw()
    {
      if (!this.fRedraw)
        return;
      this.Invalidate(this.GetFooterAreaBounds());
    }

    internal int GetColIndexOfMergedFooterCells(int rowIndex, int colOrder)
    {
      return this.fFooterSpanMap[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder]] % this.fColCount;
    }

    internal void SetFooterImageList(ImageList value)
    {
      if (value == this.fFooterImageList)
        return;
      if (this.fFooterImageList != null)
        this.fFooterImageList.RecreateHandle -= new EventHandler(this.FooterImageList_RecreateHandle);
      this.fFooterImageList = value;
      if (value != null)
      {
        if (value.HandleCreated)
          this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnContentsChange, true);
        value.RecreateHandle += new EventHandler(this.FooterImageList_RecreateHandle);
      }
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void FooterImageList_RecreateHandle(object sender, EventArgs e)
    {
      this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnContentsChange, true);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void FooterOnHandleCreated()
    {
      this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnContentsChange, true);
    }

    /// <summary>Occurs when the foreground of a custom draw footer cell is redrawn.</summary>
    [Category("Footer Cell Appearance")]
    [Description("Occurs when the foreground of a custom draw footer cell is redrawn.")]
    public event iGCustomDrawFooterCellEventHandler CustomDrawFooterCellForeground;

    /// <summary>Occurs when the background of a custom draw footer cell is redrawn.</summary>
    [Category("Footer Cell Appearance")]
    [Description("Occurs when the background of a custom draw footer cell is redrawn.")]
    public event iGCustomDrawFooterCellEventHandler CustomDrawFooterCellBackground;

    /// <summary>Occurs when the contents of the custom draw footer row header cell is redrawn.</summary>
    [Category("Footer Row Header Appearance")]
    [Description("Allows you to draw custom contents in the footer row header area.")]
    public event iGCustomDrawFooterRowHdrEventHandler CustomDrawFooterRowHdr;

    /// <summary>Occurs when the grid requires the width necessary to display all the contents of a custom draw footer cell entirely.</summary>
    [Category("Footer Cell Appearance")]
    [Description("Occurs when the grid needs the width enough to display the contents of a custom draw footer cell without clipping.")]
    public event iGCustomDrawFooterCellGetWidthEventHandler CustomDrawFooterCellGetWidth;

    /// <summary>Occurs when the grid requires the height necessary to display all the contents of a custom draw footer cell entirely.</summary>
    [Category("Footer Cell Appearance")]
    [Description("Occurs when the grid needs the height enough to display the contents of a custom draw footer cell without clipping.")]
    public event iGCustomDrawFooterCellGetHeightEventHandler CustomDrawFooterCellGetHeight;

    /// <summary>Occurs every time when the grid totals should be updated.</summary>
    [Category("Data")]
    [Description("Occurs when the totals in the footer should be recalculated.")]
    public event EventHandler RecalculateTotals;

    /// <summary>Occurs when iGrid needs to know whether a cell value should be used while calculating an aggregate function for grid totals.</summary>
    [Category("Data")]
    [Description("Determines whether a row is included in the calculation of totals.")]
    public event iGIncludeRowInTotalsCalculationEventHandler IncludeRowInTotalsCalculation;

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawFooterCellBackground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawFooterCellEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawFooterCellBackground(iGCustomDrawFooterCellEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawFooterCellBackground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawFooterCellBackground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawFooterCellForeground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawFooterCellEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawFooterCellForeground(iGCustomDrawFooterCellEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawFooterCellForeground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawFooterCellForeground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawFooterRowHdr" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawFooterRowHdrEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawFooterRowHdr(iGCustomDrawFooterRowHdrEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawFooterRowHdr == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawFooterRowHdr((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawFooterCellGetWidth" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawFooterCellGetWidthEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawFooterCellGetWidth(iGCustomDrawFooterCellGetWidthEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawFooterCellGetWidth == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawFooterCellGetWidth((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawFooterCellGetHeight" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawFooterCellGetHeightEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawFooterCellGetHeight(iGCustomDrawFooterCellGetHeightEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawFooterCellGetHeight == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawFooterCellGetHeight((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RecalculateTotals" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnRecalculateTotals(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RecalculateTotals == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RecalculateTotals((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.IncludeRowInTotalsCalculation" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGIncludeRowInTotalsCalculationEventArgs" /> that contains the event data.</param>
    protected virtual void OnIncludeRowInTotalsCalculation(iGIncludeRowInTotalsCalculationEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.IncludeRowInTotalsCalculation == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.IncludeRowInTotalsCalculation((object) this, e);
    }

    /// <summary>Gets the object that allows you to set up the header.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGHeader" /> object that represents the header.</value>
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Category("iGrid Areas")]
    [Description("The set of properties which allow you to set up the header.")]
    public iGHeader Header
    {
      get
      {
        if (this.fHeader == null)
          this.fHeader = new iGHeader(this);
        return this.fHeader;
      }
    }

    private bool ShouldSerializeHeader()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.Header);
    }

    private void ResetHeader()
    {
      this.Header.Appearance = iGControlPaintAppearance.Style3D;
      this.Header.BackColor = System.Drawing.Color.Empty;
      this.Header.SolidSortIconColor = System.Drawing.Color.Empty;
      this.Header.DrawSystem = true;
      this.Header.Font = (Font) null;
      this.Header.ForeColor = System.Drawing.Color.Empty;
      this.Header.Height = 19;
      this.Header.HGridLinesStyle = iGHeader.cDefaultGridLinesStyle.Clone();
      this.Header.HotTrackFlags = iGHdrHotTrackFlags.Text;
      this.Header.HotTrackForeColor = iGHeader.cDefaultHotTrackForeColor;
      this.Header.HotTrackIconDegree = -5;
      this.Header.ImageList = (ImageList) null;
      this.Header.SeparatingLine = iGHeader.cDefaultSeparatingLine.Clone();
      this.Header.UseXPStyles = true;
      this.Header.VGridLinesStyle = iGHeader.cDefaultGridLinesStyle.Clone();
      this.Header.Visible = true;
      this.Header.AutoHeightEvents = iGAutoHeightEvents.OnAddCol | iGAutoHeightEvents.OnContentsChange | iGAutoHeightEvents.OnThemeChange | iGAutoHeightEvents.OnRemoveRow;
    }

    internal int HeaderVisibleRowsTotalHeight
    {
      get
      {
        int num = 0;
        for (int index = 0; index < this.fHeaderRowCount; ++index)
        {
          if (this.fHeaderRows[index].Visible)
            num += this.fHeaderRows[index].Height;
        }
        return num;
      }
      set
      {
        if (value <= 0)
          throw new ArgumentOutOfRangeException(nameof (value), "Value cannot be less than or equal to zero");
        int visibleRowsTotalHeight = this.HeaderVisibleRowsTotalHeight;
        if (value == visibleRowsTotalHeight)
          return;
        int num1 = 0;
        for (int index = 0; index < this.fHeaderRowCount; ++index)
        {
          if (this.fHeaderRows[index].Visible)
            ++num1;
        }
        if (num1 == 0)
          return;
        int num2 = (value - visibleRowsTotalHeight) / num1;
        this.fHeaderRows[0].Height += (value - visibleRowsTotalHeight) % num1;
        for (int index = 0; index < this.fHeaderRowCount; ++index)
          this.fHeaderRows[index].Height += num2;
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    internal bool HeaderVisible
    {
      get
      {
        return this.fHeaderVisible;
      }
      set
      {
        if (this.fHeaderVisible == value)
          return;
        this.fHeaderVisible = value;
        if (this.fAutoResizeCols)
          this.DoAutoResizeCols(0, 0, false, value, false);
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    internal iGPenStyle HeaderVGridLinesStyle
    {
      get
      {
        return this.fHeaderVGridLinesStyle;
      }
      set
      {
        if (value == null)
          throw new ArgumentNullException();
        if (object.Equals((object) this.fHeaderVGridLinesStyle, (object) value))
          return;
        if (value.Width < 0)
          throw new ArgumentOutOfRangeException();
        this.fHeaderVGridLinesStyle = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    internal iGPenStyle HeaderHGridLinesStyle
    {
      get
      {
        return this.fHeaderHGridLinesStyle;
      }
      set
      {
        if (value == null)
          throw new ArgumentNullException();
        if (object.Equals((object) this.fHeaderHGridLinesStyle, (object) value))
          return;
        if (value.Width < 0)
          throw new ArgumentOutOfRangeException();
        this.fHeaderHGridLinesStyle = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    internal bool HeaderDrawSystem
    {
      get
      {
        return this.fHeaderDrawSystem;
      }
      set
      {
        if (this.fHeaderDrawSystem == value)
          return;
        this.fHeaderDrawSystem = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    private Rectangle GetColumnHeadersAreaBoundsNoRowHdr(bool rightToLeft)
    {
      Rectangle boundsNoRightToLeft = this.GetColumnHeadersAreaBounds_NoRightToLeft();
      int num = this.GetRowHeaderAreaLeft_NoRighToLeft() + this.fRowHeader.EffectiveWidth();
      boundsNoRightToLeft.Width -= num - boundsNoRightToLeft.Left;
      boundsNoRightToLeft.X = num;
      if (rightToLeft)
        boundsNoRightToLeft.X = this.Width - boundsNoRightToLeft.X - boundsNoRightToLeft.Width;
      return boundsNoRightToLeft;
    }

    private Rectangle GetColumnHeadersAreaBounds_NoRightToLeft()
    {
      int borderSize = this.GetBorderSize();
      int leftNoRighToLeft = this.GetRowHeaderAreaLeft_NoRighToLeft();
      int headerAreaTopEdge = this.GetColumnHeaderAreaTopEdge();
      int width = this.Width - borderSize - leftNoRighToLeft;
      int height = Math.Min(this.HeaderVisibleRowsTotalHeight, this.Height - borderSize - headerAreaTopEdge);
      return new Rectangle(leftNoRighToLeft, headerAreaTopEdge, width, height);
    }

    private int GetHeaderAreaTop()
    {
      return this.GetBorderSize();
    }

    private int GetColumnHeaderAreaTopEdge()
    {
      return this.GetHeaderAreaTop() + this.GetGroupBoxHeight();
    }

    internal int GetGroupBoxHeight()
    {
      if (!this.fGroupBoxVisible || !this.fHeaderVisible)
        return 0;
      int num = this.fHeaderRows[0].Height - this.GetHeaderHGridLinesWidth(0) + 12;
      int groupObjectColCount = this.GetGroupObjectColCount();
      if (groupObjectColCount > 0)
        num += 10 * (groupObjectColCount - 1);
      return num;
    }

    internal int GetHeaderAreaHeight()
    {
      if (this.fHeaderVisible)
        return this.HeaderVisibleRowsTotalHeight + this.GetGroupBoxHeight();
      return 0;
    }

    internal Rectangle GetHeaderAreaBounds()
    {
      int headerAreaHeight = this.GetHeaderAreaHeight();
      int borderSize = this.GetBorderSize();
      int x = borderSize;
      int width = this.Width - 2 * borderSize;
      if (this.fVScrollBar.Visible)
      {
        width -= this.fVScrollBar.Width;
        if (this.RightToLeft == RightToLeft.Yes)
          x += this.Width - width;
      }
      return new Rectangle(x, borderSize, width, headerAreaHeight);
    }

    private Rectangle GetHeaderExtraCellBounds(bool rightToLeft)
    {
      int borderSize = this.GetBorderSize();
      int num = this.fRowHeader.EffectiveWidth();
      int vscrollBarWidth = this.GetVScrollBarWidth();
      int headerAreaHeight = this.GetHeaderAreaHeight();
      int groupBoxHeight = this.GetGroupBoxHeight();
      if (rightToLeft)
        return new Rectangle(vscrollBarWidth + borderSize, borderSize + groupBoxHeight, this.Width - 2 * borderSize - num - vscrollBarWidth - this.fVisibleColsWidthPlusGroupObjectLevelArea, headerAreaHeight - groupBoxHeight);
      return new Rectangle(borderSize + num + this.fVisibleColsWidthPlusGroupObjectLevelArea, borderSize + groupBoxHeight, this.Width - 2 * borderSize - num - vscrollBarWidth - this.fVisibleColsWidthPlusGroupObjectLevelArea, headerAreaHeight - groupBoxHeight);
    }

    internal void CheckColHdrIndices(int rowIndex, int colIndex)
    {
      this.CheckHeaderRowIndex(rowIndex);
      this.CheckColIndex(colIndex);
    }

    internal void CheckHeaderRowIndex(int rowIndex)
    {
      if (rowIndex >= this.fHeaderRowCount || rowIndex < 0)
        throw new ArgumentOutOfRangeException();
    }

    private void CheckHeaderRowIndexAndCount(int rowIndex, int rowCount)
    {
      if (rowIndex < 0 || rowCount <= 0)
        throw new ArgumentOutOfRangeException();
      if (rowIndex + rowCount > this.fHeaderRowCount)
        throw new ArgumentException("Invalid row index or count");
    }

    private bool ShallHeaderAutoHeightOnEvent(iGAutoHeightEvents @event)
    {
      return (uint) (this.fHeaderAutoHeightEvents & @event) > 0U;
    }

    internal void AutoHeightHeaderOnEvent(iGAutoHeightEvents @event, bool adjustScrollBarsIfRedraw)
    {
      if (!this.ShallHeaderAutoHeightOnEvent(@event))
        return;
      if (this.fRedraw)
        this.AutoHeightHeader(adjustScrollBarsIfRedraw);
      else
        this.fAutoHeightHeaderWhenSetRedrawToTrue = true;
    }

    internal int GetColIndexOfMergedColHdrs(int rowIndex, int colOrder)
    {
      return this.fHeaderSpanMap[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder]] % this.fColCount;
    }

    internal System.Drawing.Color GetHeaderForeColor()
    {
      if (this.fHeaderForeColor.IsEmpty)
        return this.ForeColor;
      return this.fHeaderForeColor;
    }

    internal Font GetHeaderFont()
    {
      if (this.fHeaderFont == null)
        return this.Font;
      return this.fHeaderFont;
    }

    private void HeaderClearCols()
    {
      this.fHeaderSpanMap = new int[0];
      this.fColHdrs = new iGColHdrData[0];
    }

    internal void InvalidateHeaderIfRedraw()
    {
      if (!this.fRedraw)
        return;
      this.Invalidate(this.GetHeaderAreaBounds());
    }

    internal void SetHeaderRowCount(int newRowCount)
    {
      if (this.fHeaderRowCount == newRowCount)
        return;
      if (newRowCount > this.fHeaderRowCount)
      {
        this.AddHeaderRows(newRowCount - this.fHeaderRowCount);
      }
      else
      {
        Array.Resize<iGHdrRowData>(ref this.fHeaderRows, newRowCount);
        int newSize = newRowCount * this.fColCount;
        Array.Resize<iGColHdrData>(ref this.fColHdrs, newSize);
        Array.Resize<int>(ref this.fHeaderSpanMap, newSize);
        this.fHeaderRowCount = newRowCount;
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    private void CreateHeaderData()
    {
      this.fHeaderRowCount = 1;
      int length = this.fColCount * this.fHeaderRowCount;
      this.fHeaderRows = new iGHdrRowData[this.fHeaderRowCount];
      this.fHeaderSpanMap = new int[length];
      this.fColHdrs = new iGColHdrData[length];
      for (int index = 0; index < this.fHeaderRowCount; ++index)
        this.fHeaderRows[index] = new iGHdrRowData(19, true);
      for (int index = 0; index < length; ++index)
      {
        this.fHeaderSpanMap[index] = index;
        this.fColHdrs[index] = new iGColHdrData((object) null, -1);
      }
    }

    internal int AddHeaderRows(int count)
    {
      return this.AddHeaderRows(count, new iGHdrRowPattern());
    }

    internal int AddHeaderRows(int count, iGHdrRowPattern headerRowPattern)
    {
      if (headerRowPattern == null)
        throw new ArgumentNullException();
      this.fHeaderRowCount = this.fHeaderRowCount + count;
      int length = this.fColCount * this.fHeaderRowCount;
      iGHdrRowData[] iGhdrRowDataArray = new iGHdrRowData[this.fHeaderRowCount];
      Array.Copy((Array) this.fHeaderRows, 0, (Array) iGhdrRowDataArray, 0, this.fHeaderRowCount - count);
      for (int index = this.fHeaderRowCount - count; index < this.fHeaderRowCount; ++index)
        iGhdrRowDataArray[index] = headerRowPattern.fData;
      this.fHeaderRows = iGhdrRowDataArray;
      iGColHdrData[] iGcolHdrDataArray = new iGColHdrData[length];
      int[] numArray = new int[length];
      Array.Copy((Array) this.fColHdrs, 0, (Array) iGcolHdrDataArray, 0, length - count * this.fColCount);
      Array.Copy((Array) this.fHeaderSpanMap, 0, (Array) numArray, 0, length - count * this.fColCount);
      for (int index = length - count * this.fColCount; index < length; ++index)
      {
        iGcolHdrDataArray[index] = this.fDefaultCol.ColHdr;
        numArray[index] = index;
      }
      this.fHeaderSpanMap = numArray;
      this.fColHdrs = iGcolHdrDataArray;
      this.RefreshGridAndScrollBarsIfRedraw();
      return this.fHeaderRowCount - count;
    }

    internal void RemoveHeaderRowRange(int rowIndex, int count)
    {
      this.CheckHeaderRowIndex(rowIndex);
      if (count == 0)
        return;
      if (count < 0)
        throw new ArgumentOutOfRangeException();
      if (rowIndex < 1)
        throw new ArgumentOutOfRangeException();
      int length1 = this.fHeaderRowCount - count;
      iGHdrRowData[] iGhdrRowDataArray = new iGHdrRowData[length1];
      Array.Copy((Array) this.fHeaderRows, (Array) iGhdrRowDataArray, rowIndex);
      for (int index = 0; index < this.fHeaderRowCount - rowIndex - count; ++index)
        iGhdrRowDataArray[rowIndex + index] = this.fHeaderRows[rowIndex + index + count];
      this.fHeaderRows = iGhdrRowDataArray;
      int length2 = length1 * this.fColCount;
      iGColHdrData[] iGcolHdrDataArray = new iGColHdrData[length2];
      Array.Copy((Array) this.fColHdrs, (Array) iGcolHdrDataArray, rowIndex * this.fColCount);
      for (int index1 = 0; index1 < this.fHeaderRowCount - rowIndex - count; ++index1)
      {
        for (int index2 = 0; index2 < this.fColCount; ++index2)
          iGcolHdrDataArray[(rowIndex + index1) * this.fColCount + index2] = this.fColHdrs[(rowIndex + index1 + count) * this.fColCount + index2];
      }
      this.fColHdrs = iGcolHdrDataArray;
      int[] numArray = new int[length2];
      Array.Copy((Array) this.fHeaderSpanMap, (Array) numArray, rowIndex * this.fColCount);
      int num = (rowIndex + count) * this.fColCount;
      for (int index1 = 0; index1 < this.fHeaderRowCount - rowIndex - count; ++index1)
      {
        for (int index2 = 0; index2 < this.fColCount; ++index2)
        {
          int fHeaderSpan = this.fHeaderSpanMap[(rowIndex + index1 + count) * this.fColCount + index2];
          if (fHeaderSpan >= num)
            fHeaderSpan -= count * this.fColCount;
          numArray[(rowIndex + index1) * this.fColCount + index2] = fHeaderSpan;
        }
      }
      this.fHeaderSpanMap = numArray;
      this.fHeaderRowCount = length1;
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnRemoveRow, false);
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal bool SetHeaderRowHeight(int rowIndex, int value, bool adjustScrollBarsIfRedraw)
    {
      this.CheckHeaderRowIndex(rowIndex);
      iGrid.CheckRowHeight(value);
      if (this.fHeaderRows[rowIndex].Height == value)
        return false;
      this.fHeaderRows[rowIndex].Height = value;
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(0, 0, false, false, false);
      this.RefreshGridAndScrollBarsIfRedraw(adjustScrollBarsIfRedraw);
      return true;
    }

    internal void SetHeaderRowVisible(int rowIndex, bool value)
    {
      this.CheckHeaderRowIndex(rowIndex);
      if (this.fHeaderRows[rowIndex].Visible == value)
        return;
      this.fHeaderRows[rowIndex].Visible = value;
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(0, 0, false, false, false);
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal void SetHeaderRow(int rowIndex, iGHdrRowData value)
    {
      this.CheckHeaderRowIndex(rowIndex);
      iGrid.CheckRowHeight(value.Height);
      iGHdrRowData fHeaderRow = this.fHeaderRows[rowIndex];
      this.fHeaderRows[rowIndex] = value;
      this.RefreshGridAndScrollBarsIfRedraw(fHeaderRow.Height != value.Height || fHeaderRow.Visible != value.Visible);
    }

    internal void SetHeaderRowDirect(int rowIndex, iGHdrRowData value)
    {
      this.fHeaderRows[rowIndex] = value;
    }

    internal iGHdrRowData GetHeaderRow(int rowIndex)
    {
      this.CheckHeaderRowIndex(rowIndex);
      return this.fHeaderRows[rowIndex];
    }

    internal void SetColHdrValue(int rowIndex, int colIndex, object value)
    {
      this.CheckColHdrIndices(rowIndex, colIndex);
      this.fColHdrs[rowIndex * this.fColCount + colIndex].Value = value;
      if (this.fRedraw)
        this.Invalidate();
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnContentsChange, true);
    }

    internal void SetColHdrAuxValue(int rowIndex, int colIndex, object value)
    {
      this.CheckColHdrIndices(rowIndex, colIndex);
      this.fColHdrs[rowIndex * this.fColCount + colIndex].AuxValue = value;
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    internal void SetColHdrStyle(int rowIndex, int colIndex, iGColHdrStyle value)
    {
      this.CheckColHdrIndices(rowIndex, colIndex);
      this.fColHdrs[rowIndex * this.fColCount + colIndex].Style = value;
      if (this.fRedraw)
        this.Invalidate();
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnContentsChange, true);
    }

    internal void SetColHdrImageIndex(int rowIndex, int colIndex, int imageIndex)
    {
      this.CheckColHdrIndices(rowIndex, colIndex);
      this.fColHdrs[rowIndex * this.fColCount + colIndex].ImageIndex = imageIndex;
      if (this.fRedraw)
        this.Invalidate();
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnContentsChange, true);
    }

    internal void SetColHdrData(int rowIndex, int colIndex, iGColHdrData colHdrData)
    {
      this.CheckColHdrIndices(rowIndex, colIndex);
      this.fColHdrs[rowIndex * this.fColCount + colIndex] = colHdrData;
      this.Span__PropertySpanColsSet(iGGridSection.Header, rowIndex, colIndex, colHdrData.SpanCols);
      this.Span__PropertySpanRowsSet(iGGridSection.Header, rowIndex, colIndex, colHdrData.SpanRows);
      if (this.fRedraw)
        this.Invalidate();
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnContentsChange, true);
    }

    internal iGColHdrData GetColHdrData(int rowIndex, int colIndex)
    {
      this.CheckColHdrIndices(rowIndex, colIndex);
      return this.GetColHdrDataInternal(rowIndex, colIndex);
    }

    internal iGColHdrData GetColHdrDataInternal(int rowIndex, int colIndex)
    {
      return this.fColHdrs[rowIndex * this.fColCount + colIndex];
    }

    private void HeaderOnColAdded(iGColHdrData[] cells, int colBefore, int count)
    {
      iGColHdrData iGcolHdrData = new iGColHdrData((object) null, -1);
      int length = this.fColCount * this.fHeaderRowCount;
      int[] numArray = new int[length];
      iGColHdrData[] iGcolHdrDataArray = new iGColHdrData[length];
      int num1 = this.fColCount - count;
      int index1 = 0;
      int index2 = 0;
      int num2 = num1 - colBefore;
      for (int index3 = 0; index3 < this.fHeaderRowCount; ++index3)
      {
        for (int index4 = 0; index4 < this.fColCount; ++index4)
        {
          if (this.fHeaderSpanMap == null || index4 >= colBefore && index4 < colBefore + count)
          {
            numArray[index1] = index1;
            iGcolHdrDataArray[index1] = cells == null ? iGcolHdrData : cells[index4 - colBefore];
          }
          else
          {
            int fHeaderSpan = this.fHeaderSpanMap[index2];
            int num3 = fHeaderSpan + (fHeaderSpan + num2) / num1 * count;
            numArray[index1] = num3;
            iGcolHdrDataArray[index1] = this.fColHdrs[index2];
            ++index2;
          }
          ++index1;
        }
      }
      this.fHeaderSpanMap = numArray;
      this.fColHdrs = iGcolHdrDataArray;
    }

    private void HeaderOnColRemoved(int colIndex, int count)
    {
      int length = this.fColCount * this.fHeaderRowCount;
      int[] numArray = new int[length];
      iGColHdrData[] iGcolHdrDataArray = new iGColHdrData[length];
      int num1 = colIndex + count;
      int num2 = this.fColCount + count;
      int index1 = 0;
      int index2 = 0;
      if (this.fColCount > 0)
      {
        for (int index3 = 0; index3 < this.fHeaderRowCount; ++index3)
        {
          int num3 = 0;
          while (true)
          {
            if (num3 == colIndex)
              index2 += count;
            if (num3 < this.fColCount)
            {
              int fHeaderSpan = this.fHeaderSpanMap[index2];
              int num4 = fHeaderSpan % num2;
              if (num4 >= colIndex && num4 < num1)
              {
                if (num3 == colIndex)
                  iGcolHdrDataArray[index1] = this.fColHdrs[fHeaderSpan];
                fHeaderSpan -= num4 - colIndex;
              }
              else
              {
                iGcolHdrDataArray[index1] = this.fColHdrs[index2];
                if (num4 >= num1)
                  fHeaderSpan -= count;
              }
              int num5 = fHeaderSpan - fHeaderSpan / num2 * count;
              numArray[index1] = num5;
              ++index1;
              ++index2;
              ++num3;
            }
            else
              break;
          }
        }
      }
      this.fHeaderSpanMap = numArray;
      this.fColHdrs = iGcolHdrDataArray;
    }

    private bool ColRangeContainsNonMoveableCols(int colOrder, int colCount)
    {
      for (int index = colOrder + colCount - 1; index >= colOrder; --index)
      {
        if (!this.fColDatas[this.fColIdxFromOrd[index]].AllowMoving)
          return true;
      }
      return false;
    }

    private bool ColRangeContainsNonGroupableCols(int colOrder, int colCount)
    {
      for (int index = colOrder + colCount - 1; index >= colOrder; --index)
      {
        if (!this.fColDatas[this.fColIdxFromOrd[index]].AllowGrouping)
          return true;
      }
      return false;
    }

    internal bool ColContainsRowText(int colIndex)
    {
      bool flag1 = false;
      if (this.IsRowTextDisplayed())
      {
        int colOrder = this.GetColOrder(colIndex);
        bool flag2 = this.fRowTextStartColNear == 1;
        bool flag3 = this.fRowTextEndColFar == 0;
        flag1 = flag2 & flag3 || (!flag2 ? (!flag3 ? this.fRowTextStartColNear <= colOrder && colOrder < this.fColCount - this.fRowTextEndColFar : this.fRowTextStartColNear <= colOrder) : colOrder < this.fColCount - this.fRowTextEndColFar);
      }
      return flag1;
    }

    internal bool CanMoveCols(int srcOrder, int srcCount, out int dstStartOrder, out int dstEndOrder, out bool[] rowsMap, out string reasonCantMove)
    {
      this.CheckColIndexAndCount(srcOrder, srcCount, nameof (srcOrder));
      dstStartOrder = -1;
      dstEndOrder = -1;
      rowsMap = (bool[]) null;
      reasonCantMove = (string) null;
      if (this.IsExtraCol(srcOrder))
      {
        reasonCantMove = "Cannot move row text column";
        return false;
      }
      if (this.ColRangeContainsNonMoveableCols(srcOrder, srcCount))
      {
        reasonCantMove = "Cannot move non-moveable columns";
        return false;
      }
      int colIndex = this.fColIdxFromOrd[srcOrder];
      int? nullable1 = new int?();
      if (srcOrder > 0)
        nullable1 = new int?(this.fColIdxFromOrd[srcOrder - 1]);
      int num1 = this.fColIdxFromOrd[srcOrder + srcCount - 1];
      int? nullable2 = new int?();
      if (srcOrder + srcCount < this.fColCount)
        nullable2 = new int?(this.fColIdxFromOrd[srcOrder + srcCount]);
      if (this.fMergedCellCountHorz > 0)
      {
        if (colIndex > 1)
        {
          for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
          {
            if (this.GetCellDataInternal(rowIndex, colIndex).SpanCols < 0)
            {
              reasonCantMove = "Cannot break merged cells";
              return false;
            }
          }
        }
        if (nullable2.HasValue)
        {
          for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
          {
            if (this.GetCellDataInternal(rowIndex, nullable2.Value).SpanCols < 0)
            {
              reasonCantMove = "Cannot break merged cells";
              return false;
            }
          }
        }
      }
      int num2 = 0;
      int num3 = 0;
      while (num3 < this.fFooterRowCount)
      {
        if (nullable1.HasValue && this.fFooterSpanMap[num2 + nullable1.Value] == this.fFooterSpanMap[num2 + colIndex])
        {
          reasonCantMove = "Cannot break merged cells";
          return false;
        }
        if (nullable2.HasValue && this.fFooterSpanMap[num2 + num1] == this.fFooterSpanMap[num2 + nullable2.Value])
        {
          reasonCantMove = "Cannot break merged cells";
          return false;
        }
        ++num3;
        num2 += this.fColCount;
      }
      int num4 = 0;
      int num5 = int.MaxValue;
      int num6 = int.MaxValue;
      dstStartOrder = 0;
      dstEndOrder = this.fColCount - 1;
      rowsMap = new bool[this.fHeaderRowCount];
      int index1 = 0;
      while (index1 < this.fHeaderRowCount)
      {
        if (nullable1.HasValue)
        {
          int fHeaderSpan = this.fHeaderSpanMap[num4 + colIndex];
          if (fHeaderSpan == this.fHeaderSpanMap[num4 + nullable1.Value])
          {
            if (this.fHeaderSpanMap[num4 + num1] != fHeaderSpan)
            {
              rowsMap = (bool[]) null;
              reasonCantMove = "Cannot break merged cells";
              return false;
            }
            int? nullable3 = nullable2;
            int num7 = 0;
            if (nullable3.GetValueOrDefault() >= num7 & nullable3.HasValue)
            {
              int num8 = 1;
              int index2 = srcOrder + num8;
              while (num8 <= num6 && this.fHeaderSpanMap[num4 + this.fColIdxFromOrd[index2]] == fHeaderSpan)
              {
                ++num8;
                ++index2;
                if (index2 >= this.fColCount)
                  break;
              }
              num6 = num8 - 1;
            }
            else
              num6 = 0;
            int num9 = 1;
            int index3 = srcOrder - num9;
            while (num9 <= num5 && this.fHeaderSpanMap[num4 + this.fColIdxFromOrd[index3]] == fHeaderSpan)
            {
              ++num9;
              --index3;
              if (index3 < 0)
                break;
            }
            num5 = num9 - 1;
            goto label_52;
          }
        }
        if (nullable2.HasValue)
        {
          int fHeaderSpan = this.fHeaderSpanMap[num4 + num1];
          if (fHeaderSpan == this.fHeaderSpanMap[num4 + nullable2.Value])
          {
            if (this.fHeaderSpanMap[num4 + colIndex] != fHeaderSpan)
            {
              rowsMap = (bool[]) null;
              reasonCantMove = "Cannot break merged cells";
              return false;
            }
            num5 = 0;
            int num7 = 1;
            int index2 = srcOrder + num7;
            while (num7 <= num6 && this.fHeaderSpanMap[num4 + this.fColIdxFromOrd[index2]] == fHeaderSpan)
            {
              ++num7;
              ++index2;
              if (index2 >= this.fColCount)
                break;
            }
            num6 = num7 - 1;
            goto label_52;
          }
        }
        rowsMap[index1] = true;
label_52:
        ++index1;
        num4 += this.fColCount;
      }
      if (num5 != int.MaxValue)
      {
        dstStartOrder = srcOrder - num5;
        dstEndOrder = srcOrder + num6 + 1 - srcCount;
      }
      if (dstStartOrder < 1)
        dstStartOrder = 1;
      if (dstStartOrder < dstEndOrder)
        return true;
      reasonCantMove = "Invalid source or destination order";
      return false;
    }

    internal bool CanPlaceColsTo(int srcOrder, int dstOrder, int count, bool[] rowsMap, out string reasonCantPlace)
    {
      this.CheckColIndexAndCount(srcOrder, count, nameof (srcOrder));
      this.CheckColIndexAndCount(dstOrder, count, nameof (dstOrder));
      reasonCantPlace = (string) null;
      if (srcOrder <= dstOrder)
      {
        if (this.ColRangeContainsNonMoveableCols(srcOrder + count, dstOrder - srcOrder))
        {
          reasonCantPlace = "Cannot move non-moveable columns";
          return false;
        }
      }
      else if (this.ColRangeContainsNonMoveableCols(dstOrder, srcOrder - dstOrder))
      {
        reasonCantPlace = "Cannot move non-moveable columns";
        return false;
      }
      if (this.fFrozenColCount > 1)
      {
        int index = -1;
        if (srcOrder >= this.fFrozenColCount)
        {
          if (dstOrder < this.fFrozenColCount)
          {
            int num = dstOrder + count;
            if (num < this.fFrozenColCount)
              index = num;
            else if (num > this.fFrozenColCount)
              index = srcOrder + this.fFrozenColCount - dstOrder;
          }
        }
        else if (dstOrder + count > this.fFrozenColCount)
          index = dstOrder < this.fFrozenColCount ? srcOrder + this.fFrozenColCount - dstOrder : this.fFrozenColCount + count;
        if (index > 0 && !this.CanSeparateCols(this.fColIdxFromOrd[index - 1], this.fColIdxFromOrd[index], (bool[]) null))
        {
          reasonCantPlace = "Cannot break merged cells";
          return false;
        }
      }
      if (dstOrder != 0 && dstOrder + count != this.fColCount)
      {
        int colIndex1;
        int colIndex2;
        if (dstOrder <= srcOrder)
        {
          colIndex1 = this.fColIdxFromOrd[dstOrder - 1];
          colIndex2 = this.fColIdxFromOrd[dstOrder];
        }
        else
        {
          colIndex1 = this.fColIdxFromOrd[dstOrder + count - 1];
          colIndex2 = this.fColIdxFromOrd[dstOrder + count];
        }
        if (!this.CanSeparateCols(colIndex1, colIndex2, rowsMap))
        {
          reasonCantPlace = "Cannot break merged cells";
          return false;
        }
      }
      if (this.IsRowTextDisplayed() && this.fMergedCellCountAll > 0)
      {
        int[] colIdxFromOrd = new int[this.fColIdxFromOrd.Length];
        Array.Copy((Array) this.fColIdxFromOrd, (Array) colIdxFromOrd, this.fColIdxFromOrd.Length);
        this.MoveColsInColIdxFromOrdArray(colIdxFromOrd, srcOrder, dstOrder, count);
        if (this.WillMergedCellsIntersectRowTexts(this.fRowTextStartColNear, this.fRowTextEndColFar, colIdxFromOrd, int.MaxValue, 0))
        {
          reasonCantPlace = "Row text cells and merged cells cannot overlap";
          return false;
        }
      }
      return true;
    }

    private bool CanSeparateCols(int colIndex1, int colIndex2, bool[] rowsMap)
    {
      for (int index = 0; index < this.fHeaderRowCount; ++index)
      {
        if (rowsMap == null || rowsMap[index])
        {
          int num = index * this.fColCount;
          if (this.fHeaderSpanMap[num + colIndex1] == this.fHeaderSpanMap[num + colIndex2])
            return false;
        }
      }
      for (int index = 0; index < this.fFooterRowCount; ++index)
      {
        int num = index * this.fColCount;
        if (this.fFooterSpanMap[num + colIndex1] == this.fFooterSpanMap[num + colIndex2])
          return false;
      }
      if (this.fMergedCellCountHorz > 0)
      {
        for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
        {
          if (this.GetCellDataInternal(rowIndex, colIndex2).SpanCols < 0)
            return false;
        }
      }
      return true;
    }

    internal void HeaderResetData()
    {
      this.CreateHeaderData();
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal void SetHeaderImageList(ImageList value)
    {
      if (value == this.fHeaderImageList)
        return;
      if (this.fHeaderImageList != null)
        this.fHeaderImageList.RecreateHandle -= new EventHandler(this.HeaderImageList_RecreateHandle);
      this.fHeaderImageList = value;
      if (value != null)
      {
        if (value.HandleCreated)
          this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnContentsChange, true);
        value.RecreateHandle += new EventHandler(this.HeaderImageList_RecreateHandle);
      }
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void HeaderImageList_RecreateHandle(object sender, EventArgs e)
    {
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnContentsChange, true);
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void HeaderOnHandleCreated()
    {
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnContentsChange, true);
    }

    /// <summary>Occurs when the foreground of a custom draw column header is redrawn.</summary>
    [Category("Column Header Appearance")]
    [Description("Occurs when the foreground of a custom draw column header is redrawn.")]
    public event iGCustomDrawColHdrEventHandler CustomDrawColHdrForeground;

    /// <summary>Occurs when the background of a custom draw column header is redrawn.</summary>
    [Category("Column Header Appearance")]
    [Description("Occurs when the background of a custom draw column header is redrawn.")]
    public event iGCustomDrawColHdrEventHandler CustomDrawColHdrBackground;

    /// <summary>Occurs when the grid requires the width necessary to display all the contents of a custom draw column header entirely.</summary>
    [Category("Column Header Appearance")]
    [Description("Occurs when the grid needs the width enough to display the contents of a custom draw column header without clipping.")]
    public event iGCustomDrawColHdrGetWidthEventHandler CustomDrawColHdrGetWidth;

    /// <summary>Occurs when the grid requires the height necessary to display all the contents of a custom draw column header entirely.</summary>
    [Category("Column Header Appearance")]
    [Description("Occurs when the grid needs the height enough to display the contents of a custom draw column header without clipping.")]
    public event iGCustomDrawColHdrGetHeightEventHandler CustomDrawColHdrGetHeight;

    private iGrid.iGCellKindAsMerged GetCellKindAsMerged(iGCellNavigator cell)
    {
      return this.GetCellKindAsMerged(cell.RowIndex, cell.ColIndex);
    }

    private iGrid.iGCellKindAsMerged GetCellKindAsMerged(int rowIndex, int colIndex)
    {
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      if (cellDataInternal.SpanCols == 1 && cellDataInternal.SpanRows == 1)
        return iGrid.iGCellKindAsMerged.Normal;
      return cellDataInternal.SpanCols > 1 || cellDataInternal.SpanRows > 1 ? iGrid.iGCellKindAsMerged.MergedRoot : iGrid.iGCellKindAsMerged.MergedNonRoot;
    }

    private int MergedCellExpandWidthDelta(int colOrder, int spanCols)
    {
      int num = 0;
      for (int index = 1; index < spanCols; ++index)
      {
        int colIndex = this.fColIdxFromOrd[colOrder + index];
        if (this.IsColVisible(colIndex))
          num += this.fColDatas[colIndex].Width;
      }
      return num;
    }

    private int MergedCellExpandHeightDelta(int rowIndex, int spanRows)
    {
      int num = 0;
      for (int index = 1; index < spanRows; ++index)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex + index);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          num += rowDataInternal.Height;
      }
      return num;
    }

    private void IfMergedCellSetRowColToRoot(ref int rowIndex, ref int colOrder)
    {
      if (this.fMergedCellCountAll <= 0)
        return;
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, this.fColIdxFromOrd[colOrder]);
      if (cellDataInternal.SpanCols < 1)
        colOrder = colOrder + cellDataInternal.SpanCols;
      if (cellDataInternal.SpanRows >= 1)
        return;
      rowIndex = rowIndex + cellDataInternal.SpanRows;
    }

    private bool CheckUnmergeCellsSortGroup(iGUnmergeCellsRequiredReason reason, int colIndex)
    {
      bool flag = true;
      if (this.fMergedCellCountVert > 0)
      {
        iGUnmergeCellsRequiredEventArgs e = new iGUnmergeCellsRequiredEventArgs(false, reason, colIndex);
        this.OnUnmergeCellsRequired(e);
        flag = e.CellsUnmerged;
      }
      return flag;
    }

    private bool WillMergedCellsIntersectRowTexts(int rowTextStartColNear, int rowTextEndColFar, int[] colIdxFromOrd, int colCountDeltaOrder, int colCountDelta)
    {
      int rowTextEndColOrder = this.GetRowTextEndColOrder(rowTextEndColFar, this.fColCount + colCountDelta);
      for (int index = 0; index < this.fMergedCells.Count; ++index)
      {
        iGCellNavigator iGcellNavigator = this.fMergedCells.GetItem(index);
        iGCellData cellDataInternal = this.GetCellDataInternal(iGcellNavigator.RowIndex, iGcellNavigator.ColIndex);
        int colOrder = this.GetColOrder(iGcellNavigator.ColIndex, colIdxFromOrd);
        if (colOrder >= colCountDeltaOrder)
          colOrder += colCountDelta;
        if (cellDataInternal.SpanCols > 1)
        {
          int num = colOrder + cellDataInternal.SpanCols - 1;
          if (colOrder < rowTextStartColNear && rowTextStartColNear <= num || colOrder <= rowTextEndColOrder && rowTextEndColOrder < num)
            return true;
        }
        if (cellDataInternal.SpanRows > 1 && colOrder >= rowTextStartColNear && colOrder <= rowTextEndColOrder)
          return true;
      }
      return false;
    }

    /// <summary>Gets the collection of the merged cells.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGSelectedCellsCollection" /> object that represents the collection of merged cells.</value>
    [Browsable(false)]
    public iGSelectedCellsCollection MergedCells
    {
      get
      {
        if (this.fMergedCellsPublicCollection == null)
          this.fMergedCellsPublicCollection = new iGSelectedCellsCollection(this, this.fMergedCells);
        return this.fMergedCellsPublicCollection;
      }
    }

    /// <summary>Merges adjacent cells with the same values in the column with the specified numeric index.</summary>
    /// <param name="colIndex">The numeric index of the column to merge cells in.</param>
    public void MergeCellsInCols(int colIndex)
    {
      this.MergeCellsInCols(new int[1]{ colIndex }, new iGCellStyle[1]);
    }

    /// <summary>Merges adjacent cells with the same values and applies the specified cell style to them in the column with the specified numeric index.</summary>
    /// <param name="colIndex">The numeric index of the column to merge cells in.</param>
    /// <param name="mergedCellStyle">An <see cref="T:TenTec.Windows.iGridLib.iGCellStyle" /> object containing the desired formatting of merged cells.</param>
    public void MergeCellsInCols(int colIndex, iGCellStyle mergedCellStyle)
    {
      this.MergeCellsInCols(new int[1]{ colIndex }, new iGCellStyle[1]
      {
        mergedCellStyle
      });
    }

    /// <summary>Merges adjacent cells with the same values in the column with the specified string key.</summary>
    /// <param name="colKey">The string key of the column to merge cells in.</param>
    public void MergeCellsInCols(string colKey)
    {
      this.MergeCellsInCols(new string[1]{ colKey }, new iGCellStyle[1]);
    }

    /// <summary>Merges adjacent cells with the same values and applies the specified cell style to them in the column with the specified string key.</summary>
    /// <param name="colKey">The string key of the column to merge cells in.</param>
    /// <param name="mergedCellStyle">An <see cref="T:TenTec.Windows.iGridLib.iGCellStyle" /> object containing the desired formatting of merged cells.</param>
    public void MergeCellsInCols(string colKey, iGCellStyle mergedCellStyle)
    {
      this.MergeCellsInCols(new string[1]{ colKey }, new iGCellStyle[1]
      {
        mergedCellStyle
      });
    }

    /// <summary>Merges adjacent cells with the same values in the columns with the specified numeric indices.</summary>
    /// <param name="colIndices">An array of <see cref="T:System.Int32" /> values that specify the numeric column indices to merge cells in.</param>
    public void MergeCellsInCols(int[] colIndices)
    {
      this.MergeCellsInCols(colIndices, new iGCellStyle[1]);
    }

    /// <summary>Merges adjacent cells with the same values and applies the specified cell style to them in the columns with the specified numeric indices.</summary>
    /// <param name="colIndices">An array of <see cref="T:System.Int32" /> values that specify the numeric column indices to merge cells in.</param>
    /// <param name="mergedCellStyle">An <see cref="T:TenTec.Windows.iGridLib.iGCellStyle" /> object containing the desired formatting of merged cells.</param>
    public void MergeCellsInCols(int[] colIndices, iGCellStyle mergedCellStyle)
    {
      this.MergeCellsInCols(colIndices, new iGCellStyle[1]
      {
        mergedCellStyle
      });
    }

    /// <summary>Merges adjacent cells with the same values in the columns with the specified string keys.</summary>
    /// <param name="colKeys">An array of string values that specify the string column keys to merge cells in.</param>
    public void MergeCellsInCols(string[] colKeys)
    {
      this.MergeCellsInCols(colKeys, new iGCellStyle[1]);
    }

    /// <summary>Merges adjacent cells with the same values and applies the specified cell style to them in the columns with the specified string keys.</summary>
    /// <param name="colKeys">An array of string values that specify the string column keys to merge cells in.</param>
    /// <param name="mergedCellStyle">An <see cref="T:TenTec.Windows.iGridLib.iGCellStyle" /> object containing the desired formatting of merged cells.</param>
    public void MergeCellsInCols(string[] colKeys, iGCellStyle mergedCellStyle)
    {
      this.MergeCellsInCols(colKeys, new iGCellStyle[1]
      {
        mergedCellStyle
      });
    }

    /// <summary>Merges adjacent cells with the same values and applies the specified cell styles to them in the columns with the specified string keys.</summary>
    /// <param name="colKeys">An array of string values that specify the string column keys to merge cells in.</param>
    /// <param name="mergedCellStyles">An array of <see cref="T:TenTec.Windows.iGridLib.iGCellStyle" /> objects containing the desired formatting of merged cells.</param>
    public void MergeCellsInCols(string[] colKeys, iGCellStyle[] mergedCellStyles)
    {
      int[] colIndices = new int[colKeys.Length];
      for (int index = 0; index < colKeys.Length; ++index)
        colIndices[index] = this.ColKeyToIndex(colKeys[index], true) - 1;
      this.MergeCellsInCols(colIndices, mergedCellStyles);
    }

    /// <summary>Merges adjacent cells with the same values and applies the specified cell styles to them in the columns with the specified numeric indices.</summary>
    /// <param name="colIndices">An array of <see cref="T:System.Int32" /> values that specify the numeric column indices to merge cells in.</param>
    /// <param name="mergedCellStyles">An array of <see cref="T:TenTec.Windows.iGridLib.iGCellStyle" /> objects containing the desired formatting of merged cells.</param>
    public void MergeCellsInCols(int[] colIndices, iGCellStyle[] mergedCellStyles)
    {
      if (colIndices.Length == 0)
        throw new ArgumentException("Column array must contain values", "columns");
      int[] array = new int[colIndices.Length];
      for (int index = 0; index < colIndices.Length; ++index)
      {
        int colIndex = colIndices[index];
        this.CheckColIndex(colIndex);
        array[index] = this.GetColOrder(colIndex + 1);
      }
      for (int index1 = 0; index1 < this.fMergedCells.Count; ++index1)
      {
        iGCellNavigator iGcellNavigator = this.fMergedCells.GetItem(index1);
        iGCellData cellDataInternal = this.GetCellDataInternal(iGcellNavigator.RowIndex, iGcellNavigator.ColIndex);
        int colOrder = this.GetColOrder(iGcellNavigator.ColIndex);
        for (int index2 = colOrder; index2 <= colOrder + cellDataInternal.SpanCols - 1; ++index2)
        {
          if (Array.IndexOf<int>(array, index2) > -1)
            throw new ArgumentException("Merged cells cannot overlap", "columns");
        }
      }
      if (this.IsRowTextDisplayed())
      {
        int rowTextEndColOrder = this.GetRowTextEndColOrder();
        for (int index = 0; index < colIndices.Length; ++index)
        {
          int num = array[index];
          if (num >= this.fRowTextStartColNear && num <= rowTextEndColOrder)
            throw new ArgumentException("Row text cells and merged cells cannot overlap");
        }
      }
      if (this.fRowCount < 2)
        return;
      this.BeginUpdate();
      for (int index1 = 0; index1 < colIndices.Length; ++index1)
      {
        object[] objArray = new object[index1 + 1];
        int rowIndex1 = 0;
        iGCellStyle iGcellStyle = (iGCellStyle) null;
        if (mergedCellStyles != null)
        {
          int index2 = index1 < mergedCellStyles.Length ? index1 : mergedCellStyles.Length - 1;
          iGcellStyle = mergedCellStyles[index2];
        }
        for (int rowIndex2 = 0; rowIndex2 <= this.fRowCount; ++rowIndex2)
        {
          bool flag1 = false;
          bool flag2 = false;
          if (rowIndex2 == 0)
            flag2 = true;
          else if (rowIndex2 == this.fRowCount)
          {
            flag1 = true;
          }
          else
          {
            for (int index2 = index1; index2 >= 0; --index2)
            {
              if (!object.Equals(this.GetCellDataInternal(rowIndex2, colIndices[index2] + 1).Value, objArray[index2]))
              {
                flag1 = true;
                flag2 = true;
                break;
              }
            }
          }
          if (flag1)
          {
            int num = rowIndex2 - rowIndex1;
            int colIndex = colIndices[index1] + 1;
            if (num > 1)
              this.SetCellSpanRowsCore(rowIndex1, colIndex, num);
            if (iGcellStyle != null)
              this.SetCellStyleInternal(rowIndex1, colIndex, iGcellStyle);
            rowIndex1 = rowIndex2;
          }
          if (flag2)
          {
            for (int index2 = 0; index2 <= index1; ++index2)
              objArray[index2] = this.GetCellDataInternal(rowIndex2, colIndices[index2] + 1).Value;
          }
        }
      }
      this.EndUpdate();
    }

    /// <summary>Removes vertical merging from all merged cells in the column with the specified numeric index.</summary>
    /// <param name="colIndex">The numeric index of the column to remove merging from cells in.</param>
    public void UnmergeCellsInCols(int colIndex)
    {
      this.UnmergeCellsInCols(new int[1]{ colIndex }, false);
    }

    /// <summary>Removes vertical merging from all merged cells in the column with the specified numeric index and optionally clears the references to cell styles in the processed cells.</summary>
    /// <param name="colIndex">The numeric index of the column to remove merging from cells in.</param>
    /// <param name="clearCellStyles">A Boolean value that indicates whether the method should clear the references to cell styles in the processed cells.</param>
    public void UnmergeCellsInCols(int colIndex, bool clearCellStyles)
    {
      this.UnmergeCellsInCols(new int[1]{ colIndex }, (clearCellStyles ? 1 : 0) != 0);
    }

    /// <summary>Removes vertical merging from all merged cells in the column with the specified string key.</summary>
    /// <param name="colKey">The string key of the column to unmerge cells in.</param>
    public void UnmergeCellsInCols(string colKey)
    {
      this.UnmergeCellsInCols(new string[1]{ colKey }, false);
    }

    /// <summary>Removes vertical merging from all merged cells in the column with the specified string key and optionally clears the references to cell styles in the processed cells.</summary>
    /// <param name="colKey">The string key of the column to unmerge cells in.</param>
    /// <param name="clearCellStyles">A Boolean value that indicates whether the method should clear the references to cell styles in the processed cells.</param>
    public void UnmergeCellsInCols(string colKey, bool clearCellStyles)
    {
      this.UnmergeCellsInCols(new string[1]{ colKey }, (clearCellStyles ? 1 : 0) != 0);
    }

    /// <summary>Removes vertical merging from all merged cells in the columns with the specified numeric indices.</summary>
    /// <param name="colIndices">An array of <see cref="T:System.Int32" /> values that specify the numeric column indices to unmerge cells in.</param>
    public void UnmergeCellsInCols(int[] colIndices)
    {
      this.UnmergeCellsInCols(colIndices, false);
    }

    /// <summary>Removes vertical merging from all merged cells in the columns with the specified string keys.</summary>
    /// <param name="colKeys">An array of string values that specify the string column keys to unmerge cells in.</param>
    public void UnmergeCellsInCols(string[] colKeys)
    {
      this.UnmergeCellsInCols(colKeys, false);
    }

    /// <summary>Removes vertical merging from all merged cells in the columns with the specified string keys and optionally clears the references to cell styles in the processed cells.</summary>
    /// <param name="colKeys">An array of string values that specify the string column keys to unmerge cells in.</param>
    /// <param name="clearCellStyles">A Boolean value that indicates whether the method should clear the references to cell styles in the processed cells.</param>
    public void UnmergeCellsInCols(string[] colKeys, bool clearCellStyles)
    {
      int[] colIndices = new int[colKeys.Length];
      for (int index = 0; index < colKeys.Length; ++index)
        colIndices[index] = this.ColKeyToIndex(colKeys[index], true) - 1;
      this.UnmergeCellsInCols(colIndices, clearCellStyles);
    }

    /// <summary>Removes vertical merging from all merged cells in the columns with the specified numeric indices and optionally clears the references to cell styles in the processed cells.</summary>
    /// <param name="colIndices">An array of <see cref="T:System.Int32" /> values that specify the numeric column indices to unmerge cells in.</param>
    /// <param name="clearCellStyles">A Boolean value that indicates whether the method should clear the references to cell styles in the processed cells.</param>
    public void UnmergeCellsInCols(int[] colIndices, bool clearCellStyles)
    {
      if (colIndices.Length == 0)
        throw new ArgumentException("Column array must contain values", "columns");
      for (int index = 0; index < colIndices.Length; ++index)
        this.CheckColIndex(colIndices[index]);
      if (this.fRowCount < 2)
        return;
      this.BeginUpdate();
      for (int index = 0; index < colIndices.Length; ++index)
      {
        int colIndex = colIndices[index] + 1;
        int rowIndex = 0;
        while (rowIndex < this.fRowCount)
        {
          iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
          bool flag = false;
          if (cellDataInternal.SpanRows > 1)
          {
            flag = true;
            this.SetCellSpanRowsCore(rowIndex, colIndex, 1);
          }
          if (clearCellStyles)
            this.SetCellStyle(rowIndex, colIndex, (iGCellStyle) null, false);
          if (flag)
            rowIndex += cellDataInternal.SpanRows;
          else
            ++rowIndex;
        }
      }
      this.EndUpdate();
    }

    /// <summary>Removes merging from all merged cells.</summary>
    public void UnmergeAllCells()
    {
      this.UnmergeAllCells(false);
    }

    /// <summary>Removes merging from all merged cells and optionally clears the references to cell styles in merged cells.</summary>
    /// <param name="clearCellStyles">A Boolean value that indicates whether the method should clear the references to cell styles in merged cells.</param>
    public void UnmergeAllCells(bool clearCellStyles)
    {
      if (this.fMergedCellCountAll == 0)
        return;
      this.BeginUpdate();
      for (int index1 = 0; index1 < this.fMergedCells.Count; ++index1)
      {
        iGCellNavigator iGcellNavigator = this.fMergedCells.GetItem(index1);
        iGCellData cellDataInternal = this.GetCellDataInternal(iGcellNavigator.RowIndex, iGcellNavigator.ColIndex);
        int colOrder = this.GetColOrder(iGcellNavigator.ColIndex);
        for (int index2 = 0; index2 < cellDataInternal.SpanRows; ++index2)
        {
          int rowIndex = iGcellNavigator.RowIndex + index2;
          for (int index3 = 0; index3 < cellDataInternal.SpanCols; ++index3)
          {
            int colIndex = this.fColIdxFromOrd[colOrder + index3];
            this.SetCellSpanColsRowsInternalNoRedraw(rowIndex, colIndex, 1, 1);
            if (clearCellStyles)
              this.SetCellStyle(rowIndex, colIndex, (iGCellStyle) null, false);
          }
        }
      }
      this.fMergedCells.Clear();
      this.fMergedCellCountAll = 0;
      this.fMergedCellCountHorz = 0;
      this.fMergedCellCountVert = 0;
      this.EndUpdate();
    }

    /// <summary>Occurs when cell merging removal is required to complete an interactive operation.</summary>
    [Category("Cell Merging")]
    [Description("Occurs when iGrid must unmerge cells to complete the user action.")]
    public event iGUnmergeCellsRequiredEventHandler UnmergeCellsRequired;

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.UnmergeCellsRequired" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGUnmergeCellsRequiredEventArgs" /> that contains the event data.</param>
    protected virtual void OnUnmergeCellsRequired(iGUnmergeCellsRequiredEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.UnmergeCellsRequired == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.UnmergeCellsRequired((object) this, e);
    }

    private int[] Span__GetMapArray(iGGridSection gridSection)
    {
      if (gridSection == iGGridSection.Header)
        return this.fHeaderSpanMap;
      if (gridSection == iGGridSection.Footer)
        return this.fFooterSpanMap;
      throw new Exception();
    }

    private int Span__GetSectionRowCount(iGGridSection gridSection)
    {
      if (gridSection == iGGridSection.Header)
        return this.fHeaderRowCount;
      if (gridSection == iGGridSection.Footer)
        return this.fFooterRowCount;
      throw new Exception();
    }

    private iGrid.Span__SectionRowInfo Span__GetSectionRowInfo(iGGridSection gridSection, int rowIndex)
    {
      iGrid.Span__SectionRowInfo spanSectionRowInfo = new iGrid.Span__SectionRowInfo();
      if (gridSection != iGGridSection.Header)
      {
        if (gridSection == iGGridSection.Footer)
        {
          iGFooterRowData fFooterRow = this.fFooterRows[rowIndex];
          spanSectionRowInfo.Visible = fFooterRow.Visible;
          spanSectionRowInfo.Height = fFooterRow.Height;
        }
      }
      else
      {
        iGHdrRowData fHeaderRow = this.fHeaderRows[rowIndex];
        spanSectionRowInfo.Visible = fHeaderRow.Visible;
        spanSectionRowInfo.Height = fHeaderRow.Height;
      }
      return spanSectionRowInfo;
    }

    private void Span__CheckRowIndex(iGGridSection gridSection, int rowIndex)
    {
      if (gridSection != iGGridSection.Header)
      {
        if (gridSection != iGGridSection.Footer)
          return;
        this.CheckFooterRowIndex(rowIndex);
      }
      else
        this.CheckHeaderRowIndex(rowIndex);
    }

    private void Span__InvalidateSectionIfRedraw(iGGridSection gridSection)
    {
      if (gridSection != iGGridSection.Header)
      {
        if (gridSection != iGGridSection.Footer)
          return;
        this.InvalidateFooterIfRedraw();
      }
      else
        this.InvalidateHeaderIfRedraw();
    }

    internal int Span__PropertySpanRowsGet(iGGridSection gridSection, int rowIndex, int colIndex)
    {
      this.CheckColIndex(colIndex);
      this.Span__CheckRowIndex(gridSection, rowIndex);
      int colOrder = this.GetColOrder(colIndex);
      if (!this.Span__IsRoot(gridSection, rowIndex, colOrder))
        return 1;
      return this.Span__CalcSpanRowsFarInternal(gridSection, rowIndex, colOrder);
    }

    internal int Span__PropertySpanColsGet(iGGridSection gridSection, int rowIndex, int colIndex)
    {
      this.CheckColIndex(colIndex);
      this.Span__CheckRowIndex(gridSection, rowIndex);
      int colOrder = this.GetColOrder(colIndex);
      if (!this.Span__IsRoot(gridSection, rowIndex, colOrder))
        return 1;
      return this.Span__CalcSpanColsFarInternal(gridSection, rowIndex, colOrder);
    }

    internal void Span__PropertySpanRowsSet(iGGridSection gridSection, int rowIndex, int colIndex, int spanRows)
    {
      this.CheckColIndex(colIndex);
      int colOrder = this.GetColOrder(colIndex);
      if (gridSection != iGGridSection.Header)
      {
        if (gridSection == iGGridSection.Footer)
          this.CheckFooterRowIndexAndCount(rowIndex, spanRows);
      }
      else
        this.CheckHeaderRowIndexAndCount(rowIndex, spanRows);
      if (!this.Span__IsRoot(gridSection, rowIndex, colOrder))
        throw new ArgumentException("Merged cells cannot overlap");
      int oldSpanRows = this.Span__CalcSpanRowsFarInternal(gridSection, rowIndex, colOrder);
      int num = this.Span__CalcSpanColsFarInternal(gridSection, rowIndex, colOrder);
      if (this.IsExtraCol(colOrder))
        throw new ArgumentException("Row text column cannot be spanned");
      if (oldSpanRows < spanRows && !this.Span__AreCellsStandalone(gridSection, rowIndex, colOrder, spanRows, num))
        throw new ArgumentException("Merged cells cannot overlap");
      this.Span__SplitRows(gridSection, rowIndex, colOrder, spanRows, oldSpanRows, num);
      this.Span__MergeRows(gridSection, rowIndex, colOrder, spanRows, oldSpanRows, num);
      this.Span__InvalidateSectionIfRedraw(gridSection);
    }

    internal void Span__PropertySpanColsSet(iGGridSection gridSection, int rowIndex, int colIndex, int spanCols)
    {
      this.CheckColIndex(colIndex);
      int colOrder = this.GetColOrder(colIndex);
      this.CheckColIndexAndCount(colOrder, spanCols, nameof (colIndex));
      this.Span__CheckRowIndex(gridSection, rowIndex);
      if (this.IsExtraCol(colOrder))
        throw new ArgumentException("Row text column cannot be spanned");
      if (!this.Span__IsRoot(gridSection, rowIndex, colOrder))
        throw new ArgumentException("Merged cells cannot overlap");
      int num = this.Span__CalcSpanRowsFarInternal(gridSection, rowIndex, colOrder);
      int oldSpanCols = this.Span__CalcSpanColsFarInternal(gridSection, rowIndex, colOrder);
      if (oldSpanCols < spanCols)
      {
        if (colOrder < this.fFrozenColCount && colOrder + spanCols > this.fFrozenColCount)
          throw new ArgumentException("Frozen area edge cannot break merged cells");
        if (!this.Span__AreCellsStandalone(gridSection, rowIndex, colOrder, num, spanCols))
          throw new ArgumentException("Merged cells cannot overlap");
      }
      this.Span__SplitCols(gridSection, rowIndex, colOrder, spanCols, num, oldSpanCols);
      this.Span__MergeCols(gridSection, rowIndex, colOrder, spanCols, num, oldSpanCols);
      this.Span__InvalidateSectionIfRedraw(gridSection);
    }

    internal int Span__GetSpanRowsNear(iGGridSection gridSection, int rowIndex, int colIndex)
    {
      this.CheckColIndex(colIndex);
      this.Span__CheckRowIndex(gridSection, rowIndex);
      return this.Span__CalcSpanRowsNearInternal(gridSection, rowIndex, this.GetColOrder(colIndex));
    }

    internal int Span__GetSpanRowsFar(iGGridSection gridSection, int rowIndex, int colIndex)
    {
      this.CheckColIndex(colIndex);
      this.Span__CheckRowIndex(gridSection, rowIndex);
      return this.Span__CalcSpanRowsFarInternal(gridSection, rowIndex, this.GetColOrder(colIndex));
    }

    internal int Span__GetSpanColsNear(iGGridSection gridSection, int rowIndex, int colIndex)
    {
      this.CheckColIndex(colIndex);
      this.Span__CheckRowIndex(gridSection, rowIndex);
      int colOrder = this.GetColOrder(colIndex);
      return this.Span__CalcSpanColsNearInternal(gridSection, rowIndex, colOrder);
    }

    internal int Span__GetSpanColsFar(iGGridSection gridSection, int rowIndex, int colIndex)
    {
      this.CheckColIndex(colIndex);
      this.Span__CheckRowIndex(gridSection, rowIndex);
      int colOrder = this.GetColOrder(colIndex);
      return this.Span__CalcSpanColsFarInternal(gridSection, rowIndex, colOrder);
    }

    private void Span__SplitRows(iGGridSection gridSection, int rowIndex, int colOrder, int spanRows, int oldSpanRows, int oldSpanCols)
    {
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int num1 = mapArray[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder]];
      for (int index1 = rowIndex + spanRows; index1 < rowIndex + oldSpanRows; ++index1)
      {
        int num2 = index1 * this.fColCount;
        for (int index2 = colOrder + oldSpanCols - 1; index2 >= colOrder; --index2)
        {
          int index3 = num2 + this.fColIdxFromOrd[index2];
          mapArray[index3] = index3;
        }
      }
    }

    private void Span__SplitCols(iGGridSection gridSection, int rowIndex, int colOrder, int spanCols, int oldSpanRows, int oldSpanCols)
    {
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int num1 = mapArray[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder]];
      for (int index1 = rowIndex + oldSpanRows - 1; index1 >= rowIndex; --index1)
      {
        int num2 = index1 * this.fColCount;
        for (int index2 = colOrder + spanCols; index2 < colOrder + oldSpanCols; ++index2)
        {
          int index3 = num2 + this.fColIdxFromOrd[index2];
          mapArray[index3] = index3;
        }
      }
    }

    private void Span__MergeRows(iGGridSection gridSection, int rowIndex, int colOrder, int spanRows, int oldSpanRows, int oldSpanCols)
    {
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int num1 = mapArray[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder]];
      for (int index1 = rowIndex + oldSpanRows; index1 < rowIndex + spanRows; ++index1)
      {
        int num2 = index1 * this.fColCount;
        for (int index2 = colOrder + oldSpanCols - 1; index2 >= colOrder; --index2)
        {
          int index3 = num2 + this.fColIdxFromOrd[index2];
          mapArray[index3] = num1;
        }
      }
    }

    private void Span__MergeCols(iGGridSection gridSection, int rowIndex, int colOrder, int spanCols, int oldSpanRows, int oldSpanCols)
    {
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int num1 = rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder];
      for (int index1 = rowIndex + oldSpanRows - 1; index1 >= rowIndex; --index1)
      {
        int num2 = index1 * this.fColCount;
        for (int index2 = colOrder + oldSpanCols; index2 < colOrder + spanCols; ++index2)
        {
          int index3 = num2 + this.fColIdxFromOrd[index2];
          mapArray[index3] = num1;
        }
      }
    }

    private int Span__CalcSpanRowsFarInternal(iGGridSection gridSection, int rowIndex, int colOrder)
    {
      int num1 = this.fColIdxFromOrd[colOrder];
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int sectionRowCount = this.Span__GetSectionRowCount(gridSection);
      int num2 = mapArray[rowIndex * this.fColCount + num1];
      int num3 = 1;
      for (int index = rowIndex + 1; index < sectionRowCount && mapArray[index * this.fColCount + num1] == num2; ++index)
        ++num3;
      return num3;
    }

    private int Span__CalcSpanRowsNearInternal(iGGridSection gridSection, int rowIndex, int colOrder)
    {
      int num1 = this.fColIdxFromOrd[colOrder];
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int num2 = mapArray[rowIndex * this.fColCount + num1];
      int num3 = 1;
      for (int index = rowIndex - 1; index >= 0 && mapArray[index * this.fColCount + num1] == num2; --index)
        ++num3;
      return num3;
    }

    private int Span__CalcSpanColsNearInternal(iGGridSection gridSection, int rowIndex, int colOrder)
    {
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int num1 = mapArray[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder]];
      int num2 = 1;
      for (int index = colOrder - 1; index >= 0 && mapArray[rowIndex * this.fColCount + this.fColIdxFromOrd[index]] == num1; --index)
        ++num2;
      return num2;
    }

    private int Span__CalcSpanColsFarInternal(iGGridSection gridSection, int rowIndex, int colOrder)
    {
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int num1 = mapArray[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder]];
      int num2 = 1;
      for (int index = colOrder + 1; index < this.fColCount && mapArray[rowIndex * this.fColCount + this.fColIdxFromOrd[index]] == num1; ++index)
        ++num2;
      return num2;
    }

    private int Span__CalcSpanColsInternal(iGGridSection gridSection, int rowIndex, int colOrder)
    {
      return this.Span__CalcSpanColsNearInternal(gridSection, rowIndex, colOrder) + this.Span__CalcSpanColsFarInternal(gridSection, rowIndex, colOrder) - 1;
    }

    private bool Span__IsRoot(iGGridSection gridSection, int rowIndex, int colOrder)
    {
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int num1 = this.fColIdxFromOrd[colOrder];
      int index = rowIndex * this.fColCount + num1;
      int num2 = mapArray[index];
      return num2 % this.fColCount == num1 && num2 / this.fColCount == rowIndex;
    }

    private bool Span__AreCellsStandalone(iGGridSection gridSection, int rowIndex, int colOrder, int rowCount, int colCount)
    {
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int sectionRowCount = this.Span__GetSectionRowCount(gridSection);
      if (rowIndex > 0)
      {
        int num1 = rowIndex * this.fColCount;
        int num2 = num1 - this.fColCount;
        for (int index = colOrder + colCount - 1; index >= colOrder; --index)
        {
          int num3 = this.fColIdxFromOrd[index];
          if (mapArray[num2 + num3] == mapArray[num1 + num3])
            return false;
        }
      }
      int num4 = rowIndex + rowCount - 1;
      if (num4 < sectionRowCount - 1)
      {
        int num1 = num4 * this.fColCount;
        int num2 = num1 + this.fColCount;
        for (int index = colOrder + colCount - 1; index >= colOrder; --index)
        {
          int num3 = this.fColIdxFromOrd[index];
          if (mapArray[num2 + num3] == mapArray[num1 + num3])
            return false;
        }
      }
      if (colOrder > 0)
      {
        int num1 = this.fColIdxFromOrd[colOrder];
        int num2 = this.fColIdxFromOrd[colOrder - 1];
        for (int index = rowIndex + rowCount - 1; index >= rowIndex; --index)
        {
          int num3 = index * this.fColCount;
          if (mapArray[num3 + num2] == mapArray[num3 + num1])
            return false;
        }
      }
      int index1 = colOrder + colCount - 1;
      if (index1 < this.fColCount - 1)
      {
        int num1 = this.fColIdxFromOrd[index1];
        int num2 = this.fColIdxFromOrd[index1 + 1];
        for (int index2 = rowIndex + rowCount - 1; index2 >= rowIndex; --index2)
        {
          int num3 = index2 * this.fColCount;
          if (mapArray[num3 + num2] == mapArray[num3 + num1])
            return false;
        }
      }
      return true;
    }

    private void Span__GetMergedCellBounds(iGGridSection gridSection, ref int rowIndex, out int rowCount, ref int colOrder, out int colCount, ref int x, ref int y, ref int width, ref int height, bool rightToLeft)
    {
      colCount = 1;
      rowCount = 1;
      this.Span__GetMergedCellBoundsHorz(gridSection, rowIndex, ref colOrder, ref colCount, ref x, ref width, rightToLeft);
      this.Span__GetMergedCellBoundsVert(gridSection, ref rowIndex, ref rowCount, colOrder, ref y, ref height);
    }

    private void Span__GetMergedCellBoundsHorz(iGGridSection gridSection, int rowIndex, ref int colOrder, ref int colCount, ref int x, ref int width, bool rightToLeft)
    {
      int num1 = colOrder;
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int num2 = rowIndex * this.fColCount;
      int num3 = mapArray[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder]];
      int index1 = colOrder - 1;
      while (index1 >= 0)
      {
        int colIndex = this.fColIdxFromOrd[index1];
        if (mapArray[num2 + colIndex] == num3)
        {
          iGColData fColData = this.fColDatas[colIndex];
          if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
          {
            int width1 = fColData.Width;
            if (!rightToLeft)
              x = x - width1;
            width = width + width1;
          }
          colCount = colCount + 1;
          --index1;
          colOrder = colOrder - 1;
        }
        else
          break;
      }
      for (int index2 = num1 + 1; index2 < this.fColCount; ++index2)
      {
        int colIndex = this.fColIdxFromOrd[index2];
        if (mapArray[num2 + colIndex] == num3)
        {
          iGColData fColData = this.fColDatas[colIndex];
          if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
          {
            int width1 = fColData.Width;
            if (rightToLeft)
              x = x - width1;
            width = width + width1;
          }
          colCount = colCount + 1;
        }
        else
          break;
      }
      if (colOrder >= num1 || !this.Span__IsCellInFirstVisibleCol(gridSection, rowIndex, colOrder))
        return;
      int levelsExtraWidth = this.GetGroupLevelsExtraWidth();
      if (rightToLeft)
      {
        width = width + levelsExtraWidth;
      }
      else
      {
        x = x - levelsExtraWidth;
        width = width + levelsExtraWidth;
      }
    }

    private void Span__GetMergedCellBoundsVert(iGGridSection gridSection, ref int rowIndex, ref int rowCount, int colOrder, ref int y, ref int height)
    {
      int num1 = rowIndex;
      int[] mapArray = this.Span__GetMapArray(gridSection);
      int sectionRowCount = this.Span__GetSectionRowCount(gridSection);
      int num2 = mapArray[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder]];
      int num3 = this.fColIdxFromOrd[colOrder];
      for (int index = rowIndex - 1; index >= 0 && mapArray[index * this.fColCount + num3] == num2; --index)
      {
        if (gridSection != iGGridSection.Header)
        {
          if (gridSection == iGGridSection.Footer)
          {
            iGFooterRowData fFooterRow = this.fFooterRows[index];
            if (fFooterRow.Visible)
            {
              y = y - fFooterRow.Height;
              height = height + fFooterRow.Height;
            }
          }
        }
        else
        {
          iGHdrRowData fHeaderRow = this.fHeaderRows[index];
          if (fHeaderRow.Visible)
            height = height + fHeaderRow.Height;
        }
        rowCount = rowCount + 1;
        rowIndex = rowIndex - 1;
      }
      for (int index = num1 + 1; index < sectionRowCount && mapArray[index * this.fColCount + num3] == num2; ++index)
      {
        if (gridSection != iGGridSection.Header)
        {
          if (gridSection == iGGridSection.Footer)
          {
            iGFooterRowData fFooterRow = this.fFooterRows[index];
            if (fFooterRow.Visible)
              height = height + fFooterRow.Height;
          }
        }
        else
        {
          iGHdrRowData fHeaderRow = this.fHeaderRows[index];
          if (fHeaderRow.Visible)
          {
            y = y - fHeaderRow.Height;
            height = height + fHeaderRow.Height;
          }
        }
        rowCount = rowCount + 1;
      }
    }

    private bool Span__IsCellInFirstVisibleCol(iGGridSection gridSection, int rowIndex, int colOrder)
    {
      int num1 = this.Span__CalcSpanColsNearInternal(gridSection, rowIndex, colOrder);
      int num2 = this.Span__CalcSpanColsFarInternal(gridSection, rowIndex, colOrder);
      int firstVisibleColOrder = this.GetFirstVisibleColOrder();
      if (colOrder - num1 + 1 <= firstVisibleColOrder)
        return firstVisibleColOrder <= colOrder + num2 - 1;
      return false;
    }

    [DllImport("user32")]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool SetGestureConfig(IntPtr hWnd, int dwReserved, int cIDs, ref iGrid.GESTURECONFIG pGestureConfig, int cbSize);

    [DllImport("user32")]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool GetGestureInfo(IntPtr hGestureInfo, ref iGrid.GESTUREINFO pGestureInfo);

    private bool EnableGestures(ref Message m)
    {
      iGrid.GESTURENOTIFYSTRUCT structure = (iGrid.GESTURENOTIFYSTRUCT) Marshal.PtrToStructure(m.LParam, typeof (iGrid.GESTURENOTIFYSTRUCT));
      Point client = this.PointToClient(new Point((int) structure.ptsLocation.x, (int) structure.ptsLocation.y));
      iGrid.GESTURECONFIG pGestureConfig = new iGrid.GESTURECONFIG();
      int cbSize = Marshal.SizeOf((object) pGestureConfig);
      pGestureConfig.dwID = 4;
      int num = 31;
      if (this.IsPointOverCellsArea(client.X, client.Y))
      {
        pGestureConfig.dwWant = num;
        pGestureConfig.dwBlock = 0;
      }
      else
      {
        pGestureConfig.dwWant = 0;
        pGestureConfig.dwBlock = num;
      }
      return iGrid.SetGestureConfig(this.Handle, 0, 1, ref pGestureConfig, cbSize);
    }

    private bool DecodeGesture(ref Message m)
    {
      iGrid.GESTUREINFO pGestureInfo;
      try
      {
        pGestureInfo = new iGrid.GESTUREINFO();
      }
      catch
      {
        return false;
      }
      pGestureInfo.cbSize = Marshal.SizeOf((object) pGestureInfo);
      if (!iGrid.GetGestureInfo(m.LParam, ref pGestureInfo))
        return false;
      switch (pGestureInfo.dwID)
      {
        case 4:
          if (pGestureInfo.dwFlags == 1)
          {
            this._ptFirst.X = (int) pGestureInfo.ptsLocation.x;
            this._ptFirst.Y = (int) pGestureInfo.ptsLocation.y;
            this._ptFirst = this.PointToClient(this._ptFirst);
            break;
          }
          this._ptSecond.X = (int) pGestureInfo.ptsLocation.x;
          this._ptSecond.Y = (int) pGestureInfo.ptsLocation.y;
          this._ptSecond = this.PointToClient(this._ptSecond);
          if (this.CanScrollVert())
            this.SetVScrollBarValue(this.fVScrollBar.Value - (this._ptSecond.Y - this._ptFirst.Y), false);
          if (this.CanScrollHorz())
            this.SetHScrollBarValue(this.fHScrollBar.Value - (this._ptSecond.X - this._ptFirst.X), false);
          this._ptFirst = this._ptSecond;
          break;
      }
      return true;
    }

    /// <summary>Populates the grid with the data from a data source. The current column set is removed.</summary>
    /// <param name="dataSource">A <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.DataView" />, <see cref="T:System.Data.IDbCommand" />, or <see cref="T:System.Data.IDataReader" /> object to populate the grid with.</param>
    public void FillWithData(object dataSource)
    {
      if (dataSource is DataTable)
        this.FillWithData_DataTable((DataTable) dataSource, false, (string) null, false, (string) null, false, false, 0, int.MaxValue);
      else if (dataSource is DataView)
        this.FillWithData_DataView((DataView) dataSource, false, (string) null, false, (string) null, false, false, 0, int.MaxValue);
      else if (dataSource is IDataReader)
      {
        this.FillWithData_DataReader((IDataReader) dataSource, false, (string) null, false, (string) null, false, false, 0, int.MaxValue);
      }
      else
      {
        if (!(dataSource is IDbCommand))
          throw new ArgumentException("The specified data source isn't supported", nameof (dataSource));
        this.FillWithData_DbCommand((IDbCommand) dataSource, false, (string) null, false, (string) null, false, false, 0, int.MaxValue);
      }
    }

    /// <summary>Populates the grid with the data from a data source. The current column set is optionally removed or used to map the data to them.</summary>
    /// <param name="dataSource">A <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.DataView" />, <see cref="T:System.Data.IDbCommand" />, or <see cref="T:System.Data.IDataReader" /> object to populate the grid with.</param>
    /// <param name="useCurColSet">True to map the data source columns to the existing columns, False to remove the old columns and load all the columns from the data source.</param>
    public void FillWithData(object dataSource, bool useCurColSet)
    {
      if (dataSource is DataTable)
        this.FillWithData_DataTable((DataTable) dataSource, useCurColSet, (string) null, false, (string) null, false, false, 0, int.MaxValue);
      else if (dataSource is DataView)
        this.FillWithData_DataView((DataView) dataSource, useCurColSet, (string) null, false, (string) null, false, false, 0, int.MaxValue);
      else if (dataSource is IDataReader)
      {
        this.FillWithData_DataReader((IDataReader) dataSource, useCurColSet, (string) null, false, (string) null, false, false, 0, int.MaxValue);
      }
      else
      {
        if (!(dataSource is IDbCommand))
          throw new ArgumentException("The specified data source isn't supported", nameof (dataSource));
        this.FillWithData_DbCommand((IDbCommand) dataSource, useCurColSet, (string) null, false, (string) null, false, false, 0, int.MaxValue);
      }
    }

    /// <summary>Populates the grid with the data from a data source and allows you to specify such additional options as using the current column set, row key and row level columns.</summary>
    /// <param name="dataSource">A <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.DataView" />, <see cref="T:System.Data.IDbCommand" />, or <see cref="T:System.Data.IDataReader" /> object to populate the grid with.</param>
    /// <param name="useCurColSet">True to map the data source columns to the existing columns, False to remove the old columns and load all the columns from the data source.</param>
    /// <param name="rowKeyCol">The name of the data source column used as iGrid's row keys.</param>
    /// <param name="rowLevelCol">The name of the data source column used as iGrid's row levels.</param>
    public void FillWithData(object dataSource, bool useCurColSet, string rowKeyCol, string rowLevelCol)
    {
      if (dataSource is DataTable)
        this.FillWithData_DataTable((DataTable) dataSource, useCurColSet, rowKeyCol, false, rowLevelCol, false, true, 0, int.MaxValue);
      else if (dataSource is DataView)
        this.FillWithData_DataView((DataView) dataSource, useCurColSet, rowKeyCol, false, rowLevelCol, false, true, 0, int.MaxValue);
      else if (dataSource is IDataReader)
      {
        this.FillWithData_DataReader((IDataReader) dataSource, useCurColSet, rowKeyCol, false, rowLevelCol, false, true, 0, int.MaxValue);
      }
      else
      {
        if (!(dataSource is IDbCommand))
          throw new ArgumentException("The specified data source isn't supported", nameof (dataSource));
        this.FillWithData_DbCommand((IDbCommand) dataSource, useCurColSet, rowKeyCol, false, rowLevelCol, false, true, 0, int.MaxValue);
      }
    }

    /// <summary>Populates the grid with the data from a data source and allows you to specify the following options: using the current column set, row key/row level columns and their visibility, automatic adding of tree buttons.</summary>
    /// <param name="dataSource">A <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.DataView" />, <see cref="T:System.Data.IDbCommand" />, or <see cref="T:System.Data.IDataReader" /> object to populate the grid with.</param>
    /// <param name="useCurColSet">True to map the data source columns to the existing columns, False to remove the old columns and load all the columns from the data source.</param>
    /// <param name="rowKeyCol">The name of the data source column used as iGrid's row keys.</param>
    /// <param name="addRowKeyCol">Specifies whether to add the row key column as iGrid column.</param>
    /// <param name="rowLevelCol">The name of the data source column used as iGrid's row levels.</param>
    /// <param name="addRowLevelCol">Specifies whether to add the row level column as iGrid column.</param>
    /// <param name="addTreeButtons">Specifies whether the tree buttons will be displayed in the rows automatically if the row level column is specified.</param>
    public void FillWithData(object dataSource, bool useCurColSet, string rowKeyCol, bool addRowKeyCol, string rowLevelCol, bool addRowLevelCol, bool addTreeButtons)
    {
      if (dataSource is DataTable)
        this.FillWithData_DataTable((DataTable) dataSource, useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, 0, int.MaxValue);
      else if (dataSource is DataView)
        this.FillWithData_DataView((DataView) dataSource, useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, 0, int.MaxValue);
      else if (dataSource is IDataReader)
      {
        this.FillWithData_DataReader((IDataReader) dataSource, useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, 0, int.MaxValue);
      }
      else
      {
        if (!(dataSource is IDbCommand))
          throw new ArgumentException("The specified data source isn't supported", nameof (dataSource));
        this.FillWithData_DbCommand((IDbCommand) dataSource, useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, 0, int.MaxValue);
      }
    }

    /// <summary>Populates the grid with the data from a data source and allows you to specify the following options: using the current column set, row key/row level columns and their visibility, automatic adding of tree buttons, the start row and number of rows to add.</summary>
    /// <param name="dataSource">A <see cref="T:System.Data.DataTable" />, <see cref="T:System.Data.DataView" />, <see cref="T:System.Data.IDbCommand" />, or <see cref="T:System.Data.IDataReader" /> object to populate the grid with.</param>
    /// <param name="useCurColSet">True to map the data source columns to the existing columns, False to remove the old columns and load all the columns from the data source.</param>
    /// <param name="rowKeyCol">The name of the data source column used as iGrid's row keys.</param>
    /// <param name="addRowKeyCol">Specifies whether to add the row key column as iGrid column.</param>
    /// <param name="rowLevelCol">The name of the data source column used as iGrid's row levels.</param>
    /// <param name="addRowLevelCol">Specifies whether to add the row level column as iGrid column.</param>
    /// <param name="addTreeButtons">Specifies whether the tree buttons will be displayed in the rows automatically if the row level column is specified.</param>
    /// <param name="dataStartRow">The start row in the data source to populate the grid from.</param>
    /// <param name="dataRowCount">The number of rows of the data source to populated the grid.</param>
    public void FillWithData(object dataSource, bool useCurColSet, string rowKeyCol, bool addRowKeyCol, string rowLevelCol, bool addRowLevelCol, bool addTreeButtons, int dataStartRow, int dataRowCount)
    {
      if (dataSource is DataTable)
        this.FillWithData_DataTable((DataTable) dataSource, useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, dataStartRow, dataRowCount);
      else if (dataSource is DataView)
        this.FillWithData_DataView((DataView) dataSource, useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, dataStartRow, dataRowCount);
      else if (dataSource is IDataReader)
      {
        this.FillWithData_DataReader((IDataReader) dataSource, useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, dataStartRow, dataRowCount);
      }
      else
      {
        if (!(dataSource is IDbCommand))
          throw new ArgumentException("The specified data source isn't supported", nameof (dataSource));
        this.FillWithData_DbCommand((IDbCommand) dataSource, useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, dataStartRow, dataRowCount);
      }
    }

    private void FillWithData_SetColCount(int colCount)
    {
      this.Cols.Clear();
      if (colCount <= 0)
        return;
      this.Cols.AddRange(colCount);
    }

    private void FillWithData_SetRowCount(int rowCount)
    {
      this.Rows.Clear();
      if (rowCount <= 0)
        return;
      this.Rows.AddRange(rowCount);
    }

    private void FillWithData_SetColumnParams(iGCol col, Type type, string name, string caption, bool @readonly, object defautlValue)
    {
      col.Text = (object) caption;
      col.Key = name;
      if (type == typeof (bool))
      {
        col.CellStyle.Type = iGCellType.Check;
        col.CellStyle.TextAlign = iGContentAlignment.TopLeft;
        col.CellStyle.ImageAlign = iGContentAlignment.TopCenter;
      }
      else if (type == typeof (byte) || type == typeof (byte) || (type == typeof (Decimal) || type == typeof (double)) || (type == typeof (int) || type == typeof (short) || (type == typeof (long) || type == typeof (sbyte))) || (type == typeof (float) || type == typeof (uint) || (type == typeof (ushort) || type == typeof (ulong))))
      {
        col.CellStyle.TextAlign = iGContentAlignment.TopRight;
        col.CellStyle.ImageAlign = iGContentAlignment.TopLeft;
      }
      else
      {
        col.CellStyle.TextAlign = iGContentAlignment.TopLeft;
        col.CellStyle.ImageAlign = iGContentAlignment.TopLeft;
      }
      col.CellStyle.ValueType = type;
      col.DefaultCellValue = defautlValue;
      if (@readonly)
        col.CellStyle.ReadOnly = iGBool.True;
      else
        col.CellStyle.ReadOnly = iGBool.False;
    }

    private void FillWithData_DataTable(DataTable dataTable, bool useCurColSet, string rowKeyCol, bool addRowKeyCol, string rowLevelCol, bool addRowLevelCol, bool addTreeButtons, int dataStartRow, int dataRowCount)
    {
      if (dataTable == null)
        throw new ArgumentNullException();
      this.FillWithData_DataView(new DataView(dataTable, (string) null, (string) null, DataViewRowState.CurrentRows), useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, dataStartRow, dataRowCount);
    }

    private void FillWithData_DataView(DataView dataView, bool useCurColSet, string rowKeyCol, bool addRowKeyCol, string rowLevelCol, bool addRowLevelCol, bool addTreeButtons, int dataStartRow, int dataRowCount)
    {
      DataTable table = dataView.Table;
      if (dataView == null)
        throw new ArgumentNullException();
      if (table == null)
        throw new ArgumentException();
      if (dataStartRow < 0)
        throw new ArgumentOutOfRangeException(nameof (dataStartRow));
      if (dataRowCount < 0)
        throw new ArgumentOutOfRangeException(nameof (dataRowCount));
      bool staySorted = this.StaySorted;
      this.BeginUpdate();
      this.StaySorted = false;
      try
      {
        int rowCount = Math.Min(dataView.Count - dataStartRow, dataRowCount);
        int count = table.Columns.Count;
        bool flag1 = false;
        int index1 = -1;
        bool flag2 = false;
        int index2 = -1;
        if (!string.IsNullOrEmpty(rowKeyCol))
        {
          flag1 = table.Columns.Contains(rowKeyCol);
          if (flag1)
            index1 = table.Columns[rowKeyCol].Ordinal;
        }
        if (!string.IsNullOrEmpty(rowLevelCol))
        {
          flag2 = table.Columns.Contains(rowLevelCol);
          if (flag2)
            index2 = table.Columns[rowLevelCol].Ordinal;
        }
        if (!useCurColSet)
        {
          bool flag3 = false;
          int num = -1;
          string key = this.RowTextCol.Key;
          if (!string.IsNullOrEmpty(key))
          {
            flag3 = table.Columns.Contains(key);
            if (flag3)
            {
              num = table.Columns[key].Ordinal;
              --count;
            }
          }
          if (flag1 && !addRowKeyCol)
            --count;
          if (flag2 && !addRowLevelCol)
            --count;
          this.FillWithData_SetColCount(count);
          for (int index3 = table.Columns.Count - 1; index3 >= 0; --index3)
          {
            if ((!flag1 || addRowKeyCol || index3 != index1) && (!flag2 || addRowLevelCol || index3 != index2))
            {
              DataColumn column = table.Columns[index3];
              int index4 = index3;
              if (flag3)
              {
                if (index3 > num)
                  --index4;
                else if (index3 == num)
                  index4 = -1;
              }
              if (flag1 && !addRowKeyCol && index3 > index1)
                --index4;
              if (flag2 && !addRowLevelCol && index3 > index2)
                --index4;
              this.FillWithData_SetColumnParams(this.Cols[index4], column.DataType, column.ColumnName, column.Caption, column.ReadOnly, column.DefaultValue);
            }
          }
        }
        this.FillWithData_SetRowCount(rowCount);
        int[] numArray = new int[table.Columns.Count];
        for (int index3 = table.Columns.Count - 1; index3 >= 0; --index3)
          numArray[index3] = this.ColKeyToIndex(table.Columns[index3].ColumnName, false);
        int num1 = 0;
        for (int rowIndex = 0; rowIndex < rowCount; ++rowIndex)
        {
          DataRow row = dataView[rowIndex + dataStartRow].Row;
          for (int index3 = table.Columns.Count - 1; index3 >= 0; --index3)
          {
            if (numArray[index3] >= 0)
              this.SetCellValue(rowIndex, numArray[index3], row[index3], false, true, false);
            if (flag1)
              this.SetRowKey(rowIndex, row[index1].ToString(), true);
            if (flag2)
            {
              int num2 = (int) row[index2];
              this.SetRowLevel(rowIndex, num2);
              if (addTreeButtons)
              {
                this.SetRowTreeButton(rowIndex, iGTreeButtonState.Hidden);
                if (rowIndex > 0 && num2 == num1 + 1)
                  this.SetRowTreeButton(rowIndex - 1, iGTreeButtonState.Visible);
                num1 = num2;
              }
            }
          }
          // ISSUE: reference to a compiler-generated field
          if (this.FillWithDataRowAdded != null)
            this.OnFillWithDataRowAdded(new iGFillWithDataRowAddedEventArgs(rowIndex, row, (IDataReader) null));
        }
        this.RecalcTotals();
        this.fVScrollBar.Value = 0;
        this.fHScrollBar.Value = 0;
      }
      finally
      {
        this.StaySorted = staySorted;
        this.EndUpdate();
      }
    }

    private void FillWithData_DbCommand(IDbCommand command, bool useCurColSet, string rowKeyCol, bool addRowKeyCol, string rowLevelCol, bool addRowLevelCol, bool addTreeButtons, int dataStartRow, int dataRowCount)
    {
      if (command == null)
        throw new ArgumentNullException();
      IDataReader dataReader = command.ExecuteReader();
      try
      {
        this.FillWithData_DataReader(dataReader, useCurColSet, rowKeyCol, addRowKeyCol, rowLevelCol, addRowLevelCol, addTreeButtons, dataStartRow, dataRowCount);
      }
      finally
      {
        dataReader.Close();
      }
    }

    private void FillWithData_DataReader(IDataReader dataReader, bool useCurColSet, string rowKeyCol, bool addRowKeyCol, string rowLevelCol, bool addRowLevelCol, bool addTreeButtons, int dataStartRow, int dataRowCount)
    {
      if (dataReader == null)
        throw new ArgumentNullException();
      if (dataStartRow < 0)
        throw new ArgumentOutOfRangeException(nameof (dataStartRow));
      if (dataRowCount < 0)
        throw new ArgumentOutOfRangeException(nameof (dataRowCount));
      bool staySorted = this.StaySorted;
      this.BeginUpdate();
      this.StaySorted = false;
      try
      {
        DataTable schemaTable = dataReader.GetSchemaTable();
        schemaTable.CaseSensitive = false;
        int count = schemaTable.Rows.Count;
        int colCount = count;
        bool flag1 = false;
        int index1 = -1;
        bool flag2 = false;
        int index2 = -1;
        if (!string.IsNullOrEmpty(rowKeyCol))
        {
          DataRow[] dataRowArray = schemaTable.Select("ColumnName = '" + rowKeyCol + "'");
          flag1 = (uint) dataRowArray.Length > 0U;
          if (flag1)
            index1 = (int) dataRowArray[0]["ColumnOrdinal"];
        }
        if (!string.IsNullOrEmpty(rowLevelCol))
        {
          DataRow[] dataRowArray = schemaTable.Select("ColumnName = '" + rowLevelCol + "'");
          flag2 = (uint) dataRowArray.Length > 0U;
          if (flag2)
            index2 = (int) dataRowArray[0]["ColumnOrdinal"];
        }
        int[] numArray = new int[count];
        if (!useCurColSet)
        {
          bool flag3 = false;
          string key = this.RowTextCol.Key;
          int num = 0;
          if (!string.IsNullOrEmpty(key))
          {
            for (int index3 = schemaTable.Rows.Count - 1; index3 >= 0; --index3)
            {
              if ((schemaTable.Rows[index3]["ColumnName"] as string).Equals(key, StringComparison.InvariantCultureIgnoreCase))
              {
                flag3 = true;
                num = index3;
                --colCount;
                break;
              }
            }
          }
          if (flag1 && !addRowKeyCol)
            --colCount;
          if (flag2 && !addRowLevelCol)
            --colCount;
          this.FillWithData_SetColCount(colCount);
          for (int index3 = 0; index3 < count; ++index3)
          {
            if ((!flag1 || addRowKeyCol || index3 != index1) && (!flag2 || addRowLevelCol || index3 != index2))
            {
              DataRow row = schemaTable.Rows[index3];
              int index4 = index3;
              if (flag3)
              {
                if (index3 > num)
                  --index4;
                else if (index3 == num)
                  index4 = -1;
              }
              if (flag1 && !addRowKeyCol && index3 > index1)
                --index4;
              if (flag2 && !addRowLevelCol && index3 > index2)
                --index4;
              numArray[index3] = index4 + 1;
              this.FillWithData_SetColumnParams(this.Cols[index4], row["DataType"] as Type, row["ColumnName"] as string, row["ColumnName"] as string, (bool) row["IsReadOnly"], (object) null);
            }
          }
        }
        else
        {
          for (int index3 = 0; index3 < count; ++index3)
            numArray[index3] = this.ColKeyToIndex(schemaTable.Rows[index3]["ColumnName"] as string, false);
        }
        this.FillWithData_SetRowCount(0);
        object[] values = new object[count];
        int num1 = 0;
        int num2 = 0;
        while (this.fRowCount < dataRowCount && dataReader.Read())
        {
          ++num2;
          if (num2 > dataStartRow)
          {
            int rowIndex = this.AddRowRange(this.fRowCount, 1);
            dataReader.GetValues(values);
            for (int index3 = 0; index3 < count; ++index3)
            {
              if (numArray[index3] >= 0)
                this.SetCellValue(rowIndex, numArray[index3], values[index3], false, true, false);
              if (flag1)
                this.SetRowKey(rowIndex, values[index1].ToString(), true);
              if (flag2)
              {
                int num3 = (int) values[index2];
                this.SetRowLevel(rowIndex, num3);
                if (addTreeButtons)
                {
                  this.SetRowTreeButton(rowIndex, iGTreeButtonState.Hidden);
                  if (rowIndex > 0 && num3 == num1 + 1)
                    this.SetRowTreeButton(rowIndex - 1, iGTreeButtonState.Visible);
                  num1 = num3;
                }
              }
            }
            // ISSUE: reference to a compiler-generated field
            if (this.FillWithDataRowAdded != null)
              this.OnFillWithDataRowAdded(new iGFillWithDataRowAddedEventArgs(rowIndex, (DataRow) null, dataReader));
          }
        }
        this.RecalcTotals();
        this.fVScrollBar.Value = 0;
        this.fHScrollBar.Value = 0;
      }
      finally
      {
        this.StaySorted = staySorted;
        this.EndUpdate();
        dataReader.Close();
      }
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.FillWithDataRowAdded" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGFillWithDataRowAddedEventArgs" /> that contains the event data.</param>
    protected virtual void OnFillWithDataRowAdded(iGFillWithDataRowAddedEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.FillWithDataRowAdded == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.FillWithDataRowAdded((object) this, e);
    }

    /// <summary>Occurs when the <see cref="Overload:TenTec.Windows.iGridLib.iGrid.FillWithData" /> method has created and populated a new row in the grid.</summary>
    [Category("Rows")]
    [Description("Occurs when a next row has been created and populated from within the FillWithData method.")]
    public event iGFillWithDataRowAddedEventHandler FillWithDataRowAdded;

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />.</summary>
    /// <param name="pevent">An <see cref="T:System.Windows.Forms.PaintEventArgs" /> that contains the event data.</param>
    protected override void OnPaintBackground(PaintEventArgs pevent)
    {
      if (this.fDrawCustomBackground && !this.DesignMode)
        this.DoCustomDrawBackground(pevent.Graphics, pevent.ClipRectangle);
      else
        base.OnPaintBackground(pevent);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.PaintEventArgs" /> that contains the event data.</param>
    protected override void OnPaint(PaintEventArgs e)
    {
      Rectangle clientRectangle = this.ClientRectangle;
      int borderSize = this.GetBorderSize();
      int x = clientRectangle.X + borderSize;
      int y1 = clientRectangle.Y + borderSize;
      int width = clientRectangle.Width - 2 * borderSize;
      int height = clientRectangle.Height - 2 * borderSize;
      int headerAreaHeight = this.GetHeaderAreaHeight();
      int footerAreaHeight = this.GetFooterAreaHeight();
      if (this.fRedraw)
      {
        this.DrawCellsAndRowHdrs(e.Graphics, x, y1 + headerAreaHeight, width, height - headerAreaHeight - footerAreaHeight, e.ClipRectangle);
        this.DrawControlNameAtDesignTime(e.Graphics);
      }
      int y2 = y1 + height - footerAreaHeight;
      if (this.fHScrollBar.Visible)
        y2 -= this.fHScrollBar.Height;
      this.DrawFooter(e.Graphics, x, y2, width, footerAreaHeight, e.ClipRectangle);
      this.DrawHeader(e.Graphics, x, y1, width, height, e.ClipRectangle);
      this.DrawBorder(e.Graphics, clientRectangle.X, clientRectangle.Y, clientRectangle.Width, clientRectangle.Height);
      this.DrawScrollBars(e.Graphics);
      if (this.IsAutoScroll() && this.fCursor != (Cursor) null)
        this.DrawAutoScrollBitmap(e.Graphics);
      this.DoPostPaint(e.Graphics, e.ClipRectangle);

       // FABRICE
        //if ((this.fWatermarkWasDrawn || this.DesignMode ? 1 : (Environment.TickCount - iGrid.fCreateTickCount >= 44000 ? 1 : 0)) != 0)
      if (true)
      {
                    this.fWatermarkWasDrawn = true;
        StringFormat format = new StringFormat();
        format.Alignment = StringAlignment.Far;
        format.LineAlignment = StringAlignment.Far;
        using (Font font = new Font("Tahoma", 7f))
        {
          //string str = string.Format("10Tec iGrid.NET {0}", (object) typeof (iGrid).Assembly.GetName().Version);
          //string str = string.Format("Fabrice Audouard Hack - iGrid.NET {0}", (object) typeof (iGrid).Assembly.GetName().Version);
          //char[] chArray = new char[20]
          //{
          //  'V',
          //  'O',
          //  'S',
          //  'F',
          //  'H',
          //  'J',
          //  'T',
          //  'U',
          //  'F',
          //  'S',
          //  'F',
          //  'E',
          //  '!',
          //  'W',
          //  'F',
          //  'S',
          //  'T',
          //  'J',
          //  'P',
          //  'O'
          //};
          //for (int index = 0; index < chArray.Length; ++index)
          //  chArray[index] = (char) ((uint) chArray[index] - 1U);
          //string s = str + "\r\n" + new string(chArray);
            string s = "Unlimited Version :-)"; // + new string(chArray);
          Rectangle areaBoundsNoRowHdr = this.GetCellsAreaBoundsNoRowHdr();
          e.Graphics.TextRenderingHint = this.fTextRenderingHint;
          e.Graphics.DrawString(s, font, SystemBrushes.ControlDark, (RectangleF) areaBoundsNoRowHdr, format);
        }
      }
      base.OnPaint(e);
    }

    private void DrawControlNameAtDesignTime(Graphics g)
    {
      if (!this.DesignMode || this.fRowCount != 0)
        return;
      RectangleF areaBoundsNoRowHdr = (RectangleF) this.GetCellsAreaBoundsNoRowHdr();
      areaBoundsNoRowHdr.Inflate(-3f, -3f);
      g.TextRenderingHint = this.fTextRenderingHint;
      g.DrawString(this.Name, this.Font, SystemBrushes.WindowText, areaBoundsNoRowHdr);
    }

    private void DrawVResizeLine(int x)
    {
      Rectangle headerAreaBounds = this.GetCellsAndRowHeaderAreaBounds(true);
      if (x < headerAreaBounds.Left || x >= headerAreaBounds.Right)
        return;
      ControlPaint.DrawReversibleLine(this.PointToScreen(new Point(x, headerAreaBounds.Top)), this.PointToScreen(new Point(x, headerAreaBounds.Bottom)), System.Drawing.Color.Black);
    }

    private void DrawHResizeLine(int y)
    {
      Rectangle headerAreaBounds = this.GetCellsAndRowHeaderAreaBounds(true);
      if (y < headerAreaBounds.Top || y >= headerAreaBounds.Bottom)
        return;
      ControlPaint.DrawReversibleLine(this.PointToScreen(new Point(headerAreaBounds.Left, y)), this.PointToScreen(new Point(headerAreaBounds.Right, y)), System.Drawing.Color.Black);
    }

    private ImageAttributes GetImageAttributes(float transparency)
    {
      float[][] newColorMatrix1 = new float[5][];
      for (int index = 0; index < 5; ++index)
      {
        newColorMatrix1[index] = new float[5];
        newColorMatrix1[index][index] = index == 3 ? transparency : 1f;
      }
      ImageAttributes imageAttributes = new ImageAttributes();
      ColorMatrix newColorMatrix2 = new ColorMatrix(newColorMatrix1);
      imageAttributes.SetColorMatrix(newColorMatrix2);
      return imageAttributes;
    }

    private Font AdjustFontForPrinting(Font font)
    {
      if (font == null)
        throw new ArgumentNullException();
      if ((uint) (font.Unit - 3) > 3U)
        return font;
      this.fFontForPrinterAdjusted = true;
      return new Font(font.Name, (float) ((double) font.SizeInPoints * (double) this.fDisplayVerticalResolution / 72.0), font.Style, GraphicsUnit.Pixel, font.GdiCharSet, font.GdiVerticalFont);
    }

    private void CheckDisposeFontForPrinter(Font font)
    {
      if (!this.fFontForPrinterAdjusted)
        return;
      font.Dispose();
      this.fFontForPrinterAdjusted = false;
    }

    private bool DrawActionIconSupported(iGActions action)
    {
      switch (action)
      {
        case iGActions.GoNextPage:
        case iGActions.GoPrevPage:
        case iGActions.GoFirstRow:
        case iGActions.GoFirstCol:
        case iGActions.GoLastRow:
        case iGActions.GoLastCol:
        case iGActions.SelectAllCells:
        case iGActions.DeselectAllCells:
        case iGActions.SelectAllRows:
        case iGActions.DeselectAllRows:
        case iGActions.ExpandAll:
        case iGActions.CollapseAll:
          return true;
        default:
          return false;
      }
    }

    private void DrawSelectDeselectAllCells(Graphics g, Rectangle bounds, iGActions action, System.Drawing.Color color, bool enabled)
    {
      int num1 = Math.Min(bounds.Width, bounds.Height) - 8;
      if (num1 <= 0)
        return;
      using (Pen pen = new Pen(color))
      {
        Brush brush = !enabled ? (Brush) new SolidBrush(SystemColors.ControlLight) : (Brush) new SolidBrush(SystemColors.Highlight);
        using (brush)
        {
          if (num1 < 7)
          {
            int x = bounds.X + (bounds.Width - num1) / 2;
            int y = bounds.Y + (bounds.Height - num1) / 2;
            g.DrawRectangle(pen, x, y, num1 - 1, num1 - 1);
            if (num1 <= 2 || action != iGActions.SelectAllCells)
              return;
            g.FillRectangle(brush, x + 1, y + 1, num1 - 2, num1 - 2);
          }
          else
          {
            int num2 = 5 + 2 * ((num1 - 5) / 2);
            int x = bounds.X + (bounds.Width - num2) / 2;
            int y = bounds.Y + (bounds.Height - num2) / 2;
            int num3 = (num2 - 5) / 2 + 2;
            if (num3 <= 0)
              return;
            g.DrawRectangle(pen, x, y, num3 - 1, num3 - 1);
            if (num3 > 2 && action == iGActions.SelectAllCells)
              g.FillRectangle(brush, x + 1, y + 1, num3 - 2, num3 - 2);
            g.DrawRectangle(pen, x + num3 + 1, y, num3 - 1, num3 - 1);
            if (num3 > 2 && action == iGActions.SelectAllCells)
              g.FillRectangle(brush, x + num3 + 2, y + 1, num3 - 2, num3 - 2);
            g.DrawRectangle(pen, x, y + num3 + 1, num3 - 1, num3 - 1);
            if (num3 > 2 && action == iGActions.SelectAllCells)
              g.FillRectangle(brush, x + 1, y + num3 + 2, num3 - 2, num3 - 2);
            g.DrawRectangle(pen, x + num3 + 1, y + num3 + 1, num3 - 1, num3 - 1);
            if (num3 <= 2 || action != iGActions.SelectAllCells)
              return;
            g.FillRectangle(brush, x + num3 + 2, y + num3 + 2, num3 - 2, num3 - 2);
          }
        }
      }
    }

    private void DrawSelectDeselectAllRows(Graphics g, Rectangle bounds, iGActions action, System.Drawing.Color color, bool enabled)
    {
      int num1 = Math.Min(bounds.Width, bounds.Height) - 8;
      if (num1 <= 0)
        return;
      using (Pen pen = new Pen(color))
      {
        Brush brush = !enabled ? (Brush) new SolidBrush(SystemColors.ControlLight) : (Brush) new SolidBrush(SystemColors.Highlight);
        using (brush)
        {
          if (num1 < 7)
          {
            int num2 = num1;
            int num3 = num1 / 2;
            if (num3 <= 0)
              return;
            int x = bounds.X + (bounds.Width - num2) / 2;
            int y = bounds.Y + (bounds.Height - num3) / 2;
            g.DrawRectangle(pen, x, y, num2 - 1, num3 - 1);
            if (num2 <= 2 || num3 <= 2 || action != iGActions.SelectAllRows)
              return;
            g.FillRectangle(brush, x + 1, y + 1, num2 - 2, num3 - 2);
          }
          else
          {
            int num2 = 5 + 2 * ((num1 - 5) / 2);
            int x = bounds.X + (bounds.Width - num2) / 2;
            int y = bounds.Y + (bounds.Height - num2) / 2;
            int num3 = (num2 - 5) / 2 + 2;
            if (num3 <= 0)
              return;
            g.DrawRectangle(pen, x, y, num2 - 1, num3 - 1);
            if (num3 > 2 && num2 > 2 && action == iGActions.SelectAllRows)
              g.FillRectangle(brush, x + 1, y + 1, num2 - 2, num3 - 2);
            g.DrawRectangle(pen, x, y + num3 + 1, num2 - 1, num3 - 1);
            if (num3 <= 2 || num2 <= 2 || action != iGActions.SelectAllRows)
              return;
            g.FillRectangle(brush, x + 1, y + num3 + 2, num2 - 2, num3 - 2);
          }
        }
      }
    }

    private void DrawExpandCollapseAll(Graphics g, Rectangle bounds, iGActions action, System.Drawing.Color color)
    {
      int num1 = Math.Min(bounds.Width, bounds.Height) - 8;
      int num2 = num1 / 9;
      if (num2 == 0)
      {
        if (num1 >= 7)
        {
          int x1 = bounds.X + (bounds.Width - 7) / 2;
          if (action == iGActions.ExpandAll)
          {
            int num3 = bounds.Y + (bounds.Height - 7) / 2;
            using (Pen pen = new Pen(color, (float) num2))
            {
              g.DrawLine(pen, x1, num3, x1 + 6, num3);
              g.DrawLine(pen, x1 + 3, num3 + 2, x1 + 6, num3 + 2);
              g.DrawLine(pen, x1 + 3, num3 + 4, x1 + 6, num3 + 4);
              g.DrawLine(pen, x1, num3 + 6, x1 + 6, num3 + 6);
            }
          }
          else
          {
            int num3 = bounds.Y + (bounds.Height - 5) / 2;
            using (Pen pen = new Pen(color, (float) num2))
            {
              g.DrawLine(pen, x1, num3, x1 + 6, num3);
              g.DrawLine(pen, x1, num3 + 2, x1 + 6, num3 + 2);
              g.DrawLine(pen, x1, num3 + 4, x1 + 6, num3 + 4);
            }
          }
        }
        else
        {
          int x1 = bounds.X + (bounds.Width - 5) / 2;
          if (action == iGActions.ExpandAll)
          {
            int num3 = bounds.Y + (bounds.Height - 5) / 2;
            using (Pen pen = new Pen(color, (float) num2))
            {
              g.DrawLine(pen, x1, num3, x1 + 4, num3);
              g.DrawLine(pen, x1 + 2, num3 + 2, x1 + 4, num3 + 2);
              g.DrawLine(pen, x1, num3 + 4, x1 + 4, num3 + 4);
            }
          }
          else
          {
            int num3 = bounds.Y + (bounds.Height - 3) / 2;
            using (Pen pen = new Pen(color, (float) num2))
            {
              g.DrawLine(pen, x1, num3, x1 + 4, num3);
              g.DrawLine(pen, x1, num3 + 2, x1 + 4, num3 + 2);
            }
          }
        }
      }
      else
      {
        int num3 = (num1 - 5 * num2) / 4;
        int num4 = 5 * num2 + 4 * num3;
        int x = bounds.X + (bounds.Width - num4) / 2 + num2 / 2;
        if (action == iGActions.ExpandAll)
        {
          int y = bounds.Y + (bounds.Height - num4) / 2 + num2 / 2;
          int num5 = 2 * num4 / 3;
          using (Pen pen = new Pen(color, (float) num2))
          {
            g.DrawRectangle(pen, x, y, num4 - num2, num2 + num3);
            g.DrawRectangle(pen, x + num4 - num5, y + (num2 + num3), num5 - num2, num2 + num3);
            g.DrawRectangle(pen, x + num4 - num5, y + 2 * (num2 + num3), num5 - num2, num2 + num3);
            g.DrawRectangle(pen, x, y + 3 * (num2 + num3), num4 - num2, num2 + num3);
          }
        }
        else
        {
          int num5 = 4 * num2 + 3 * num3;
          int y = bounds.Y + (bounds.Height - num5) / 2 + num2 / 2;
          using (Pen pen = new Pen(color, (float) num2))
          {
            g.DrawRectangle(pen, x, y, num4 - num2, num2 + num3);
            g.DrawRectangle(pen, x, y + (num2 + num3), num4 - num2, num2 + num3);
            g.DrawRectangle(pen, x, y + 2 * (num2 + num3), num4 - num2, num2 + num3);
          }
        }
      }
    }

    private void DrawLastPrevRowCol(Graphics g, Rectangle bounds, iGActions action, System.Drawing.Color color)
    {
      int x = bounds.X + 2;
      int y = bounds.Y + 2;
      iGArrowDirection direction;
      switch (action)
      {
        case iGActions.GoFirstRow:
          direction = iGArrowDirection.Up;
          break;
        case iGActions.GoFirstCol:
          direction = this.RightToLeft != RightToLeft.Yes ? iGArrowDirection.Left : iGArrowDirection.Right;
          break;
        case iGActions.GoLastCol:
          direction = this.RightToLeft != RightToLeft.Yes ? iGArrowDirection.Right : iGArrowDirection.Left;
          break;
        default:
          direction = iGArrowDirection.Down;
          break;
      }
      int arrowSize = iGDrawGridItem.GetArrowSize(ref x, ref y, bounds.Width - 4, bounds.Height - 4, direction, false);
      int num1 = (int) ((double) arrowSize / 4.0 + 0.5);
      if (num1 <= 0)
        num1 = 0;
      switch (direction)
      {
        case iGArrowDirection.Up:
          y += num1;
          break;
        case iGArrowDirection.Left:
          x += num1;
          break;
        case iGArrowDirection.Right:
          x -= num1;
          break;
        default:
          y -= num1;
          break;
      }
      int num2 = iGDrawGridItem.DrawArrow(g, color, x, y, arrowSize, direction);
      if (num2 <= 0)
        return;
      using (Brush brush = (Brush) new SolidBrush(color))
      {
        switch (direction)
        {
          case iGArrowDirection.Up:
            g.FillRectangle(brush, x, y - 2 * num1, num2, num1);
            break;
          case iGArrowDirection.Down:
            g.FillRectangle(brush, x, y + arrowSize + 2 * num1 - 1, num2, num1);
            break;
          case iGArrowDirection.Left:
            g.FillRectangle(brush, x - 2 * num1, y, num1, num2);
            break;
          case iGArrowDirection.Right:
            g.FillRectangle(brush, x + arrowSize + 2 * num1 - 1, y, num1, num2);
            break;
        }
      }
    }

    /// <summary>Draws the specified action's icon on the specified canvas. Use this method to draw an action icon on a scroll bar custom button.</summary>
    /// <param name="g">The graphics surface to draw the action icon on.</param>
    /// <param name="bounds">The bounds of the button to draw the action icon on.</param>
    /// <param name="action">The action which icon to draw.</param>
    /// <param name="enabled">True to draw the action icon with <see cref="P:TenTec.Windows.iGridLib.iGScrollBarSettings.ForeColor" /> of the scroll bars, False - with the <see cref="P:System.Windows.Forms.Control.ForeColor" /> of the grid.</param>
    public void DrawActionIcon(Graphics g, Rectangle bounds, iGActions action, bool enabled)
    {
      if (!this.DrawActionIconSupported(action))
        throw new ArgumentException();
      IiGControlPaint iGcontrolPaint = this.fVScrollBar.fCustomControlPaint == null || (this.fVScrollBar.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.ControlsColors) != iGControlPaintFunctions.ControlsColors ? (IiGControlPaint) this.fVScrollBar.fControlPaintStyle.ControlPaint : this.fVScrollBar.fCustomControlPaint;
      System.Drawing.Color color = !enabled ? iGcontrolPaint.ControlsDisabledForeColor : iGcontrolPaint.ControlsForeColor;
      switch (action)
      {
        case iGActions.GoNextPage:
          iGDrawGridItem.DrawArrowOnButton(g, color, bounds.X, bounds.Y, bounds.Width, bounds.Height, iGArrowDirection.Down, true);
          break;
        case iGActions.GoPrevPage:
          iGDrawGridItem.DrawArrowOnButton(g, color, bounds.X, bounds.Y, bounds.Width, bounds.Height, iGArrowDirection.Up, true);
          break;
        case iGActions.GoFirstRow:
        case iGActions.GoFirstCol:
        case iGActions.GoLastRow:
        case iGActions.GoLastCol:
          this.DrawLastPrevRowCol(g, bounds, action, color);
          break;
        case iGActions.SelectAllCells:
        case iGActions.DeselectAllCells:
          this.DrawSelectDeselectAllCells(g, bounds, action, color, enabled);
          break;
        case iGActions.SelectAllRows:
        case iGActions.DeselectAllRows:
          this.DrawSelectDeselectAllRows(g, bounds, action, color, enabled);
          break;
        case iGActions.ExpandAll:
        case iGActions.CollapseAll:
          this.DrawExpandCollapseAll(g, bounds, action, color);
          break;
      }
    }

    private bool IsDrawSizeBox()
    {
      if (this.RightToLeft == RightToLeft.Yes || !this.fHScrollBar.Visible || !this.fVScrollBar.Visible)
        return false;
      Form topLevelControl = this.TopLevelControl as Form;
      if (topLevelControl == null || topLevelControl.WindowState != FormWindowState.Normal || topLevelControl.FormBorderStyle != FormBorderStyle.Sizable && topLevelControl.FormBorderStyle != FormBorderStyle.SizableToolWindow)
        return false;
      Point screen = this.PointToScreen(new Point(0, 0));
      Point client = topLevelControl.PointToClient(screen);
      return client.X + this.Width >= topLevelControl.ClientRectangle.Width - 1 && client.Y + this.Height >= topLevelControl.ClientRectangle.Height - 1;
    }

    private void DrawSizeBox(Graphics g, int x, int y)
    {
      int width = this.fVScrollBar.Width;
      int height = this.fHScrollBar.Height;
      System.Drawing.Color color;
      IiGControlPaint iGcontrolPaint;
      if (this.fVScrollBar.fCustomControlPaint != null)
      {
        color = (this.fVScrollBar.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.ControlsColors) != iGControlPaintFunctions.ControlsColors ? this.fVScrollBar.fControlPaintStyle.BackColor : this.fVScrollBar.fCustomControlPaint.ControlsBackColor;
        iGcontrolPaint = (this.fVScrollBar.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.SizeBox) != iGControlPaintFunctions.SizeBox ? (IiGControlPaint) this.fVScrollBar.fControlPaintStyle.ControlPaint : this.fVScrollBar.fCustomControlPaint;
      }
      else
      {
        iGcontrolPaint = (IiGControlPaint) this.fVScrollBar.fControlPaintStyle.ControlPaint;
        color = this.fVScrollBar.fControlPaintStyle.BackColor;
      }
      using (Brush brush = (Brush) new SolidBrush(color))
        g.FillRectangle(brush, x, y, width, height);
      if (!this.IsDrawSizeBox())
        return;
      iGcontrolPaint.DrawSizeBox(g, x, y, width, height, iGSizeBoxAlign.Right);
    }

    private void DrawScrollBars(Graphics g)
    {
      if (!this.fHScrollBar.Visible && !this.fVScrollBar.Visible)
        return;
      if (this.fScrollBarOpacity == 1.0)
      {
        if (!this.fHScrollBar.Visible || !this.fVScrollBar.Visible)
          return;
        this.DrawSizeBox(g, this.fVScrollBar.Left, this.fHScrollBar.Top);
      }
      else
      {
        ImageAttributes imageAttributes = this.GetImageAttributes((float) this.fScrollBarOpacity);
        if (this.fHScrollBar.Visible)
          this.DrawTransparent(g, this.fHScrollBar.Bounds, imageAttributes, new iGrid.iGDrawTransparentDelegate(((iGScrollBarBase) this.fHScrollBar).PaintTo));
        if (this.fVScrollBar.Visible)
          this.DrawTransparent(g, this.fVScrollBar.Bounds, imageAttributes, new iGrid.iGDrawTransparentDelegate(((iGScrollBarBase) this.fVScrollBar).PaintTo));
        if (!this.fHScrollBar.Visible || !this.fVScrollBar.Visible)
          return;
        this.DrawTransparent(g, new Rectangle(this.fVScrollBar.Left, this.fHScrollBar.Top, this.fVScrollBar.Width, this.fHScrollBar.Height), imageAttributes, new iGrid.iGDrawTransparentDelegate(this.DrawSizeBox));
      }
    }

    private void DrawTransparent(Graphics g, Rectangle bounds, ImageAttributes attributes, iGrid.iGDrawTransparentDelegate paint)
    {
      IntPtr hdc = g.GetHdc();
      IntPtr compatibleBitmap;
      IntPtr compatibleDc;
      try
      {
        compatibleBitmap = iGNativeMethods.CreateCompatibleBitmap(hdc, bounds.Width, bounds.Height);
        compatibleDc = iGNativeMethods.CreateCompatibleDC(hdc);
      }
      finally
      {
        g.ReleaseHdc(hdc);
      }
      try
      {
        iGNativeMethods.SelectObject(compatibleDc, compatibleBitmap);
        using (Graphics g1 = Graphics.FromHdc(compatibleDc))
          paint(g1, 0, 0);
        using (Image image = (Image) Image.FromHbitmap(compatibleBitmap))
          g.DrawImage(image, bounds, 0, 0, bounds.Width, bounds.Height, GraphicsUnit.Pixel, attributes);
      }
      finally
      {
        iGNativeMethods.DeleteObject(compatibleDc);
        iGNativeMethods.DeleteObject(compatibleBitmap);
      }
    }

    private void DrawCellsAndRowHdrs(Graphics g, int x, int y, int width, int height, Rectangle clipRectangle)
    {
      if (width <= 0 || height <= 0 || !clipRectangle.IntersectsWith(new Rectangle(x, y, width, height)) || this.fRowCount == 0 && this.fExtendGridLinesMode == iGGridLinesMode.None)
        return;
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      IiGControlPaint controlPaint = (IiGControlPaint) this.fCellControlPaintStyle.ControlPaint;
      int startIndex = int.MaxValue;
      bool selected = false;
      int firstSelectableColOrder;
      int lastSelectableColOrder;
      this.GetSelectableColsInRowMode(out firstSelectableColOrder, out lastSelectableColOrder);
      bool flag1 = this.IsMousePressedSelection();
      int min1 = 0;
      int max1 = 0;
      int min2 = 0;
      int max2 = 0;
      Brush brush = (Brush) null;
      if (flag1)
      {
        iGSelectCellsData tag = (iGSelectCellsData) this.fMouseData.Tag;
        this.GetMinMax(tag.EndRowIndex, this.fMouseData.RowIndex, out min1, out max1);
        this.GetMinMax(tag.EndColOrder, this.fMouseData.ColOrder, out min2, out max2);
        System.Drawing.Color color = !this.fRowMode ? this.SelCellsBackColor : (!this.fSelRowsBackColor.IsEmpty ? this.fSelRowsBackColor : this.SelCellsBackColor);
        color = System.Drawing.Color.FromArgb(50, (int) color.R, (int) color.G, (int) color.B);
        brush = (Brush) new SolidBrush(color);
      }
      bool flag2 = (this.fExtendGridLinesMode & iGGridLinesMode.Horizontal) > iGGridLinesMode.None;
      bool flag3 = (this.fExtendGridLinesMode & iGGridLinesMode.Vertical) > iGGridLinesMode.None;
      iGrid.GridLineParams gridLineStyleParams1 = this.GetGridLineStyleParams(this.fVGridLinesStyle, iGOrientation.Vertical, false);
      iGrid.GridLineParams gridLineStyleParams2 = this.GetGridLineStyleParams(this.fVLastColGridLineStyle, iGOrientation.Vertical, false);
      iGrid.GridLineParams gridLineStyleParams3 = this.GetGridLineStyleParams(this.fHGridLinesStyle, iGOrientation.Horizontal, false);
      iGrid.GridLineParams gridLineStyleParams4 = this.GetGridLineStyleParams(this.fHLastRowGridLineStyle, iGOrientation.Horizontal, false);
      iGrid.GridLineParams gridLineStyleParams5 = this.GetGridLineStyleParams(this.fGroupRowsGridLinesStyle, iGOrientation.Horizontal, false);
      iGrid.GridLineParams gridLineStyleParams6 = this.GetGridLineStyleParams(this.fFrozenColsSeparatingLineStyle, iGOrientation.Vertical, false);
      iGrid.GridLineParams gridLineStyleParams7 = this.GetGridLineStyleParams(this.fFrozenRowsSeparatingLineStyle, iGOrientation.Horizontal, false);
      iGrid.GridLineParams gridLineStyleParams8 = this.GetGridLineStyleParams(this.fHExtendedGridLineStyle, iGOrientation.Horizontal, false);
      iGrid.GridLineParams gridLineStyleParams9 = this.GetGridLineStyleParams(this.fVExtendedGridLineStyle, iGOrientation.Vertical, false);
      int num1 = this.fRowHeader.EffectiveWidth();
      int x1 = rightToLeft ? x + width - num1 : x;
      int num2 = rightToLeft ? x : x + num1;
      int y1 = y;
      int num3 = width - num1;
      int height1 = height;
      int num4 = y1 + height1 - 1;
      int num5 = num2 + num3 - 1;
      Region clip = g.Clip;
      g.SetClip(new Rectangle(x, y, width, height), CombineMode.Intersect);
      Region region = clip;
      IntPtr rectRgn1 = iGNativeMethods.CreateRectRgn(0, 0, 0, 0);
      IntPtr rectRgn2 = iGNativeMethods.CreateRectRgn(0, 0, 0, 0);
      IntPtr hdc1 = g.GetHdc();
      bool flag4 = iGNativeMethods.GetClipRgn(hdc1, rectRgn1) == 1;
      iGNativeMethods.IntersectClipRect(hdc1, x, y, x + width, y + height);
      bool flag5 = iGNativeMethods.GetClipRgn(hdc1, rectRgn2) == 1;
      g.ReleaseHdc(hdc1);
      int x2 = int.MinValue;
      int width1 = 0;
      bool flag6 = false;
      bool flag7 = true;
      int visibleFrozenColOrder = this.GetLastVisibleFrozenColOrder();
      int visibleFrozenRowIndex = this.GetLastVisibleFrozenRowIndex();
      int groupObjectColCount = this.GetGroupObjectColCount();
      int nextLevel = 0;
      SolidBrush[] levelAreaBrushes = new SolidBrush[groupObjectColCount];
      bool flag8 = this.IsLevelAreaScrollableNoTreeCol();
      Size size = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.TreeButton) != iGControlPaintFunctions.TreeButton ? controlPaint.GetTreeButtonSize() : this.fCustomControlPaint.GetTreeButtonSize();
      int treeButtonAreaWidth = this.GetTreeButtonAreaWidth(size);
      bool flag9 = this.IsGroupRowContentScrollable();
      int lastAutoGroupRowLevel = -1;
      int endVisibleColOrder = this.GetRowTextEndVisibleColOrder();
      bool isRowTextDrawn = this.IsRowTextDisplayed();
      bool enabled = this.Enabled;
      bool drawAsFocusedState = this.GetDrawAsFocusedState();
      int vscrollBarWidth = this.GetVScrollBarWidth();
      int num6 = num2;
      if (this.fScrollBarOpacity == 1.0 & rightToLeft)
        num6 += vscrollBarWidth;
      int num7 = num3;
      if (this.fScrollBarOpacity == 1.0)
        num7 -= vscrollBarWidth;
      int num8 = num6 + num7;
      int num9 = y1;
      int num10 = num9 + height1;
      if (this.fScrollBarOpacity == 1.0)
        num10 -= this.GetHScrollBarHeight();
      List<iGTreeBranchState> gtreeBranchStateList = (List<iGTreeBranchState>) null;
      int num11 = y1;
      bool flag10 = false;
      int rowIndex1;
      for (int rowIndex2 = -1; rowIndex2 < this.fRowCount; rowIndex2 = rowIndex1)
      {
        int level = nextLevel;
        iGRowData rowData;
        bool isAutoGroupRow;
        bool isGroupRow;
        if (rowIndex2 > -1)
        {
          rowData = this.GetRowDataInternal(rowIndex2);
          isAutoGroupRow = rowData.Type == iGRowType.AutoGroupRow;
          isGroupRow = isAutoGroupRow || rowData.Type == iGRowType.ManualGroupRow;
        }
        else
        {
          rowData = new iGRowData();
          isAutoGroupRow = false;
          isGroupRow = false;
        }
        for (rowIndex1 = rowIndex2 + 1; rowIndex1 < this.fRowCount; ++rowIndex1)
        {
          if (rowIndex1 == this.fFrozenRowCount)
            rowIndex1 = this.fViewportFirstRowIndex;
          iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
          if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          {
            nextLevel = rowIndex1 < this.fFrozenRowCount ? 0 : rowDataInternal.Level;
            goto label_22;
          }
        }
        nextLevel = 0;
label_22:
        if (rowIndex2 != -1)
        {
          if (isGroupRow)
            this.fIsOneOfTheGroupRowsVisible = true;
          for (int index = level; index < levelAreaBrushes.Length; ++index)
            levelAreaBrushes[index] = (SolidBrush) null;
          if (isAutoGroupRow)
          {
            this.SetLevelBrush(rowIndex2, 0, level, ref levelAreaBrushes);
            lastAutoGroupRowLevel = level;
          }
          else if (lastAutoGroupRowLevel >= level)
          {
            lastAutoGroupRowLevel = level - 1;
            while (lastAutoGroupRowLevel >= 0 && levelAreaBrushes[lastAutoGroupRowLevel] == null)
              --lastAutoGroupRowLevel;
          }
          if (flag7 && rowIndex2 >= this.fFrozenRowCount)
          {
            if (num11 > y1)
            {
              g.SetClip(new Rectangle(x, num11, width, y + height - num11), CombineMode.Intersect);
              region = g.Clip;
              IntPtr hdc2 = g.GetHdc();
              iGNativeMethods.IntersectClipRect(hdc2, x, num11, x + width, y + height);
              flag5 = iGNativeMethods.GetClipRgn(hdc2, rectRgn2) == 1;
              g.ReleaseHdc(hdc2);
            }
            this.FillLevelAreaBrushes(rowIndex2, isAutoGroupRow, level, ref levelAreaBrushes, ref lastAutoGroupRowLevel);
            if (this.fTreeLinesVisible)
            {
              gtreeBranchStateList = new List<iGTreeBranchState>();
              this.FillTreeBranchData(gtreeBranchStateList, rowIndex2, true, (iGIsRowVisibleDelegate) null);
            }
            num11 -= this.fViewportFirstRowHiddenHeight;
            flag10 = this.fViewportFirstRowVisibleCountBefore % 2 == 1;
            flag7 = false;
          }
          else if (gtreeBranchStateList != null)
            this.FillTreeBranchData(gtreeBranchStateList, rowIndex2, false, (iGIsRowVisibleDelegate) null);
          int firstColX = this.GetFirstColX(rightToLeft, num2, num3);
          int num12 = firstColX;
          int num13 = num11 + rowData.Height;
          if (clipRectangle.Bottom >= num11 && clipRectangle.Top < num13)
          {
            if (this.fSelectedRows.Count > 0)
            {
              if (startIndex < 0)
                startIndex = ~startIndex;
              startIndex = startIndex != int.MaxValue ? (startIndex != this.fSelectedRows.Count ? this.fSelectedRows.IndexOf(rowIndex2, startIndex) : ~startIndex) : this.fSelectedRows.IndexOf(rowIndex2);
              selected = startIndex >= 0;
            }
            int num14 = int.MinValue;
            int num15 = 0;
            int num16 = 0;
            int x1_1 = int.MinValue;
            int num17 = 0;
            bool flag11 = false;
            bool flag12 = false;
            int num18 = 0;
            bool isFirstVisibleCol = true;
            bool flag13 = true;
            bool flag14 = true;
            if (this.fMergedCellCountAll > 0 && !isGroupRow && (rowIndex1 < this.fRowCount && this.GetRowDataInternal(rowIndex1).Type == iGRowType.Normal))
              flag14 = false;
            for (int colDrawOrder = 0; colDrawOrder < this.fColCount; ++colDrawOrder)
            {
              int colOrder = !isGroupRow ? this.DrawColOrderToColOrder(colDrawOrder) : 0;
              int colIndex1 = this.fColIdxFromOrd[colOrder];
              iGColData fColData = this.fColDatas[colIndex1];
              bool flag15 = !this.IsTreeColSpecified() ? !flag11 : this.IsTreeCol(colIndex1);
              iGTreeButtonState treeButtonState = !(flag15 | isGroupRow) ? iGTreeButtonState.Absent : rowData.TreeButton;
              iGColDisposition iGcolDisposition = isGroupRow ? iGColDisposition.Normal : this.GetColDisposition(colOrder, isRowTextDrawn);
              iGCellData cellDataInternal1 = this.GetCellDataInternal(rowIndex2, colIndex1);
              bool lastVisibleCol = colIndex1 == this.fLastVisibleColIndex | isGroupRow || iGcolDisposition == iGColDisposition.RowText && this.fColIdxFromOrd[endVisibleColOrder] == this.fLastVisibleColIndex || cellDataInternal1.SpanCols > 1 && this.fColIdxFromOrd[colOrder + cellDataInternal1.SpanCols - 1] >= this.fLastVisibleColIndex;
              bool lastVisibleFrozenCol = colOrder == visibleFrozenColOrder || cellDataInternal1.SpanCols > 1 && colOrder + cellDataInternal1.SpanCols - 1 == visibleFrozenColOrder;
              bool visible1;
              int width2;
              this.GetHGridLineWidthAndVisible(rowIndex2, visibleFrozenRowIndex, isGroupRow, gridLineStyleParams7.Visible, gridLineStyleParams3.Visible, gridLineStyleParams4.Visible, gridLineStyleParams1.Visible, iGcolDisposition == iGColDisposition.AboveRowText, out visible1, out width2);
              bool visible2;
              int width3;
              this.GetVGridLineWidthAndVisible(lastVisibleCol, lastVisibleFrozenCol, gridLineStyleParams2.Visible, gridLineStyleParams6.Visible, gridLineStyleParams1.Visible, out visible2, out width3);
              bool flag16 = true;
              int num19 = 0;
              int num20 = 0;
              int num21 = 0;
              int num22 = 0;
              int num23 = 0;
              int num24 = 0;
              bool flag17 = flag10;
              int x3;
              int num25;
              int colsWidth1;
              int num26;
              if (iGcolDisposition == iGColDisposition.RowText)
              {
                x3 = num14;
                if (rightToLeft)
                  x3 -= num15;
                num25 = num16;
                colsWidth1 = num15;
                num26 = rowData.Height - rowData.NormalCellHeight;
              }
              else
              {
                bool isFirstVisibleAboveRowTextCol = iGcolDisposition == iGColDisposition.AboveRowText && colOrder >= this.fRowTextStartColNear && num14 == int.MinValue;
                int num27 = 0;
                bool drawAsRowSelected = selected && rowData.Selectable && (this.fHighlightSelCells && colOrder >= firstSelectableColOrder) && colOrder <= lastSelectableColOrder;
                int colsWidth2;
                if (!isGroupRow)
                {
                  if (colOrder == this.fFrozenColCount)
                  {
                    this.SetFrozenColClip(g, num12, num2, y1, num3, height1, rightToLeft);
                    num12 = this.GetScrolledX(num12, rightToLeft);
                  }
                  if (iGcolDisposition != iGColDisposition.Auxiliary && this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex1))
                  {
                    if (!flag12 & flag15)
                    {
                      if (rowIndex2 >= this.fFrozenRowCount && level > 0)
                      {
                        int colWithAutoLevelWidth = fColData.Width + groupObjectColCount * this.fLevelIndent;
                        int colWithAutoLevelX = num12;
                        if (rightToLeft)
                          colWithAutoLevelX -= colWithAutoLevelWidth;
                        this.DrawLevelArea(g, rowIndex2, level, nextLevel, isGroupRow, isFirstVisibleCol, flag13 && colOrder >= firstSelectableColOrder, iGcolDisposition == iGColDisposition.AboveRowText, isFirstVisibleAboveRowTextCol, colWithAutoLevelX, colWithAutoLevelWidth, num11, rowData.Height, rowData.NormalCellHeight, cellDataInternal1.Style, rowData.CellStyle, fColData.CellStyle, drawAsRowSelected, drawAsFocusedState, levelAreaBrushes, visibleFrozenRowIndex, gridLineStyleParams7.Visible, gridLineStyleParams3.Visible, gridLineStyleParams4.Visible, gridLineStyleParams1.Visible, gridLineStyleParams5, rightToLeft, gtreeBranchStateList, flag10 && !isGroupRow, !flag10 && !isGroupRow);
                      }
                      flag12 = true;
                    }
                    colsWidth2 = fColData.Width;
                    if (flag15)
                    {
                      if (rowIndex2 >= this.fFrozenRowCount)
                      {
                        if (level > 0)
                        {
                          if (rightToLeft)
                            num12 -= level * this.fLevelIndent;
                          else
                            num12 += level * this.fLevelIndent;
                        }
                        colsWidth2 += (groupObjectColCount - level) * this.fLevelIndent;
                        if (level > groupObjectColCount)
                        {
                          int num28 = level > lastAutoGroupRowLevel ? level - (lastAutoGroupRowLevel + 1) : lastAutoGroupRowLevel - level;
                          if (colsWidth2 + num28 * this.fLevelIndent < 0)
                            num18 = colsWidth2 + num28 * this.fLevelIndent;
                          if (level > lastAutoGroupRowLevel)
                          {
                            num27 = (level - (lastAutoGroupRowLevel + 1)) * this.fLevelIndent;
                            if (colsWidth2 < 0)
                            {
                              num27 += colsWidth2;
                              if (num27 < 0)
                                num27 = 0;
                            }
                          }
                        }
                      }
                      else
                        colsWidth2 += groupObjectColCount * this.fLevelIndent;
                      flag11 = true;
                    }
                  }
                  else
                    continue;
                }
                else
                {
                  if (level > 0)
                  {
                    int num28 = num12;
                    int num29 = this.fVisibleColsWidthPlusGroupObjectLevelArea;
                    if (flag8)
                    {
                      num28 = this.GetScrolledX(num28, rightToLeft);
                      if (rightToLeft)
                        num28 -= num29;
                    }
                    else
                    {
                      num29 = this.GetGroupRowWidthWhenLevelAreaIsFrozen(num28, num29, rightToLeft);
                      if (rightToLeft)
                        num28 -= num29;
                      if (!flag9)
                      {
                        if (rightToLeft)
                        {
                          int num30 = num2 + vscrollBarWidth - num28;
                          if (num30 > 0)
                          {
                            num28 = num2 + vscrollBarWidth;
                            num29 -= num30;
                          }
                        }
                        else
                        {
                          int num30 = num28 + num29 - (num2 + num3 - vscrollBarWidth);
                          if (num30 > 0)
                            num29 -= num30;
                        }
                      }
                    }
                    this.DrawLevelArea(g, rowIndex2, level, nextLevel, isGroupRow, true, true, false, false, num28, num29, num11, rowData.Height, rowData.NormalCellHeight, (iGCellStyle) null, rowData.CellStyle, (iGCellStyle) null, drawAsRowSelected, drawAsFocusedState, levelAreaBrushes, visibleFrozenRowIndex, gridLineStyleParams6.Visible, gridLineStyleParams3.Visible, gridLineStyleParams4.Visible, gridLineStyleParams1.Visible, gridLineStyleParams5, rightToLeft, gtreeBranchStateList, flag10 && !isGroupRow, !flag10 && !isGroupRow);
                  }
                  colsWidth2 = this.fVisibleColsWidthPlusGroupObjectLevelArea;
                  if (level > 0)
                  {
                    if (rightToLeft)
                    {
                      firstColX -= level * this.fLevelIndent;
                      num12 -= level * this.fLevelIndent;
                    }
                    else
                    {
                      firstColX += level * this.fLevelIndent;
                      num12 += level * this.fLevelIndent;
                    }
                    colsWidth2 -= level * this.fLevelIndent;
                  }
                  if (flag8)
                  {
                    if (rightToLeft)
                      num12 += this.fHScrollBar.Value;
                    else
                      num12 -= this.fHScrollBar.Value;
                  }
                  else
                    colsWidth2 = this.GetGroupRowWidthWhenLevelAreaIsFrozen(num12, colsWidth2, rightToLeft);
                }
                if (!isGroupRow && this.fMergedCellCountAll > 0)
                {
                  if (cellDataInternal1.SpanCols >= 1 && cellDataInternal1.SpanRows >= 1)
                  {
                    flag16 = true;
                    if (cellDataInternal1.SpanCols > 1)
                    {
                      num19 = this.MergedCellExpandWidthDelta(colOrder, cellDataInternal1.SpanCols);
                      num24 = cellDataInternal1.SpanCols - 1;
                    }
                    if (cellDataInternal1.SpanRows > 1)
                      num20 = this.MergedCellExpandHeightDelta(rowIndex2, cellDataInternal1.SpanRows);
                  }
                  else
                  {
                    bool flag18 = false;
                    if (rowIndex2 + cellDataInternal1.SpanRows < this.fViewportFirstRowIndex)
                    {
                      if (rowIndex2 > this.fViewportFirstRowIndex)
                      {
                        flag18 = true;
                      }
                      else
                      {
                        for (int rowIndex3 = rowIndex2 + cellDataInternal1.SpanRows; rowIndex3 < rowIndex2; ++rowIndex3)
                        {
                          if (this.IsRowVisibleInternal(rowIndex3))
                          {
                            iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex3);
                            if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
                            {
                              num21 -= rowDataInternal.Height;
                              num20 += rowDataInternal.Height;
                            }
                          }
                        }
                      }
                    }
                    else
                    {
                      for (int rowIndex3 = rowIndex2 + cellDataInternal1.SpanRows; rowIndex3 < rowIndex2; ++rowIndex3)
                      {
                        if (this.IsRowVisibleInternal(rowIndex3))
                        {
                          flag18 = true;
                          break;
                        }
                      }
                    }
                    if (!flag18)
                    {
                      for (int index = colOrder + cellDataInternal1.SpanCols; index < colOrder; ++index)
                      {
                        if (this.IsColVisible(this.fColIdxFromOrd[index]))
                        {
                          flag18 = true;
                          break;
                        }
                      }
                    }
                    if (flag18)
                    {
                      flag16 = false;
                    }
                    else
                    {
                      flag16 = true;
                      num23 = cellDataInternal1.SpanCols;
                      num22 = cellDataInternal1.SpanRows;
                      int index = colOrder + cellDataInternal1.SpanCols;
                      int rowIndex3 = rowIndex2 + cellDataInternal1.SpanRows;
                      cellDataInternal1 = this.GetCellDataInternal(rowIndex3, this.fColIdxFromOrd[index]);
                      int spanCols = index + cellDataInternal1.SpanCols - colOrder;
                      int spanRows = rowIndex3 + cellDataInternal1.SpanRows - rowIndex2;
                      num19 += this.MergedCellExpandWidthDelta(colOrder, spanCols);
                      num20 += this.MergedCellExpandHeightDelta(rowIndex2, spanRows);
                      num24 = spanCols - 1;
                      for (int rowIndex4 = rowIndex2 - 1; rowIndex4 >= rowIndex3; --rowIndex4)
                      {
                        if (this.IsRowVisibleInternal(rowIndex4))
                          flag17 = !flag17;
                      }
                    }
                  }
                }
                colsWidth1 = colsWidth2 + num19;
                if (this.fRowMode && this.fCurCell.RowIndex == rowIndex2 && (colOrder >= firstSelectableColOrder && colOrder <= lastSelectableColOrder))
                {
                  int num28 = (level - lastAutoGroupRowLevel - 1) * this.fLevelIndent;
                  if (x2 == int.MinValue)
                  {
                    x2 = num12;
                    flag6 = colOrder >= this.fFrozenColCount;
                    if (!isAutoGroupRow && num28 > 0 && (flag15 && this.fColorizeRowLevelIndent))
                    {
                      if (rightToLeft)
                        x2 += num28;
                      else
                        x2 -= num28;
                    }
                  }
                  if (flag15 && (this.fColorizeRowLevelIndent || !flag13) && (!isAutoGroupRow && num28 > 0))
                    width1 += num28;
                  width1 += colsWidth1;
                }
                int num31;
                if (iGcolDisposition == iGColDisposition.AboveRowText)
                {
                  num31 = rowData.NormalCellHeight > rowData.Height ? rowData.Height : rowData.NormalCellHeight;
                  if (colsWidth1 > 0)
                    num17 += colsWidth1;
                  if (flag15 && !isFirstVisibleAboveRowTextCol)
                    num15 += fColData.Width;
                  else if (colsWidth1 > 0)
                    num15 += colsWidth1;
                  num17 += num27;
                  if (lastVisibleCol)
                    num17 -= width3;
                  if (isFirstVisibleAboveRowTextCol)
                  {
                    num14 = num12;
                    if (colsWidth1 < 0)
                    {
                      if (rightToLeft)
                        num14 -= colsWidth1;
                      else
                        num14 += colsWidth1;
                    }
                    num16 = num11 + num31;
                    x1_1 = !rightToLeft ? num14 - num27 : num14 + num27;
                  }
                }
                else
                  num31 = rowData.Height;
                num26 = num31 + num20;
                if (rightToLeft)
                  num12 -= colsWidth1;
                x3 = num12;
                num25 = num11 + num21;
                isFirstVisibleCol = false;
                if (colOrder >= firstSelectableColOrder)
                  flag13 = false;
              }
              if (((clipRectangle.Right <= x3 ? 0 : (clipRectangle.X < x3 + colsWidth1 ? 1 : 0)) & (flag16 ? 1 : 0)) != 0)
              {
                int num27 = rowIndex2 + num22;
                int index1 = colOrder + num23;
                int colIndex2 = this.fColIdxFromOrd[index1];
                iGrid.iGCellKindAsMerged cellKindAsMerged = this.GetCellKindAsMerged(num27, colIndex2);
                int num28 = num26 - width2;
                int num29 = colsWidth1 - width3;
                int num30 = x3;
                if (rightToLeft)
                  num30 += width3;
                bool isEnabled = enabled && this.GetPropFromStyles_Enabled(cellDataInternal1.Style, rowData.CellStyle, fColData.CellStyle);
                bool isReadOnly = this.fReadOnly || this.GetPropFromStyles_ReadOnly(cellDataInternal1.Style, rowData.CellStyle, fColData.CellStyle);
                iGControlState iGcontrolState;
                if (!isEnabled)
                  iGcontrolState = iGControlState.Disabled;
                else if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Cells && (this.fMouseData.RowIndex == num27 && this.fMouseData.ColOrder == index1))
                {
                  iGcontrolState = this.fMouseData.State;
                  if (this.fMouseData.State == iGControlState.Pressed && this.fMouseData.Button != MouseButtons.Left)
                    iGcontrolState = iGControlState.Hot;
                  if ((!this.fHotTracking || this.IsCellDropDownActive()) && iGcontrolState == iGControlState.Hot)
                    iGcontrolState = iGControlState.Normal;
                }
                else
                  iGcontrolState = iGControlState.Normal;
                bool isCurRow = num27 == this.fCurCell.RowIndex;
                bool isCurCell = isCurRow && colIndex2 == this.fCurCell.ColIndex;
                bool flag18 = this.IsCellInTextEdit(num27, colIndex2);
                bool flag19 = isCurCell && !flag18 && (!this.fRowMode || this.IsGroupRow(rowData) || this.fRowModeHasCurCell);
                bool flag20 = false;
                bool flag21 = false;
                if (!this.fRowMode)
                {
                  flag20 = this.GetCellSelectedInternal(num27, colIndex2);
                  if (flag1)
                  {
                    switch (cellKindAsMerged)
                    {
                      case iGrid.iGCellKindAsMerged.Normal:
                        flag21 = this.DoTwoCellRangesIntersect(min1, min2, max1, max2, num27, index1, num27, index1);
                        break;
                      case iGrid.iGCellKindAsMerged.MergedRoot:
                        iGCellData cellDataInternal2 = this.GetCellDataInternal(num27, colIndex2);
                        flag21 = this.DoTwoCellRangesIntersect(min1, min2, max1, max2, num27, index1, num27 + cellDataInternal2.SpanRows - 1, index1 + cellDataInternal2.SpanCols - 1);
                        break;
                    }
                  }
                }
                else if (flag1 && !isGroupRow)
                  flag21 = min1 <= num27 + cellDataInternal1.SpanRows - 1 && num27 <= max1;
                bool flag22 = !this.fRowMode && this.GetPropFromStyles_Selectable(cellDataInternal1.Style, rowData.CellStyle, fColData.CellStyle) & fColData.IncludeInSelect;
                bool flag23 = ((!rowData.Selectable || index1 < firstSelectableColOrder || index1 > lastSelectableColOrder ? (iGcolDisposition == iGColDisposition.RowText ? 1 : 0) : 1) | (isGroupRow ? 1 : 0)) != 0;
                bool flag24 = flag20 & flag22 && this.fHighlightSelCells && !flag18;
                bool flag25 = false;
                if (this.fRowMode && this.fMergedCellCountVert > 0 && (this.fSelectedRows.Count > 0 && cellKindAsMerged == iGrid.iGCellKindAsMerged.MergedRoot))
                {
                  for (int index2 = num27; index2 < num27 + cellDataInternal1.SpanRows; ++index2)
                  {
                    if (this.fSelectedRows.Contains(index2))
                    {
                      flag25 = true;
                      break;
                    }
                  }
                }
                bool flag26 = (selected | flag25) & flag23 && this.fHighlightSelCells && !flag18;
                bool flag27 = !this.fRowMode ? flag22 & flag21 : flag23 & flag21;
                int num31;
                int num32;
                if (isGroupRow)
                {
                  if (rightToLeft)
                  {
                    if (flag8 && !this.fScrollGroupRows && !this.fTreeLinesVisible)
                    {
                      num31 = this.GetGroupRowWidthWhenLevelAreaIsFrozen(firstColX, colsWidth1, rightToLeft) - width3;
                      num32 = firstColX - num31;
                    }
                    else
                    {
                      num32 = num30;
                      num31 = num29;
                    }
                    if (!flag9)
                    {
                      int num33 = num2 + vscrollBarWidth - num32;
                      if (num33 > 0)
                      {
                        num32 = num2 + vscrollBarWidth;
                        num31 -= num33;
                      }
                    }
                  }
                  else
                  {
                    if (flag8 && !this.fScrollGroupRows && !this.fTreeLinesVisible)
                    {
                      num32 = firstColX;
                      num31 = this.GetGroupRowWidthWhenLevelAreaIsFrozen(firstColX, colsWidth1, rightToLeft) - width3;
                    }
                    else
                    {
                      num32 = num30;
                      num31 = num29;
                    }
                    if (!flag9)
                    {
                      int num33 = num32 + num31 - (num2 + num3 - vscrollBarWidth);
                      if (num33 > 0)
                        num31 -= num33;
                    }
                  }
                }
                else
                {
                  num32 = num30;
                  num31 = num29;
                }
                int num34;
                int num35;
                if (width3 > 0 && !visible2)
                {
                  num34 = x3;
                  num35 = colsWidth1;
                }
                else
                {
                  num34 = num30;
                  num35 = num29;
                }
                int backgroundY = num25;
                int num36 = width2 <= 0 || visible1 ? num28 : num26;
                System.Drawing.Color backColor;
                System.Drawing.Color foreColor;
                Font font;
                this.GetUniCellFormattingNoSelected(iGGridSection.Cells, num27, colIndex2, (iGStyleBase) cellDataInternal1.Style, (iGStyleBase) rowData.CellStyle, (iGStyleBase) fColData.CellStyle, iGcontrolState, flag17 && !isGroupRow, !flag17 && !isGroupRow, flag24, flag26, out backColor, out foreColor, out font);
                this.AdjustCellForeColorWithSelColors(ref foreColor, flag19, flag24, flag26, isEnabled, drawAsFocusedState);
                iGTreeBranchState treeBranchState = !isGroupRow || !this.IsTreeColSpecified() ? (gtreeBranchStateList == null ? iGTreeBranchState.None : gtreeBranchStateList[level]) : iGTreeBranchState.None;
                int contentsX = num32;
                int contentsY = num25;
                int contentsWidth = num31;
                int contentsHeight = num28;
                int contentsInViewport = (int) this.GetPropFromStyles_FitContentsInViewport(cellDataInternal1.Style, rowData.CellStyle, fColData.CellStyle);
                int num37 = 4;
                if ((contentsInViewport & num37) != 0)
                {
                  if (contentsX < num6)
                  {
                    contentsWidth -= num6 - contentsX;
                    contentsX = num6;
                  }
                  if (contentsX + contentsWidth > num8)
                    contentsWidth = num8 - contentsX;
                }
                int num38 = 2;
                if ((contentsInViewport & num38) != 0)
                {
                  if (contentsY < num9)
                  {
                    contentsHeight -= num9 - contentsY;
                    contentsY = num9;
                  }
                  if (contentsY + contentsHeight > num10)
                    contentsHeight = num10 - contentsY;
                }
                bool stylesSingleClickEdit = this.GetPropFromStyles_SingleClickEdit(cellDataInternal1.Style, rowData.CellStyle, fColData.CellStyle);
                this.DrawUniCellContents(iGGridSection.Cells, g, controlPaint, num27, colIndex2, contentsX, contentsY, contentsWidth, contentsHeight, true, num34, backgroundY, num35, num36, cellDataInternal1.Value, cellDataInternal1.AuxValue, cellDataInternal1.ImageIndex, (iGStyleBase) cellDataInternal1.Style, (iGStyleBase) rowData.CellStyle, (iGStyleBase) fColData.CellStyle, isCurCell, isCurRow, flag19, flag24, flag26, iGcontrolState, iGcontrolState, isReadOnly, stylesSingleClickEdit, drawAsFocusedState, rowData.Type, treeButtonState, rowData.Expanded, size, treeButtonAreaWidth, treeBranchState, (Pen) null, true, true, false, backColor, foreColor, font, iGSortOrder.None, -1, false, false, false);
                this.CheckDisposeFontForPrinter(font);
                if (isAutoGroupRow && nextLevel > level && (this.GetPropFromStyles_CustomDrawFlags((iGStyleBase) cellDataInternal1.Style, (iGStyleBase) rowData.CellStyle, (iGStyleBase) fColData.CellStyle) & iGCustomDrawFlags.Background) == iGCustomDrawFlags.None)
                {
                  int width4 = this.fLevelIndent - width2;
                  if (width4 > colsWidth1 - width3)
                    width4 = colsWidth1 - width3;
                  if (width4 > 0)
                  {
                    if (rightToLeft)
                    {
                      if (levelAreaBrushes.Length > level && levelAreaBrushes[level] != null)
                        g.FillRectangle((Brush) levelAreaBrushes[level], x3 + colsWidth1 - width4, num25 + num36, width4, num26 - num36);
                    }
                    else if (levelAreaBrushes.Length > level && levelAreaBrushes[level] != null)
                      g.FillRectangle((Brush) levelAreaBrushes[level], x3, num25 + num36, width4, num26 - num36);
                  }
                }
                if (((num28 <= 0 ? 0 : (num29 > 0 ? 1 : 0)) & (flag27 ? 1 : 0)) != 0)
                  g.FillRectangle(brush, num34, num25, num35, num36);
                if (visible2 && num28 > 0)
                {
                  int num33 = !rightToLeft ? x3 + colsWidth1 : num30;
                  if (lastVisibleCol)
                  {
                    int num39 = num25 + num26;
                    if (gridLineStyleParams2.Visible)
                    {
                      int num40 = num33 - gridLineStyleParams2.PenOffset;
                      if (num39 == num25)
                        g.DrawLine(gridLineStyleParams2.Pen, num40, num25 - 1, num40, num39 + gridLineStyleParams2.PenExtra);
                      else
                        g.DrawLine(gridLineStyleParams2.Pen, num40, num25, num40, num39 + gridLineStyleParams2.PenExtra);
                    }
                  }
                  else
                  {
                    int num39 = num25 + num36;
                    if (lastVisibleFrozenCol && gridLineStyleParams6.Visible)
                    {
                      int num40 = num33 - gridLineStyleParams6.PenOffset;
                      if (num39 == num25)
                        g.DrawLine(gridLineStyleParams6.Pen, num40, num25 - 1, num40, num39 + gridLineStyleParams6.PenExtra);
                      else
                        g.DrawLine(gridLineStyleParams6.Pen, num40, num25, num40, num39 + gridLineStyleParams6.PenExtra);
                    }
                    else if (gridLineStyleParams1.Visible)
                    {
                      int num40 = num33 - gridLineStyleParams1.PenOffset;
                      if (num39 == num25)
                        g.DrawLine(gridLineStyleParams1.Pen, num40, num25 - 1, num40, num39 + gridLineStyleParams1.PenExtra);
                      else
                        g.DrawLine(gridLineStyleParams1.Pen, num40, num25, num40, num39 + gridLineStyleParams1.PenExtra);
                    }
                  }
                }
                if (visible1 && !flag14)
                {
                  bool flag28 = true;
                  if (iGcolDisposition == iGColDisposition.RowText && rowData.NormalCellHeight >= rowData.Height)
                    flag28 = false;
                  if (flag28)
                  {
                    iGrid.GridLineParams gridLineParams = (iGrid.GridLineParams) null;
                    if (rowIndex2 == this.fLastVisibleRowIndex)
                    {
                      if (gridLineStyleParams4.Visible)
                        gridLineParams = gridLineStyleParams4;
                    }
                    else if (rowIndex2 == visibleFrozenRowIndex && gridLineStyleParams7.Visible)
                      gridLineParams = gridLineStyleParams7;
                    else if (isGroupRow)
                    {
                      if (gridLineStyleParams5.Visible)
                        gridLineParams = gridLineStyleParams5;
                    }
                    else if (gridLineStyleParams3.Visible)
                      gridLineParams = gridLineStyleParams3;
                    if (gridLineParams != null)
                    {
                      int x1_2 = x3;
                      int x2_1 = x1_2 + colsWidth1 + gridLineParams.PenExtra;
                      if (flag15)
                      {
                        int num33 = level * this.fLevelIndent;
                        if (!rightToLeft)
                          x1_2 -= num33;
                        else
                          x2_1 += num33;
                      }
                      if (lastVisibleCol)
                      {
                        if (rightToLeft)
                          x1_2 += this.fVLastColGridLineStyle.Width;
                        else
                          x2_1 -= this.fVLastColGridLineStyle.Width;
                      }
                      int num39 = num25 + num26 - gridLineParams.PenOffset;
                      g.DrawLine(gridLineParams.Pen, x1_2, num39, x2_1, num39);
                    }
                  }
                }
              }
              if (iGcolDisposition == iGColDisposition.Normal || iGcolDisposition == iGColDisposition.AboveRowText)
              {
                if (num24 > 0)
                  colDrawOrder += num24;
                if (rightToLeft)
                {
                  if (num12 <= num2 && !isRowTextDrawn)
                    break;
                }
                else
                {
                  num12 += colsWidth1;
                  if (num12 > num5 && !isRowTextDrawn)
                    break;
                }
              }
              if (isGroupRow)
                break;
            }
            if (flag14 && (((!gridLineStyleParams1.Visible ? 0 : (gridLineStyleParams3.Visible ? 1 : 0)) & (isRowTextDrawn ? 1 : 0)) != 0 && x1_1 > int.MinValue && (num17 > 0 && rowData.NormalCellHeight < rowData.Height)))
            {
              if (rightToLeft)
                g.DrawLine(gridLineStyleParams3.Pen, x1_1 - num17, num16 - gridLineStyleParams3.PenOffset, x1_1 + gridLineStyleParams3.PenExtra, num16 - gridLineStyleParams3.PenOffset);
              else
                g.DrawLine(gridLineStyleParams3.Pen, x1_1, num16 - gridLineStyleParams3.PenOffset, x1_1 + num17 + gridLineStyleParams3.PenExtra, num16 - gridLineStyleParams3.PenOffset);
            }
            int num41 = 0;
            if (rowIndex2 >= this.fFrozenRowCount)
            {
              int num19 = (!isAutoGroupRow ? (level > lastAutoGroupRowLevel ? lastAutoGroupRowLevel + 1 : level) : level + 1) * this.fLevelIndent;
              if (isAutoGroupRow)
                num19 -= this.fGroupRowsGridLinesStyle.Width;
              num41 = num19 + num18;
              if (nextLevel * this.fLevelIndent <= num41)
                num41 = nextLevel * this.fLevelIndent;
            }
            int num42 = num12;
            int num43 = !rightToLeft ? num5 + 1 : num2;
            bool flag29 = gridLineStyleParams3.Visible || gridLineStyleParams7.Visible || gridLineStyleParams4.Visible || gridLineStyleParams5.Visible;
            if ((!isGroupRow | flag8) & flag29)
            {
              int num19;
              int x1_2;
              int x1_3;
              int num20;
              if (rightToLeft)
              {
                num19 = num5 + 1 - this.fFrozenColsWidth + this.fHScrollBar.Value;
                if (this.fFrozenColsWidth == 0)
                  num19 -= num41;
                x1_2 = num42;
                x1_3 = num43;
                num20 = x1_2;
                if (gridLineStyleParams2.Visible)
                  x1_2 += this.fVLastColGridLineStyle.Width;
              }
              else
              {
                x1_2 = num2 + this.fFrozenColsWidth - this.fHScrollBar.Value;
                if (this.fFrozenColsWidth == 0)
                  x1_2 += num41;
                num19 = num42;
                x1_3 = num19;
                num20 = num43;
                if (gridLineStyleParams2.Visible)
                  num19 -= this.fVLastColGridLineStyle.Width;
              }
              bool flag15 = true;
              if (rowIndex2 == this.fLastVisibleRowIndex)
              {
                if (gridLineStyleParams4.Visible)
                {
                  if (x1_2 < num19 & flag14)
                    g.DrawLine(gridLineStyleParams4.Pen, x1_2, num13 - gridLineStyleParams4.PenOffset, num19 + gridLineStyleParams4.PenExtra, num13 - gridLineStyleParams4.PenOffset);
                }
                else
                  flag15 = false;
              }
              else if (rowIndex2 == visibleFrozenRowIndex && gridLineStyleParams7.Visible)
              {
                if (x1_2 < num19 & flag14)
                  g.DrawLine(gridLineStyleParams7.Pen, x1_2, num13 - gridLineStyleParams7.PenOffset, num19 + gridLineStyleParams7.PenExtra, num13 - gridLineStyleParams7.PenOffset);
              }
              else if (isGroupRow)
              {
                if (gridLineStyleParams5.Visible)
                {
                  if (x1_2 < num19 & flag14)
                    g.DrawLine(gridLineStyleParams5.Pen, x1_2, num13 - gridLineStyleParams5.PenOffset, num19 + gridLineStyleParams5.PenExtra, num13 - gridLineStyleParams5.PenOffset);
                }
                else
                  flag15 = false;
              }
              else if (gridLineStyleParams3.Visible)
              {
                if (x1_2 < num19 & flag14)
                  g.DrawLine(gridLineStyleParams3.Pen, x1_2, num13 - gridLineStyleParams3.PenOffset, num19 + gridLineStyleParams3.PenExtra, num13 - gridLineStyleParams3.PenOffset);
              }
              else
                flag15 = false;
              if (((!(gridLineStyleParams8.Visible & flag15) ? 0 : (x1_3 < num20 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0 && num13 <= num4)
                g.DrawLine(gridLineStyleParams8.Pen, x1_3, num13 - gridLineStyleParams8.PenOffset, num20 + gridLineStyleParams8.PenExtra, num13 - gridLineStyleParams8.PenOffset);
            }
            bool flag30 = ((!this.fRowMode || x2 <= int.MinValue || !this.fFocusRect ? 0 : (this.fCurCell.RowIndex == rowIndex2 ? 1 : 0)) & (drawAsFocusedState ? 1 : 0)) != 0;
            int y2 = 0;
            int height2 = 0;
            if (flag30)
            {
              y2 = num11;
              height2 = rowData.Height;
              bool visible1;
              int width2;
              this.GetHGridLineWidthAndVisible(rowIndex2, visibleFrozenRowIndex, isGroupRow, gridLineStyleParams7.Visible, gridLineStyleParams3.Visible, gridLineStyleParams4.Visible, gridLineStyleParams1.Visible, false, out visible1, out width2);
              if (visible1)
                height2 -= width2;
              if (this.fAreCellsSrollableHorz && !flag6)
                width1 -= this.fHScrollBar.Value;
              int index = Math.Min(lastSelectableColOrder, this.GetLastVisibleColOrder());
              bool visible2;
              int width3;
              this.GetVGridLineWidthAndVisible(this.fColIdxFromOrd[index] == this.fLastVisibleColIndex | isGroupRow, index == visibleFrozenColOrder, gridLineStyleParams2.Visible, gridLineStyleParams6.Visible, gridLineStyleParams1.Visible, out visible2, out width3);
              if (visible2)
                width1 -= width3;
              if (rightToLeft)
                x2 -= width1;
              if (width1 <= 0 || height2 <= 0)
                flag30 = false;
            }
            if (flag30 & flag6)
              this.DrawFocusRect(g, x2, y2, width1, height2);
            IntPtr hdc2 = g.GetHdc();
            if (flag5)
              iGNativeMethods.SelectClipRgn(hdc2, rectRgn2);
            else
              iGNativeMethods.SelectClipRgn(hdc2, IntPtr.Zero);
            g.ReleaseHdc(hdc2);
            g.Clip = region;
            if (flag30 && !flag6)
              this.DrawFocusRect(g, x2, y2, width1, height2);
            if (((!isGroupRow ? 1 : (!flag8 ? 1 : 0)) & (flag29 ? 1 : 0)) != 0)
            {
              int num19;
              int x1_2;
              int x1_3;
              int num20;
              int x1_4;
              int num21;
              if (rightToLeft)
              {
                num19 = num5 + 1 - num41;
                x1_2 = num5 + 1 - this.fFrozenColsWidth;
                if (gridLineStyleParams2.Visible && visibleFrozenColOrder >= 0 && this.fColIdxFromOrd[visibleFrozenColOrder] == this.fLastVisibleColIndex)
                  x1_2 += this.fVLastColGridLineStyle.Width;
                x1_3 = num42;
                num20 = num19;
                x1_4 = num43;
                num21 = x1_3;
                if (gridLineStyleParams2.Visible)
                  x1_3 += this.fVLastColGridLineStyle.Width;
              }
              else
              {
                x1_2 = num2 + num41;
                num19 = num2 + this.fFrozenColsWidth;
                if (gridLineStyleParams2.Visible && visibleFrozenColOrder >= 0 && this.fColIdxFromOrd[visibleFrozenColOrder] == this.fLastVisibleColIndex)
                  num19 -= this.fVLastColGridLineStyle.Width;
                num20 = num42;
                x1_3 = x1_2;
                x1_4 = num20;
                num21 = num43;
                if (gridLineStyleParams2.Visible)
                  num20 -= this.fVLastColGridLineStyle.Width;
              }
              bool flag15 = true;
              if (rowIndex2 == this.fLastVisibleRowIndex)
              {
                if (gridLineStyleParams4.Visible)
                {
                  if (isGroupRow)
                  {
                    if (x1_3 < num20 & flag14)
                      g.DrawLine(gridLineStyleParams4.Pen, x1_3, num13 - gridLineStyleParams4.PenOffset, num20 + gridLineStyleParams4.PenExtra, num13 - gridLineStyleParams4.PenOffset);
                  }
                  else if (x1_2 < num19 & flag14)
                    g.DrawLine(gridLineStyleParams4.Pen, x1_2, num13 - gridLineStyleParams4.PenOffset, num19 + gridLineStyleParams4.PenExtra, num13 - gridLineStyleParams4.PenOffset);
                }
                else
                  flag15 = false;
              }
              else if (rowIndex2 == visibleFrozenRowIndex && gridLineStyleParams7.Visible)
              {
                if (isGroupRow)
                {
                  if (x1_3 < num20 & flag14)
                    g.DrawLine(gridLineStyleParams7.Pen, x1_3, num13 - gridLineStyleParams7.PenOffset, num20 + gridLineStyleParams7.PenExtra, num13 - gridLineStyleParams7.PenOffset);
                }
                else if (x1_2 < num19 & flag14)
                  g.DrawLine(gridLineStyleParams7.Pen, x1_2, num13 - gridLineStyleParams7.PenOffset, num19 + gridLineStyleParams7.PenExtra, num13 - gridLineStyleParams7.PenOffset);
              }
              else if (isGroupRow)
              {
                if (gridLineStyleParams5.Visible)
                {
                  if (x1_3 < num20 & flag14)
                    g.DrawLine(gridLineStyleParams5.Pen, x1_3, num13 - gridLineStyleParams5.PenOffset, num20 + gridLineStyleParams5.PenExtra, num13 - gridLineStyleParams5.PenOffset);
                }
                else
                  flag15 = false;
              }
              else if (gridLineStyleParams3.Visible)
              {
                if (x1_2 < num19 & flag14)
                  g.DrawLine(gridLineStyleParams3.Pen, x1_2, num13 - gridLineStyleParams3.PenOffset, num19 + gridLineStyleParams3.PenExtra, num13 - gridLineStyleParams3.PenOffset);
              }
              else
                flag15 = false;
              if (((!(flag15 & isGroupRow) || !gridLineStyleParams8.Visible ? 0 : (num21 > x1_4 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0)
                g.DrawLine(gridLineStyleParams8.Pen, x1_4, num13 - gridLineStyleParams8.PenOffset, num21 + gridLineStyleParams8.PenExtra, num13 - gridLineStyleParams8.PenOffset);
            }
            iGControlState state = this.fMouseData.IsEmpty ? iGControlState.Normal : (this.fMouseData.Area != iGMouseArea.RowResize || this.fMouseData.RowIndex != rowIndex2 ? (this.fMouseData.Area != iGMouseArea.RowHdr || this.fMouseData.RowIndex != rowIndex2 ? iGControlState.Normal : (this.fMouseData.State != iGControlState.Pressed ? this.fMouseData.State : iGControlState.Hot)) : (!((iGResizeRowData) this.fMouseData.Tag).IsOverRowHdr || this.IsAnyDropDownActive() ? iGControlState.Normal : iGControlState.Hot));
            this.fRowHeader.DrawRowHdrWithGridLines(g, x1, num11, rowData.Height, rowIndex2, state, this.GetRowHdrGlyph(rowIndex2), this.GetRowHdrBackColor(rowIndex2), selected, rightToLeft);
          }
          flag10 = !flag10;
          num11 = num13;
          if (num11 > num4)
            break;
        }
      }
      IntPtr hdc3 = g.GetHdc();
      if (flag4)
        iGNativeMethods.SelectClipRgn(hdc3, rectRgn1);
      else
        iGNativeMethods.SelectClipRgn(hdc3, IntPtr.Zero);
      g.ReleaseHdc(hdc3);
      g.Clip = clip;
      if (gridLineStyleParams9.Visible & flag3 && num11 < num4)
      {
        int num12;
        int x1_1;
        if (rightToLeft)
        {
          num12 = num5 + 1 - groupObjectColCount * this.fLevelIndent;
          x1_1 = num5 + 1;
        }
        else
        {
          num12 = num2 + groupObjectColCount * this.fLevelIndent;
          x1_1 = num2;
        }
        int y2 = num4 + 1;
        for (int colOrder = 0; colOrder < this.fColCount; ++colOrder)
        {
          if (colOrder == this.fFrozenColCount)
          {
            int num13;
            if (rightToLeft)
            {
              num13 = x1_1;
              x1_1 = num12;
            }
            else
              num13 = num12;
            if (gridLineStyleParams8.Visible && num13 > x1_1)
            {
              int num14 = num11 + this.fDefaultRow.Height;
              while (num14 - this.fHExtendedGridLineStyle.Width <= y2)
              {
                g.DrawLine(gridLineStyleParams8.Pen, x1_1, num14 - gridLineStyleParams8.PenOffset, num13 + gridLineStyleParams8.PenExtra, num14 - gridLineStyleParams8.PenOffset);
                num14 += this.fDefaultRow.Height;
              }
            }
            this.SetFrozenColClip(g, num12, num2, y1, num3, height1, rightToLeft);
            num12 = this.GetScrolledX(num12, rightToLeft);
            x1_1 = num12;
          }
          int colIndex = this.fColIdxFromOrd[colOrder];
          iGColData fColData = this.fColDatas[colIndex];
          if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
          {
            if (rightToLeft)
              num12 -= fColData.Width;
            else
              num12 += fColData.Width;
            if (this.GetColDisposition(colOrder, isRowTextDrawn) != iGColDisposition.AboveRowText || this.IsDrawExtraVGridLineAboveRowText(colOrder, endVisibleColOrder))
            {
              if (this.fColIdxFromOrd[colOrder] == this.fLastVisibleColIndex)
              {
                if (!gridLineStyleParams2.Visible)
                  continue;
              }
              else if ((colOrder != visibleFrozenColOrder || !gridLineStyleParams6.Visible) && !gridLineStyleParams1.Visible)
                continue;
              int num13 = num12;
              if (rightToLeft)
                num13 += this.fVExtendedGridLineStyle.Width;
              g.DrawLine(gridLineStyleParams9.Pen, num13 - gridLineStyleParams9.PenOffset, num11, num13 - gridLineStyleParams9.PenOffset, y2);
            }
          }
        }
        if (gridLineStyleParams8.Visible)
        {
          if (flag2)
          {
            if (rightToLeft)
            {
              if (num2 < num12)
                num12 = num2;
            }
            else
              num12 = num5 + 1;
          }
          int num13;
          if (rightToLeft)
          {
            num13 = x1_1;
            x1_1 = num12;
          }
          else
            num13 = num12;
          if (num13 > x1_1)
          {
            int num14 = num11 + this.fDefaultRow.Height;
            while (num14 - this.fHExtendedGridLineStyle.Width <= y2)
            {
              g.DrawLine(gridLineStyleParams8.Pen, x1_1, num14 - gridLineStyleParams8.PenOffset, num13 + gridLineStyleParams8.PenExtra, num14 - gridLineStyleParams8.PenOffset);
              num14 += this.fDefaultRow.Height;
            }
          }
        }
        int y3 = num11;
        while (y3 <= y2)
        {
          this.fRowHeader.DrawRowHdrWithGridLines(g, x1, y3, this.fDefaultRow.Height, -1, iGControlState.Normal, iGRowHdrGlyph.None, SystemColors.Control, false, rightToLeft);
          y3 += this.fDefaultRow.Height;
        }
      }
      IntPtr hdc4 = g.GetHdc();
      if (flag4)
        iGNativeMethods.SelectClipRgn(hdc4, rectRgn1);
      else
        iGNativeMethods.SelectClipRgn(hdc4, IntPtr.Zero);
      g.ReleaseHdc(hdc4);
      iGNativeMethods.DeleteObject(rectRgn1);
      iGNativeMethods.DeleteObject(rectRgn2);
      g.Clip = clip;
      if (gridLineStyleParams1.Pen != null)
        gridLineStyleParams1.Pen.Dispose();
      if (gridLineStyleParams3.Pen != null)
        gridLineStyleParams3.Pen.Dispose();
      if (gridLineStyleParams5.Pen != null)
        gridLineStyleParams5.Pen.Dispose();
      if (gridLineStyleParams2.Pen != null)
        gridLineStyleParams2.Pen.Dispose();
      if (gridLineStyleParams4.Pen != null)
        gridLineStyleParams4.Pen.Dispose();
      if (gridLineStyleParams8.Pen != null)
        gridLineStyleParams8.Pen.Dispose();
      if (gridLineStyleParams9.Pen != null)
        gridLineStyleParams9.Pen.Dispose();
      if (gridLineStyleParams6.Pen != null)
        gridLineStyleParams6.Pen.Dispose();
      if (gridLineStyleParams7.Pen != null)
        gridLineStyleParams7.Pen.Dispose();
      if (brush != null)
        brush.Dispose();
      for (int index = levelAreaBrushes.Length - 1; index >= 0; --index)
      {
        if (levelAreaBrushes[index] != null)
          levelAreaBrushes[index].Dispose();
      }
    }

    private bool GetDrawAsFocusedState()
    {
      if (!this.Focused && !this.IsTextBoxVisible() && !this.fDrawAsFocused)
        return this.IsAnyDropDownActive();
      return true;
    }

    private void GetSelectableColsInRowMode(out int firstSelectableColOrder, out int lastSelectableColOrder)
    {
      firstSelectableColOrder = -1;
      lastSelectableColOrder = -1;
      bool isRowTextDrawn = this.IsRowTextDisplayed();
      for (int colOrder = 0; colOrder < this.fColCount; ++colOrder)
      {
        iGColDisposition colDisposition = this.GetColDisposition(colOrder, isRowTextDrawn);
        switch (colDisposition)
        {
          case iGColDisposition.RowText:
          case iGColDisposition.Auxiliary:
            continue;
          default:
            if (this.fColDatas[this.fColIdxFromOrd[colOrder]].IncludeInSelect || colDisposition == iGColDisposition.AboveRowText)
            {
              if (firstSelectableColOrder < 0)
                firstSelectableColOrder = colOrder;
              lastSelectableColOrder = colOrder;
              continue;
            }
            continue;
        }
      }
    }

    private bool IsLevelAreaScrollableNoTreeCol()
    {
      if (this.fFrozenColsWidth == 0)
        return this.IsScrollableHorz();
      return false;
    }

    private bool IsGroupRowContentScrollable()
    {
      if (this.fScrollGroupRows || this.fTreeLinesVisible)
        return this.IsLevelAreaScrollableNoTreeCol();
      return false;
    }

    private void DrawLevelArea(Graphics g, int rowIndex, int level, int nextLevel, bool isGroupRow, bool isFirstVisibleCol, bool isFirstVisibleIncludedInRowSelectionCol, bool isAboveRowText, bool isFirstVisibleAboveRowTextCol, int colWithAutoLevelX, int colWithAutoLevelWidth, int rowY, int rowHeight, int normalCellHeight, iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle, bool drawAsRowSelected, bool drawAsFocused, SolidBrush[] levelAreaBrushes, int lastVisibleFrozenRowIndex, bool drawHFrozenSeparating, bool drawHorizontalLines, bool drawHorizontalLastRow, bool drawVerticalLines, iGrid.GridLineParams hGridLinesGroupRow, bool rightToLeft, List<iGTreeBranchState> treeBranchData, bool isEven, bool isOdd)
    {
      Region region1 = (Region) null;
      Region region2 = (Region) null;
      if (colWithAutoLevelWidth < level * this.fLevelIndent)
      {
        if (colWithAutoLevelWidth <= 0)
          return;
        region1 = g.Clip;
        region2 = region1.Clone();
        region2.Intersect(new Rectangle(colWithAutoLevelX, 0, colWithAutoLevelWidth, this.Height));
        g.Clip = region2;
      }
      int num1 = !hGridLinesGroupRow.Visible ? 0 : this.fGroupRowsGridLinesStyle.Width;
      bool aboveRowText = ((isGroupRow ? 0 : (!isFirstVisibleAboveRowTextCol ? 1 : 0)) & (isAboveRowText ? 1 : 0)) != 0;
      bool visible;
      int width1;
      this.GetHGridLineWidthAndVisible(rowIndex, lastVisibleFrozenRowIndex, isGroupRow, drawHFrozenSeparating, drawHorizontalLines, drawHorizontalLastRow, drawVerticalLines, aboveRowText, out visible, out width1);
      Size treeButtonFullSize = this.GetTreeButtonFullSize();
      System.Drawing.Color selRowsBackColor = this.GetSelRowsBackColor(drawAsFocused);
      int num2 = 0;
      for (int partIndex = 0; partIndex < level; ++partIndex)
      {
        int num3 = !rightToLeft ? colWithAutoLevelX + num2 : colWithAutoLevelX + colWithAutoLevelWidth - num2 - this.fLevelIndent;
        int x1 = num3;
        if (rightToLeft)
          x1 += num1;
        int width2 = this.fLevelIndent - num1;
        int height = !aboveRowText ? rowHeight : Math.Min(normalCellHeight, rowHeight);
        if (nextLevel <= partIndex & visible)
          height -= width1;
        bool flag;
        if (this.DoCustomDrawLevelIndentPart(rowIndex, partIndex, g, new Rectangle(num3, rowY, this.fLevelIndent, height)))
        {
          if (partIndex < levelAreaBrushes.Length && levelAreaBrushes[partIndex] != null)
          {
            if (!levelAreaBrushes[partIndex].Color.IsEmpty)
              g.FillRectangle((Brush) levelAreaBrushes[partIndex], x1, rowY, width2, height);
            flag = true;
          }
          else
          {
            if (this.fColorizeRowLevelIndent || !isFirstVisibleCol)
            {
              System.Drawing.Color dynamicNoSelected = this.GetUniCellBackColorNoDynamicNoSelected(iGGridSection.Cells, (iGStyleBase) cellStyle, (iGStyleBase) rowStyle, (iGStyleBase) colStyle, iGControlState.Normal, isEven, isOdd);
              if (!dynamicNoSelected.IsEmpty)
              {
                using (Brush brush = (Brush) new SolidBrush(dynamicNoSelected))
                  g.FillRectangle(brush, num3, rowY, this.fLevelIndent, height);
              }
            }
            if ((this.fColorizeRowLevelIndent || !isFirstVisibleIncludedInRowSelectionCol) && drawAsRowSelected)
            {
              using (Brush brush = (Brush) new SolidBrush(selRowsBackColor))
                g.FillRectangle(brush, num3, rowY, this.fLevelIndent, height);
            }
            flag = false;
          }
        }
        else
          flag = false;
        if (hGridLinesGroupRow.Visible & flag)
        {
          if (rightToLeft)
            g.DrawLine(hGridLinesGroupRow.Pen, x1 - hGridLinesGroupRow.PenOffset, rowY, x1 - hGridLinesGroupRow.PenOffset, rowY + rowHeight + hGridLinesGroupRow.PenExtra);
          else
            g.DrawLine(hGridLinesGroupRow.Pen, x1 + this.fLevelIndent - hGridLinesGroupRow.PenOffset, rowY, x1 + this.fLevelIndent - hGridLinesGroupRow.PenOffset, rowY + rowHeight + hGridLinesGroupRow.PenExtra);
        }
        if (treeBranchData != null && treeBranchData[partIndex] == iGTreeBranchState.Full)
        {
          int x2;
          int width3;
          this.GetTreeButtonXCoordinates(treeButtonFullSize.Width, num3, this.fLevelIndent, rightToLeft, out x2, out width3);
          int num4 = x2 + width3 / 2;
          int y2 = !aboveRowText ? rowY + rowHeight : rowY + Math.Min(normalCellHeight, rowHeight);
          this.DrawTreeBranch(g, num4, rowY, num4, y2, (Pen) null);
        }
        num2 += this.fLevelIndent;
      }
      if (region1 == null)
        return;
      g.Clip = region1;
      region2.Dispose();
      region1.Dispose();
    }

    private void SetLevelBrush(int rowIndex, int groupColIndex, int level, ref SolidBrush[] levelAreaBrushes)
    {
      System.Drawing.Color backColorNoSelected = this.GetUniCellBackColorNoSelected(iGGridSection.Cells, rowIndex, groupColIndex, (iGStyleBase) this.GetCellDataInternal(rowIndex, groupColIndex).Style, (iGStyleBase) this.GetRowDataInternal(rowIndex).CellStyle, (iGStyleBase) this.GetColDataInternal(groupColIndex).CellStyle, iGControlState.Normal, false, false, false, false);
      if (levelAreaBrushes.Length < level + 1)
        levelAreaBrushes = (SolidBrush[]) iGArrayManager.ExtendArray((Array) levelAreaBrushes, typeof (SolidBrush), levelAreaBrushes.Length, level - levelAreaBrushes.Length + 1, levelAreaBrushes.Length, true);
      if (levelAreaBrushes[level] != null)
        levelAreaBrushes[level].Dispose();
      levelAreaBrushes[level] = new SolidBrush(backColorNoSelected);
    }

    private void FillLevelAreaBrushes(int rowIndex, bool isAutoGroupRow, int level, ref SolidBrush[] levelAreaBrushes, ref int lastAutoGroupRowLevel)
    {
      if (level == 0)
        return;
      bool flag = false;
      for (int rowIndex1 = rowIndex - 1; rowIndex1 >= 0; --rowIndex1)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
        if (rowDataInternal.Type == iGRowType.AutoGroupRow)
        {
          if (rowDataInternal.Level < level)
          {
            if (!flag)
            {
              if (!isAutoGroupRow)
                lastAutoGroupRowLevel = rowDataInternal.Level;
              flag = true;
            }
            level = rowDataInternal.Level;
            this.SetLevelBrush(rowIndex1, 0, level, ref levelAreaBrushes);
            if (level == 0)
              break;
          }
        }
        else if (rowDataInternal.Level < level)
        {
          level = rowDataInternal.Level;
          if (level == 0)
            break;
        }
      }
    }

    private int GetGroupRowWidthWhenLevelAreaIsFrozen(int startX, int colsWidth, bool rightToLeft)
    {
      if (rightToLeft)
        return colsWidth - (this.GetScrolledX(startX, rightToLeft) - startX);
      return colsWidth - (startX - this.GetScrolledX(startX, rightToLeft));
    }

    private int GetLastVisibleColIndex()
    {
      int lastVisibleColOrder = this.GetLastVisibleColOrder();
      if (lastVisibleColOrder >= 0)
        return this.fColIdxFromOrd[lastVisibleColOrder];
      return -1;
    }

    private int GetLastVisibleColOrder()
    {
      for (int colDrawOrder = this.fColCount - 1; colDrawOrder >= 0; --colDrawOrder)
      {
        int colOrder = this.DrawColOrderToColOrder(colDrawOrder);
        if (this.IsColVisible(this.fColIdxFromOrd[colOrder]))
          return colOrder;
      }
      return -1;
    }

    private int GetLastVisibleRowIndex(int startSearchFromRowIndex)
    {
      return this.GetLastVisibleRowIndex(startSearchFromRowIndex, 0);
    }

    private int GetLastVisibleRowIndex(int startSearchFromRowIndex, int searchTillRowIndex)
    {
      if (startSearchFromRowIndex == -1)
        startSearchFromRowIndex = this.fRowCount - 1;
      for (int rowIndex = startSearchFromRowIndex; rowIndex >= searchTillRowIndex; --rowIndex)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          return rowIndex;
      }
      return -1;
    }

    private int GetCellWidthFromColWidth(bool isFirstVisibleCol, int colIndex, int colDataWidth, int rowIndex, int rowDataLevel, int groupObjectColCount)
    {
      if (!(!this.IsTreeColSpecified() ? isFirstVisibleCol : this.IsTreeCol(colIndex)))
        return colDataWidth;
      if (rowIndex < this.fFrozenRowCount)
        return colDataWidth + groupObjectColCount * this.fLevelIndent;
      return colDataWidth + (groupObjectColCount - rowDataLevel) * this.fLevelIndent;
    }

    /// <summary>Returns the size of the tree button.</summary>
    /// <returns>The size of the tree button.</returns>
    public Size GetTreeButtonFullSize()
    {
      if (this.fCustomControlPaint != null && (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.TreeButton) == iGControlPaintFunctions.TreeButton)
        return this.fCustomControlPaint.GetTreeButtonSize();
      return this.fCellControlPaintStyle.ControlPaint.GetTreeButtonSize();
    }

    /// <summary>Returns the indent of the tree button from the left edge of cell.</summary>
    /// <returns>The indent of the tree button from the left edge of cell.</returns>
    public static int GetTreeButtonIndent()
    {
      return 3;
    }

    private int GetTreeButtonAreaWidth()
    {
      return this.GetTreeButtonAreaWidth(this.GetTreeButtonFullSize());
    }

    private int GetTreeButtonAreaWidth(Size buttonSize)
    {
      return buttonSize.Width + 6;
    }

    private int GetLastVisibleFrozenColOrder()
    {
      for (int index = Math.Min(this.fFrozenColCount - 1, this.fColCount - 1); index >= 0; --index)
      {
        if (this.IsColVisible(this.fColIdxFromOrd[index]))
          return index;
      }
      return -1;
    }

    private int GetLastVisibleFrozenRowIndex()
    {
      for (int rowIndex = Math.Min(this.fFrozenRowCount - 1, this.fRowCount - 1); rowIndex >= 0; --rowIndex)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          return rowIndex;
      }
      return -1;
    }

    private int GetFirstColX(bool rightToLeft)
    {
      if (rightToLeft)
        return this.Width - this.GetBorderSize() - this.fRowHeader.EffectiveWidth();
      return this.GetBorderSize() + this.fRowHeader.EffectiveWidth();
    }

    private int GetFirstColX(bool rightToLeft, int colsAreaX, int colsAreaWidth)
    {
      if (rightToLeft)
        return colsAreaX + colsAreaWidth;
      return colsAreaX;
    }

    private void SetFrozenColClip(Graphics g, int lastFrozenColRightPlusOne, int x, int y, int width, int height, bool rightToLeft)
    {
      if (!this.IsScrollableHorz())
        return;
      if (rightToLeft)
      {
        width = lastFrozenColRightPlusOne - x;
      }
      else
      {
        width -= lastFrozenColRightPlusOne - x;
        x = lastFrozenColRightPlusOne;
      }
      g.SetClip(new Rectangle(x, y, width, height), CombineMode.Intersect);
      IntPtr hdc = g.GetHdc();
      iGNativeMethods.IntersectClipRect(hdc, x, y, x + width, y + height);
      g.ReleaseHdc(hdc);
    }

    private int GetScrolledX(int x, bool rightToLeft)
    {
      if (!this.IsScrollableHorz())
        return x;
      if (rightToLeft)
        return x + this.fHScrollBar.Value;
      return x - this.fHScrollBar.Value;
    }

    private void FillCell(Graphics g, int x, int y, int width, int height, System.Drawing.Color backColor)
    {
      if (width <= 0 || height <= 0 || backColor.IsEmpty)
        return;
      using (SolidBrush solidBrush = new SolidBrush(backColor))
        g.FillRectangle((Brush) solidBrush, x, y, width, height);
    }

    /// <summary>Draws the contents of the specified row header on the specified graphics surface.</summary>
    /// <param name="g">The graphics surface to drawn on.</param>
    /// <param name="rowIndex">The index of the row to be drawn.</param>
    /// <param name="x">The X-coordinate of the row header area with the grid lines area excluded.</param>
    /// <param name="y">The Y-coordinate of the row header area with the grid lines area excluded.</param>
    /// <param name="width">The width of the row header area with the grid lines area excluded.</param>
    /// <param name="height">The height of the row header area with the grid lines area excluded.</param>
    /// <param name="drawBackground">Indicates whether to draw the row header background. This parameter does not affect the system style background.</param>
    /// <param name="drawSystemBackground">Indicates whether to draw the system background (XP, 3D or Flat).</param>
    /// <param name="adjustForPrinter">Indicates whether to adjust drawing for printer. If you pass True to this parameter, the grid will not use XP visual styles (as they are not drawn correctly in different DPIs), will scale images according to the DPI etc.</param>
    public void DrawRowHdrContents(Graphics g, int rowIndex, int x, int y, int width, int height, bool drawBackground, bool drawSystemBackground, bool adjustForPrinter)
    {
      if (g == null)
        throw new ArgumentNullException(nameof (g));
      this.CheckRowIndex(rowIndex);
      if (width < 0)
        throw new ArgumentOutOfRangeException(nameof (width), "Width cannot be negative");
      if (height < 0)
        throw new ArgumentOutOfRangeException(nameof (height), "Height cannot be negative");
      this.fAdjustDrawingForPrinter = adjustForPrinter;
      this.fDisplayVerticalResolution = this.CreateGraphics().DpiY;
      try
      {
        this.fRowHeader.DrawRowHdrWithoutGridLines(g, x, y, width, height, rowIndex, iGControlState.Normal, iGRowHdrGlyph.None, this.GetRowHdrBackColor(rowIndex), false, drawBackground, drawSystemBackground, this.RightToLeft == RightToLeft.Yes);
      }
      finally
      {
        this.fAdjustDrawingForPrinter = false;
      }
    }

    /// <summary>Draws the contents of the specified cell on the specified graphics surface.</summary>
    /// <param name="g">The graphics surface to drawn on.</param>
    /// <param name="rowIndex">The row index of the cell to be drawn.</param>
    /// <param name="colIndex">The column index of the cell to be drawn.</param>
    /// <param name="x">The X-coordinate of the cell area with the grid lines area excluded.</param>
    /// <param name="y">The Y-coordinate of the cell area with the grid lines area excluded.</param>
    /// <param name="width">The width of the cell area with the grid lines area excluded.</param>
    /// <param name="height">The height of the cell area with the grid lines area excluded.</param>
    /// <param name="drawBackground">Indicates whether to draw the cell background.</param>
    /// <param name="backgroundX">The X-coordinate of the cell background.</param>
    /// <param name="backgroundY">The Y-coordinate of the cell background.</param>
    /// <param name="backgroundWidth">The width of the cell background.</param>
    /// <param name="backgroundHeight">The height of the cell background.</param>
    /// <param name="isEven">Indicates whether the cell in an even row.</param>
    /// <param name="isOdd">Indicates whether the cell in an odd row.</param>
    /// <param name="drawComboButton">Indicates whether to draw the combo button if it is present in the cell.</param>
    /// <param name="drawEllipsisButton">Indicates whether to draw the ellipsis button if it is present in the cell.</param>
    /// <param name="drawTreeButton">Indicates whether to draw the tree button (plus/minus sign in the group row) if it is present in the cell.</param>
    /// <param name="treeBranchState">The information about the tree lines.</param>
    /// <param name="forceTreeButtonExpanded">Indicates whether to draw the tree button in the expanded state regardless of its real state.</param>
    /// <param name="customTreeLinesPen">A <see cref="T:System.Drawing.Pen" /> object used to draw tree lines. If not specified, iGrid draws tree lines using the corresponding settings from the iGrid <see cref="P:TenTec.Windows.iGridLib.iGrid.TreeLines" /> object property.</param>
    /// <param name="plainCheckBox">Indicates whether to force to draw the check box in the cell (if it present there) flat with a single-width border regardless of its real appearance.</param>
    /// <param name="adjustForPrinter">Indicates whether to adjust drawing for printer. If you pass True to this parameter, the grid will not use XP visual styles (as they are not drawn correctly in different DPIs), will scale images according to the DPI etc.</param>
    public void DrawCellContents(Graphics g, int rowIndex, int colIndex, int x, int y, int width, int height, bool drawBackground, int backgroundX, int backgroundY, int backgroundWidth, int backgroundHeight, bool isEven, bool isOdd, bool drawComboButton, bool drawEllipsisButton, bool drawTreeButton, iGTreeBranchState treeBranchState, bool forceTreeButtonExpanded, Pen customTreeLinesPen, bool plainCheckBox, bool adjustForPrinter)
    {
      ++colIndex;
      if (g == null)
        throw new ArgumentNullException(nameof (g));
      this.CheckCellIndices(rowIndex, colIndex);
      if (width < 0)
        throw new ArgumentOutOfRangeException(nameof (width), "Width cannot be negative");
      if (height < 0)
        throw new ArgumentOutOfRangeException(nameof (height), "Height cannot be negative");
      if (drawBackground)
      {
        if (backgroundWidth < 0)
          throw new ArgumentOutOfRangeException(nameof (backgroundWidth), "The background width cannot be negative");
        if (backgroundHeight < 0)
          throw new ArgumentOutOfRangeException(nameof (backgroundHeight), "The background height cannot be negative");
      }
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      iGCellStyle cellStyle = this.GetColData(colIndex).CellStyle;
      iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
      bool useXp = this.fCellControlPaintStyle.UseXP;
      if (adjustForPrinter)
        this.fCellControlPaintStyle.UseXP = false;
      IiGControlPaint controlPaint = (IiGControlPaint) this.fCellControlPaintStyle.ControlPaint;
      Size size = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.TreeButton) != iGControlPaintFunctions.TreeButton ? controlPaint.GetTreeButtonSize() : this.fCustomControlPaint.GetTreeButtonSize();
      int treeButtonAreaWidth = this.GetTreeButtonAreaWidth(size);
      bool flag = !this.IsTreeColSpecified() ? this.IsFirstVisibleCol(this.GetColOrder(colIndex)) : this.IsTreeCol(colIndex);
      iGTreeButtonState treeButtonState = !drawTreeButton || !this.IsGroupRow(rowDataInternal) && !(colIndex >= 1 & flag) ? iGTreeButtonState.Absent : rowDataInternal.TreeButton;
      this.fAdjustDrawingForPrinter = adjustForPrinter;
      this.fDisplayVerticalResolution = this.CreateGraphics().DpiY;
      iGControlState iGcontrolState = (!this.Enabled ? 0 : (this.GetPropFromStyles_Enabled(cellDataInternal.Style, rowDataInternal.CellStyle, cellStyle) ? 1 : 0)) != 0 ? iGControlState.Normal : iGControlState.Disabled;
      System.Drawing.Color backColor;
      System.Drawing.Color foreColor;
      Font font;
      this.GetUniCellFormattingNoSelected(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle, iGcontrolState, isEven, isOdd, false, false, out backColor, out foreColor, out font);
      try
      {
        this.DrawUniCellContents(iGGridSection.Cells, g, controlPaint, rowIndex, colIndex, x, y, width, height, drawBackground, backgroundX, backgroundY, backgroundWidth, backgroundHeight, cellDataInternal.Value, cellDataInternal.AuxValue, cellDataInternal.ImageIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle, false, false, false, false, false, iGcontrolState, iGcontrolState, this.GetPropFromStyles_ReadOnly(cellDataInternal.Style, rowDataInternal.CellStyle, cellStyle), this.GetPropFromStyles_SingleClickEdit(cellDataInternal.Style, rowDataInternal.CellStyle, cellStyle), true, rowDataInternal.Type, treeButtonState, rowDataInternal.Expanded | forceTreeButtonExpanded, size, treeButtonAreaWidth, treeBranchState, customTreeLinesPen, drawComboButton, drawEllipsisButton, plainCheckBox, backColor, foreColor, font, iGSortOrder.None, -1, false, false, false);
      }
      finally
      {
        this.CheckDisposeFontForPrinter(font);
        this.fAdjustDrawingForPrinter = false;
        if (adjustForPrinter)
          this.fCellControlPaintStyle.UseXP = useXp;
      }
    }

    private void DrawUniCellContents(iGGridSection gridSection, Graphics g, IiGControlPaint controlPaint, int rowIndex, int colIndex, int contentsX, int contentsY, int contentsWidth, int contentsHeight, bool drawBackground, int backgroundX, int backgroundY, int backgroundWidth, int backgroundHeight, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, bool isCurCell, bool isCurRow, bool drawCellAsCurrent, bool drawCellAsSelected, bool drawCellAsRowSelected, iGControlState cellState, iGControlState cellButtonState, bool isReadOnly, bool singleClickEdit, bool drawAsFocused, iGRowType rowType, iGTreeButtonState treeButtonState, bool isTreeButtonExpanded, Size fullTreeButtonSize, int treeButtonAreaWidth, iGTreeBranchState treeBranchState, Pen customTreeLinesPen, bool drawComboButton, bool drawEllipsisButton, bool plainCheckBox, System.Drawing.Color cellBackColor, System.Drawing.Color cellForeColor, Font cellFont, iGSortOrder headerSortOrder, int headerSortIndex, bool headerForceDrawSortInfo, bool headerPlainSortInfo, bool headerForceSortAreaRightAlign)
    {
      if (backgroundWidth <= 0 || backgroundHeight <= 0)
        return;
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int num1 = backgroundX != int.MinValue ? backgroundX : (!rightToLeft ? contentsX : contentsX + (contentsWidth - backgroundWidth));
      System.Drawing.Color selRowsBackColor = this.GetSelRowsBackColor(drawAsFocused);
      System.Drawing.Color color1 = !drawAsFocused ? this.fSelCellsBackColorNoFocus : this.fSelCellsBackColor;
      System.Drawing.Color color2 = !drawAsFocused ? this.fCurCellBackColorNoFocus : this.fCurCellBackColor;
      iGCellDrawType cellType;
      iGCellDrawTypeFlags cellTypeFlags;
      if (gridSection == iGGridSection.Footer)
      {
        cellType = iGCellDrawType.Text;
        cellTypeFlags = iGCellDrawTypeFlags.None;
      }
      else
      {
        cellType = this.GetPropFromStyles_DrawType(cellStyle, rowStyle, colStyle);
        cellTypeFlags = this.GetPropFromStyles_DrawTypeFlags(cellStyle, rowStyle, colStyle);
      }
      iGCellDrawFlags fromStylesDrawFlags = this.GetPropFromStyles_DrawFlags(cellStyle, rowStyle, colStyle);
      iGCustomDrawFlags stylesCustomDrawFlags = this.GetPropFromStyles_CustomDrawFlags(cellStyle, rowStyle, colStyle);
      if (drawBackground)
      {
        if ((stylesCustomDrawFlags & iGCustomDrawFlags.Background) != iGCustomDrawFlags.None)
        {
          Rectangle bounds = new Rectangle(num1, backgroundY, backgroundWidth, backgroundHeight);
          switch (gridSection)
          {
            case iGGridSection.Header:
              this.OnCustomDrawColHdrBackground(new iGCustomDrawColHdrEventArgs(rowIndex, colIndex - 1, g, bounds, cellState));
              break;
            case iGGridSection.Cells:
              this.OnCustomDrawCellBackground(new iGCustomDrawCellEventArgs(rowIndex, colIndex - 1, g, bounds, cellState, drawCellAsSelected, drawCellAsRowSelected));
              break;
            case iGGridSection.Footer:
              this.OnCustomDrawFooterCellBackground(new iGCustomDrawFooterCellEventArgs(rowIndex, colIndex - 1, g, bounds));
              break;
          }
        }
        else
          this.FillCell(g, num1, backgroundY, backgroundWidth, backgroundHeight, cellBackColor);
      }
      if (contentsWidth > 0 && contentsHeight > 0)
      {
        iGIndent iGindent = new iGIndent();
        ContentAlignment stylesImageAlign = this.GetPropFromStyles_ImageAlign(cellStyle, rowStyle, colStyle);
        StringFormat cellStringFormat = this.GetUniCellStringFormat(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle);
        int num2 = contentsX;
        int num3 = contentsWidth;
        bool flag1 = gridSection == iGGridSection.Header || (this.fShowControlsInAllCells || (this.fRowMode ? (isCurRow ? 1 : 0) : (isCurCell ? 1 : 0)) != 0) && !isReadOnly;
        IiGDropDownControl cellDropDownControl = this.GetUniCellDropDownControl(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle, false);
        if (gridSection == iGGridSection.Header && cellState == iGControlState.Pressed)
        {
          ++num2;
          ++contentsY;
        }
        Rectangle rectangle1 = Rectangle.Empty;
        if (treeButtonState == iGTreeButtonState.Visible || treeButtonState == iGTreeButtonState.Hidden)
        {
          rectangle1 = this.GetTreeButtonBounds(contentsX, contentsY, contentsWidth, contentsHeight, rightToLeft);
          if (rightToLeft)
          {
            if (treeButtonAreaWidth > num3)
            {
              num2 = rectangle1.X + 3;
              num3 = 0;
            }
            else
              num3 -= treeButtonAreaWidth;
          }
          else if (treeButtonAreaWidth > num3)
          {
            num2 = rectangle1.Right + 3;
            num3 = 0;
          }
          else
          {
            num2 += treeButtonAreaWidth;
            num3 -= treeButtonAreaWidth;
          }
        }
        bool flag2 = (uint) (cellTypeFlags & iGCellDrawTypeFlags.HasEllipsisButton) > 0U & flag1 & drawEllipsisButton;
        Rectangle buttonBounds1;
        if (flag2)
        {
          buttonBounds1 = this.GetEllipsisRectangle(num2, contentsY, num3, contentsHeight, rightToLeft);
          if (rightToLeft)
          {
            num3 -= buttonBounds1.X - num2 + buttonBounds1.Width;
            num2 = buttonBounds1.X + buttonBounds1.Width;
          }
          else
            num3 -= num2 + num3 - buttonBounds1.X;
        }
        else
          buttonBounds1 = Rectangle.Empty;
        int num4 = !(flag1 & drawComboButton) ? 0 : (this.ShouldDrawComboButton(cellType, cellTypeFlags, cellDropDownControl) ? 1 : 0);
        Rectangle buttonBounds2;
        if (num4 != 0)
        {
          buttonBounds2 = this.GetComboRectangle(num2, contentsY, num3, contentsHeight, rightToLeft);
          if (rightToLeft)
          {
            num3 -= buttonBounds2.X - num2 + buttonBounds2.Width;
            num2 = buttonBounds2.X + buttonBounds2.Width;
          }
          else
            num3 -= num2 + num3 - buttonBounds2.X;
        }
        else
          buttonBounds2 = Rectangle.Empty;
        string text = (string) null;
        Size textSize = Size.Empty;
        int arrowHeight;
        int arrowWidth = arrowHeight = 0;
        int minValue;
        int num5 = minValue = int.MinValue;
        int num6 = minValue;
        int y = minValue;
        int x = minValue;
        if (gridSection == iGGridSection.Header)
        {
          int sortAreaWidth = this.GetSortAreaWidth(g, headerSortIndex, controlPaint, cellFont, cellStyle as iGColHdrStyle, colStyle as iGColHdrStyle, headerForceDrawSortInfo, headerPlainSortInfo, out arrowWidth, out arrowHeight, out textSize, out text);
          if (sortAreaWidth > 0)
          {
            StringAlignment stylesTextHalign = this.GetPropFromStyles_TextHAlign(cellStyle, rowStyle, colStyle);
            int num7 = (stylesImageAlign != ContentAlignment.TopLeft && stylesImageAlign != ContentAlignment.MiddleLeft && stylesImageAlign != ContentAlignment.BottomLeft || (stylesTextHalign != StringAlignment.Near || headerForceSortAreaRightAlign) ? 0 : ((cellStringFormat.FormatFlags & StringFormatFlags.DirectionRightToLeft) == (StringFormatFlags) 0 ? 1 : 0)) == 0 ? contentsWidth : this.GetUniCellContentsWidth(gridSection, g, cellFont, contentsHeight, num3 - sortAreaWidth, cellDataValue, cellDataAuxValue, cellDataImageIndex, rowIndex, colIndex, cellStyle, rowStyle, colStyle, false);
            if (!rightToLeft)
            {
              x = sortAreaWidth + num7 < num3 ? num2 + num7 + 3 : num2 + num3 - 3 - textSize.Width - arrowWidth;
              num6 = x + arrowWidth;
            }
            else
            {
              if (sortAreaWidth + num7 >= num3)
              {
                num6 = num2 + 3;
                x = num6 + textSize.Width;
              }
              else
              {
                x = num2 + num3 - num7 - 3 - arrowWidth;
                num6 = x - textSize.Width;
              }
              num2 += sortAreaWidth;
            }
            y = contentsY + (contentsHeight - arrowHeight) / 2;
            num5 = contentsY + (contentsHeight - textSize.Height) / 2;
            num3 -= sortAreaWidth;
          }
        }
        bool flag3 = cellType == iGCellDrawType.Check;
        Rectangle rectangle2;
        if (flag3)
        {
          rectangle2 = new Rectangle(num2, contentsY, num3, contentsHeight);
          num2 = contentsX;
          num3 = 0;
        }
        else
          rectangle2 = Rectangle.Empty;
        if (drawBackground)
        {
          if (drawCellAsRowSelected)
            this.FillCellPartsWithSemitransparentSelColor(g, selRowsBackColor, num1, backgroundY, backgroundWidth, backgroundHeight, num2, num3, (int) selRowsBackColor.A == (int) byte.MaxValue || (this.fHighlightSelCellItems & iGHighlightSelCellItems.Controls) != iGHighlightSelCellItems.Controls, (int) selRowsBackColor.A == (int) byte.MaxValue || (this.fHighlightSelCellItems & iGHighlightSelCellItems.Images) != iGHighlightSelCellItems.Images, false);
          if (drawCellAsSelected)
            this.FillCellPartsWithSemitransparentSelColor(g, color1, num1, backgroundY, backgroundWidth, backgroundHeight, num2, num3, (int) color1.A == (int) byte.MaxValue || (this.fHighlightSelCellItems & iGHighlightSelCellItems.Controls) != iGHighlightSelCellItems.Controls, (int) color1.A == (int) byte.MaxValue || (this.fHighlightSelCellItems & iGHighlightSelCellItems.Images) != iGHighlightSelCellItems.Images, false);
          if (drawCellAsCurrent)
            this.FillCellPartsWithSemitransparentSelColor(g, color2, num1, backgroundY, backgroundWidth, backgroundHeight, num2, num3, (int) color2.A == (int) byte.MaxValue || (this.fHighlightSelCellItems & iGHighlightSelCellItems.Controls) != iGHighlightSelCellItems.Controls, (int) color2.A == (int) byte.MaxValue || (this.fHighlightSelCellItems & iGHighlightSelCellItems.Images) != iGHighlightSelCellItems.Images, false);
        }
        if ((treeButtonState == iGTreeButtonState.Visible || treeButtonState == iGTreeButtonState.Hidden) && (treeBranchState != iGTreeBranchState.None && treeBranchState != iGTreeBranchState.NotSpecified))
        {
          int num7;
          int x2;
          bool flag4;
          if (rightToLeft)
          {
            num7 = rectangle1.X + rectangle1.Width - fullTreeButtonSize.Width / 2 - 1;
            x2 = rectangle1.X - 3;
            if (x2 < contentsX)
              x2 = contentsX;
            flag4 = num7 >= contentsX;
          }
          else
          {
            num7 = rectangle1.X + fullTreeButtonSize.Width / 2;
            x2 = rectangle1.X + fullTreeButtonSize.Width + 3;
            if (x2 >= contentsX + contentsWidth)
              x2 = contentsX + contentsWidth - 1;
            flag4 = num7 < contentsX + contentsWidth;
          }
          if (flag4)
          {
            if (treeBranchState == iGTreeBranchState.Up || treeBranchState == iGTreeBranchState.Full)
              this.DrawTreeBranch(g, num7, contentsY, num7, rectangle1.Y + rectangle1.Height / 2, customTreeLinesPen);
            if (treeBranchState == iGTreeBranchState.Down || treeBranchState == iGTreeBranchState.Full)
              this.DrawTreeBranch(g, num7, rectangle1.Y + rectangle1.Height / 2, num7, contentsY + contentsHeight, customTreeLinesPen);
            this.DrawTreeBranch(g, num7, rectangle1.Y + rectangle1.Height / 2, x2, rectangle1.Y + rectangle1.Height / 2, customTreeLinesPen);
          }
        }
        if (treeButtonState == iGTreeButtonState.Visible)
        {
          if (this.fCustomControlPaint != null && (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.TreeButton) == iGControlPaintFunctions.TreeButton)
            this.fCustomControlPaint.DrawTreeButton(g, rectangle1.X, rectangle1.Y, rectangle1.Width, rectangle1.Height, isTreeButtonExpanded);
          else
            controlPaint.DrawTreeButton(g, rectangle1.X, rectangle1.Y, rectangle1.Width, rectangle1.Height, isTreeButtonExpanded);
        }
        if (flag2)
          this.DrawEllipsis(g, controlPaint, rowIndex, colIndex, cellButtonState, isReadOnly, singleClickEdit, buttonBounds1, rightToLeft);
        if (num4 != 0)
          this.DrawCombo(gridSection, g, controlPaint, rowIndex, colIndex, isCurCell, (cellTypeFlags & iGCellDrawTypeFlags.NoTextEdit) != iGCellDrawTypeFlags.NoTextEdit, singleClickEdit, cellButtonState, isReadOnly, buttonBounds2);
        if ((stylesCustomDrawFlags & iGCustomDrawFlags.Foreground) == iGCustomDrawFlags.None)
        {
          iGIndent stylesContentIndent = this.GetPropFromStyles_ContentIndent(cellStyle, rowStyle, colStyle);
          Size imageSize = Size.Empty;
          iGrid.iGCellContents contentsInternal = this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle, cellType, cellTypeFlags, fromStylesDrawFlags, cellDropDownControl);
          if ((cellTypeFlags & iGCellDrawTypeFlags.Password) != iGCellDrawTypeFlags.None)
            contentsInternal.Text = new string(this.fPasswordCharEffective, contentsInternal.Text.Length);
          if (flag3)
            this.DrawCheck(g, controlPaint, contentsInternal.CheckState, this.GetPropFromStyles_DrawTypeFlags(cellStyle, rowStyle, colStyle), cellState, isReadOnly, singleClickEdit, isCurCell, rectangle2.X, rectangle2.Y, rectangle2.Width, rectangle2.Height, stylesImageAlign, stylesContentIndent, plainCheckBox, rightToLeft);
          else if (this.IsCellImageReallyDrawn(contentsInternal))
          {
            imageSize = contentsInternal.ImageList.ImageSize;
            bool hot = gridSection == iGGridSection.Header && (cellState == iGControlState.Hot || cellState == iGControlState.Pressed);
            this.DrawImage(g, contentsInternal.ImageList, contentsInternal.ImageIndex, num2, contentsY, num3, contentsHeight, stylesImageAlign, stylesContentIndent, rightToLeft, hot);
          }
          if (drawBackground && this.fHighlightSelCellItems != iGHighlightSelCellItems.None)
          {
            bool highlightControlsArea = (this.fHighlightSelCellItems & iGHighlightSelCellItems.Controls) == iGHighlightSelCellItems.Controls;
            bool highlightContentsArea = (this.fHighlightSelCellItems & iGHighlightSelCellItems.Images) == iGHighlightSelCellItems.Images;
            if (drawCellAsRowSelected)
              this.FillCellPartsWithSemitransparentSelColor(g, selRowsBackColor, num1, backgroundY, backgroundWidth, backgroundHeight, num2, num3, highlightControlsArea, highlightContentsArea, true);
            if (drawCellAsSelected)
              this.FillCellPartsWithSemitransparentSelColor(g, color1, num1, backgroundY, backgroundWidth, backgroundHeight, num2, num3, highlightControlsArea, highlightContentsArea, true);
            if (drawCellAsCurrent)
              this.FillCellPartsWithSemitransparentSelColor(g, color2, num1, backgroundY, backgroundWidth, backgroundHeight, num2, num3, highlightControlsArea, highlightContentsArea, true);
          }
          if (!flag3 && this.IsCellTextReallyDrawn(contentsInternal))
          {
            iGIndent indentNoRightToLeft = this.GetCellTextIndent_NoRightToLeft(cellStyle, rowStyle, colStyle, imageSize, stylesContentIndent, stylesImageAlign);
            using (SolidBrush solidBrush = new SolidBrush(cellForeColor))
              this.DrawText(g, contentsInternal.Text, cellFont, (Brush) solidBrush, cellStringFormat, num2, contentsY, num3, contentsHeight, indentNoRightToLeft, rightToLeft);
          }
          if (gridSection == iGGridSection.Header)
          {
            if (num6 >= contentsX && cellFont != null)
            {
              using (Brush brush = (Brush) new SolidBrush(cellForeColor))
              {
                g.TextRenderingHint = this.fTextRenderingHint;
                g.DrawString(text, cellFont, brush, (float) num6, (float) num5);
              }
            }
            if (x >= contentsX)
            {
              if (headerPlainSortInfo || !this.fHeaderDrawSystem)
              {
                iGArrowDirection direction = headerSortOrder != iGSortOrder.Ascending ? iGArrowDirection.Down : iGArrowDirection.Up;
                System.Drawing.Color color3 = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.ControlsColors) != iGControlPaintFunctions.ControlsColors ? controlPaint.ControlsForeColor : this.fCustomControlPaint.ControlsForeColor;
                iGDrawGridItem.DrawArrow(g, color3, x, y, 5, direction);
              }
              else
              {
                iGHeaderPart headerPart = headerSortOrder != iGSortOrder.Ascending ? iGHeaderPart.SortArrowDown : iGHeaderPart.SortArrowUp;
                controlPaint.DrawHeader(g, x, y, arrowWidth, arrowHeight, headerPart, iGControlState.Normal, rightToLeft);
              }
            }
          }
        }
        else
        {
          Rectangle bounds = new Rectangle(num2, contentsY, num3, contentsHeight);
          switch (gridSection)
          {
            case iGGridSection.Header:
              this.OnCustomDrawColHdrForeground(new iGCustomDrawColHdrEventArgs(rowIndex, colIndex - 1, g, bounds, cellState));
              break;
            case iGGridSection.Cells:
              this.OnCustomDrawCellForeground(new iGCustomDrawCellEventArgs(rowIndex, colIndex - 1, g, bounds, cellState, drawCellAsSelected, drawCellAsRowSelected));
              break;
            case iGGridSection.Footer:
              this.OnCustomDrawFooterCellForeground(new iGCustomDrawFooterCellEventArgs(rowIndex, colIndex - 1, g, bounds));
              break;
          }
        }
      }
      if (!(isCurCell & drawAsFocused) || !this.fFocusRect || this.fRowMode && !this.IsGroupRow(rowType))
        return;
      this.DrawFocusRect(g, num1, backgroundY, backgroundWidth, backgroundHeight);
    }

    private bool IsCellTextReallyDrawn(iGrid.iGCellContents cellContents)
    {
      if (cellContents.DrawText && cellContents.Text != null)
        return cellContents.Text.Length > 0;
      return false;
    }

    private bool IsCellImageReallyDrawn(iGrid.iGCellContents cellContents)
    {
      if (cellContents.DrawImage && cellContents.ImageList != null && cellContents.ImageIndex >= 0)
        return cellContents.ImageIndex < cellContents.ImageList.Images.Count;
      return false;
    }

    private System.Drawing.Color GetSelRowsBackColor(bool drawAsFocused)
    {
      if (drawAsFocused)
      {
        if (this.fSelRowsBackColor.IsEmpty)
          return this.fSelCellsBackColor;
        return this.fSelRowsBackColor;
      }
      if (this.fSelRowsBackColorNoFocus.IsEmpty)
        return this.fSelCellsBackColorNoFocus;
      return this.fSelRowsBackColorNoFocus;
    }

    private void FillCellPartsWithSemitransparentSelColor(Graphics g, System.Drawing.Color color, int fillX, int fillY, int fillWidth, int fillHeight, int withoutControlsX, int withoutControlsWidth, bool highlightControlsArea, bool highlightContentsArea, bool makeOpaqueColorSemitransparent)
    {
      if (makeOpaqueColorSemitransparent && (int) color.A == (int) byte.MaxValue)
        color = System.Drawing.Color.FromArgb(90, color);
      using (Brush brush = (Brush) new SolidBrush(color))
      {
        if (highlightControlsArea)
        {
          if (fillX < withoutControlsX)
            g.FillRectangle(brush, fillX, fillY, withoutControlsX - fillX, fillHeight);
          if (fillX + fillWidth > withoutControlsX + withoutControlsWidth)
            g.FillRectangle(brush, withoutControlsX + withoutControlsWidth, fillY, fillX + fillWidth - (withoutControlsX + withoutControlsWidth), fillHeight);
        }
        if (!highlightContentsArea || withoutControlsWidth <= 0)
          return;
        g.FillRectangle(brush, withoutControlsX, fillY, withoutControlsWidth, fillHeight);
      }
    }

    private void DrawFocusRect(Graphics g, int x, int y, int width, int height)
    {
      HatchBrush hatchBrush = (!this.fScrollWindowVert ? this.fHScrollBar.Value % 2 : this.fVScrollBar.Value % 2) != 0 ? new HatchBrush(HatchStyle.Percent50, this.fFocusRectColor2, this.fFocusRectColor1) : new HatchBrush(HatchStyle.Percent50, this.fFocusRectColor1, this.fFocusRectColor2);
      iGDrawGridItem.DrawRectangleWithBrush(g, (Brush) hatchBrush, x, y, width, height);
      hatchBrush.Dispose();
    }

    private void DrawImage(Graphics g, ImageList imageList, int imageIndex, int x, int y, int width, int height, ContentAlignment align, iGIndent indent, bool rightToLeft, bool hot)
    {
      if (imageList == null || imageIndex >= imageList.Images.Count)
        return;
      int num1 = width - indent.fLeft - indent.fRight;
      if (num1 <= 0)
        return;
      int num2 = height - indent.fTop - indent.fBottom;
      if (num2 <= 0)
        return;
      Size imageSize = imageList.ImageSize;
      int x1 = x;
      int y1 = y;
      iGAligner.AdjustImageLocation(ref x1, ref y1, width, height, imageSize.Width, imageSize.Height, align, indent, rightToLeft);
      Rectangle rect = new Rectangle(x + indent.fLeft, y + indent.fTop, num1, num2);
      bool flag1 = hot && (uint) (this.GetHotTrackFlags() & iGHdrHotTrackFlags.Icon) > 0U;
      bool flag2 = (x1 < rect.X || y1 < rect.Y || x1 + imageSize.Width > rect.Right ? 1 : (y1 + imageSize.Height > rect.Bottom ? 1 : 0)) != 0 && (flag1 || this.fAdjustDrawingForPrinter);
      Region region = (Region) null;
      if (flag2)
      {
        region = g.Clip;
        g.SetClip(rect, CombineMode.Intersect);
      }
      if (flag1)
      {
        if (this.fHighlightIconAttributes == null)
        {
          this.fHighlightIconAttributes = new ImageAttributes();
          ColorMatrix newColorMatrix = new ColorMatrix();
          newColorMatrix.Matrix00 = 1f;
          newColorMatrix.Matrix11 = 1f;
          newColorMatrix.Matrix22 = 1f;
          newColorMatrix.Matrix33 = 1f;
          newColorMatrix.Matrix44 = 1f;
          newColorMatrix.Matrix40 = newColorMatrix.Matrix41 = newColorMatrix.Matrix42 = (float) this.fHotTrackIconDegree / 100f;
          this.fHighlightIconAttributes.SetColorMatrix(newColorMatrix);
        }
        g.DrawImage(imageList.Images[imageIndex], new Rectangle(new Point(x1, y1), imageSize), 0, 0, imageSize.Width, imageSize.Height, GraphicsUnit.Pixel, this.fHighlightIconAttributes);
      }
      else if (this.fAdjustDrawingForPrinter)
      {
        g.DrawImage(imageList.Images[imageIndex], new Rectangle(x1, y1, imageSize.Width, imageSize.Height));
      }
      else
      {
        iGNativeMethods.IMAGELISTDRAWPARAMS pimldp = new iGNativeMethods.IMAGELISTDRAWPARAMS();
        IntPtr hdc = g.GetHdc();
        pimldp.himl = imageList.Handle;
        pimldp.hdcDst = hdc;
        pimldp.cbSize = Marshal.SizeOf(pimldp.GetType());
        pimldp.i = imageIndex;
        pimldp.x = Math.Max(x1, rect.X);
        pimldp.y = Math.Max(y1, rect.Y);
        pimldp.cx = Math.Min(imageSize.Width, num1);
        pimldp.cy = Math.Min(imageSize.Height, num2);
        if (x1 < rect.X)
          pimldp.xBitmap = rect.X - x1;
        if (y1 < rect.Y)
          pimldp.yBitmap = rect.Y - y1;
        pimldp.rgbBk = -1;
        pimldp.rgbFg = -1;
        pimldp.fStyle = 1;
        try
        {
          iGNativeMethods.ImageList_DrawIndirect(ref pimldp);
        }
        finally
        {
          g.ReleaseHdc(hdc);
        }
      }
      if (!flag2)
        return;
      g.Clip = region;
    }

    private void DrawText(Graphics g, string text, Font font, Brush brush, StringFormat stringFormat, int x, int y, int width, int height, iGIndent indent, bool rightToLeft)
    {
      height -= indent.fTop + indent.fBottom;
      width -= indent.fLeft + indent.fRight;
      if (height <= 0 || width <= 0)
        return;
      StringFormatFlags formatFlags = stringFormat.FormatFlags;
      if (rightToLeft)
      {
        stringFormat.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
        indent = iGAligner.RtlTranslateIndent(indent);
      }
      x += indent.fLeft;
      y += indent.fTop;
      StringAlignment lineAlignment = stringFormat.LineAlignment;
      StringAlignment alignment = stringFormat.Alignment;
      if ((formatFlags & StringFormatFlags.DirectionVertical) != (StringFormatFlags) 0)
      {
        stringFormat.LineAlignment = alignment;
        stringFormat.Alignment = lineAlignment;
      }
      g.TextRenderingHint = this.fTextRenderingHint;
      if ((formatFlags & (StringFormatFlags) 65536) != (StringFormatFlags) 0)
      {
        int num1 = (int) Math.Floor((double) width / 2.0);
        int num2 = (int) Math.Floor((double) height / 2.0);
        g.TranslateTransform((float) x + (float) width / 2f, (float) y + (float) height / 2f);
        g.RotateTransform(180f);
        if (stringFormat.LineAlignment == StringAlignment.Near)
          stringFormat.LineAlignment = StringAlignment.Far;
        else if (stringFormat.LineAlignment == StringAlignment.Far)
          stringFormat.LineAlignment = StringAlignment.Near;
        if (stringFormat.Alignment == StringAlignment.Near)
          stringFormat.Alignment = StringAlignment.Far;
        else if (stringFormat.Alignment == StringAlignment.Far)
          stringFormat.Alignment = StringAlignment.Near;
        g.DrawString(text, font, brush, new RectangleF((float) -num1, (float) -num2, (float) width, (float) height), stringFormat);
        g.ResetTransform();
      }
      else
        g.DrawString(text, font, brush, (RectangleF) new Rectangle(x, y, width, height), stringFormat);
      stringFormat.LineAlignment = lineAlignment;
      stringFormat.Alignment = alignment;
      if (!rightToLeft)
        return;
      stringFormat.FormatFlags = formatFlags;
    }

    internal bool IsUniCellPartClippedInternal(iGGridSection gridSection, int rowIndex, int colIndex, iGClippedCellParts parts, bool checkIfPartiallyHidden, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      iGrid.iGCellContents contentsInternal = this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle);
      return this.IsUniCellPartClippedInternal(gridSection, rowIndex, colIndex, parts, checkIfPartiallyHidden, contentsInternal, cellStyle, rowStyle, colStyle);
    }

    private bool IsUniCellPartClippedInternal(iGGridSection gridSection, int rowIndex, int colIndex, iGClippedCellParts parts, bool checkIfPartiallyHidden, iGrid.iGCellContents cellContents, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if ((this.GetPropFromStyles_CustomDrawFlags(cellStyle, rowStyle, colStyle) & iGCustomDrawFlags.Foreground) != iGCustomDrawFlags.None)
        return false;
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      Rectangle rect1 = Rectangle.Empty;
      switch (gridSection)
      {
        case iGGridSection.Header:
          rect1 = this.GetColumnHeadersAreaBoundsNoRowHdr(rightToLeft);
          break;
        case iGGridSection.Cells:
          rect1 = this.GetCellsAreaBoundsNoRowHdr(rightToLeft);
          break;
        case iGGridSection.Footer:
          rect1 = this.GetFooterAreaBoundsNoRowHdr(rightToLeft);
          break;
      }
      int colOrder = this.GetColOrder(colIndex);
      iGColDisposition iGcolDisposition = this.GetColDisposition(colOrder);
      bool flag1 = false;
      switch (gridSection)
      {
        case iGGridSection.Header:
        case iGGridSection.Footer:
          flag1 = colOrder < this.fFrozenColCount;
          break;
        case iGGridSection.Cells:
          if (this.IsGroupRow(rowIndex))
            iGcolDisposition = iGColDisposition.Auxiliary;
          switch (iGcolDisposition)
          {
            case iGColDisposition.Normal:
            case iGColDisposition.AboveRowText:
              flag1 = colOrder < this.fFrozenColCount;
              break;
            case iGColDisposition.RowText:
              flag1 = this.fRowTextStartColNear < this.fFrozenColCount;
              break;
            case iGColDisposition.Auxiliary:
              flag1 = true;
              break;
            default:
              flag1 = true;
              break;
          }
            break;
      }
      bool flag2 = iGcolDisposition != iGColDisposition.Auxiliary && !flag1;
      bool flag3 = gridSection == iGGridSection.Cells && rowIndex >= this.fFrozenRowCount;
      if (flag2 | flag3)
      {
        Rectangle frozenCellsAreaBounds = this.GetNonFrozenCellsAreaBounds(rightToLeft);
        if (flag2)
          rect1.Intersect(new Rectangle(frozenCellsAreaBounds.X, 0, frozenCellsAreaBounds.Width, this.Height));
        if (flag3)
          rect1.Intersect(new Rectangle(0, frozenCellsAreaBounds.Y, this.Width, frozenCellsAreaBounds.Height));
      }
      iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType(cellStyle, rowStyle, colStyle);
      if (gridSection == iGGridSection.Cells && fromStylesDrawType == iGCellDrawType.Check)
      {
        int checkSize = this.GetCheckSize((IiGControlPaint) this.fCellControlPaintStyle.ControlPaint, int.MaxValue, int.MaxValue, new iGIndent(0));
        Rectangle andTextAreaBounds = this.GetCellImageAndTextAreaBounds(rowIndex, colIndex, false);
        if (checkIfPartiallyHidden)
          andTextAreaBounds.Intersect(rect1);
        if (andTextAreaBounds.Width < checkSize || andTextAreaBounds.Height < checkSize)
          return true;
      }
      else
      {
        if ((parts & iGClippedCellParts.Image) == iGClippedCellParts.Image && this.IsCellImageReallyDrawn(cellContents))
        {
          Rectangle rectangle = Rectangle.Empty;
          switch (gridSection)
          {
            case iGGridSection.Header:
              rectangle = this.GetColHdrImageAndTextAreaBounds(rowIndex, colIndex, false);
              break;
            case iGGridSection.Cells:
              rectangle = this.GetCellImageAndTextAreaBounds(rowIndex, colIndex, false);
              break;
            case iGGridSection.Footer:
              rectangle = this.GetFooterCellImageAndTextAreaBounds(rowIndex, colIndex, false);
              break;
          }
          if (rectangle.Width < cellContents.ImageList.ImageSize.Width || rectangle.Height < cellContents.ImageList.ImageSize.Height)
            return true;
          if (checkIfPartiallyHidden)
          {
            int x = rectangle.X;
            int y = rectangle.Y;
            int width1 = cellContents.ImageList.ImageSize.Width;
            int width2 = cellContents.ImageList.ImageSize.Width;
            ContentAlignment stylesImageAlign = this.GetPropFromStyles_ImageAlign(cellStyle, rowStyle, colStyle);
            iGAligner.AdjustImageLocation(ref x, ref y, rectangle.Width, rectangle.Height, width1, width2, stylesImageAlign, new iGIndent(), rightToLeft);
            Rectangle rect2 = new Rectangle(x, y, width1, width2);
            if (!rect1.Contains(rect2))
              return true;
          }
        }
        if ((parts & iGClippedCellParts.Text) == iGClippedCellParts.Text && this.IsCellTextReallyDrawn(cellContents))
        {
          Rectangle rectangle = Rectangle.Empty;
          switch (gridSection)
          {
            case iGGridSection.Header:
              rectangle = this.GetColHdrTextAreaBounds(rowIndex, colIndex);
              break;
            case iGGridSection.Cells:
              rectangle = this.GetCellTextAreaBounds(rowIndex, colIndex);
              break;
            case iGGridSection.Footer:
              rectangle = this.GetFooterCellTextAreaBounds(rowIndex, colIndex);
              break;
          }
          using (Graphics graphics = this.CreateGraphics())
          {
            StringFormat cellStringFormat = this.GetUniCellStringFormat(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle);
            bool isEven = false;
            bool isOdd = false;
            bool cellSelected = false;
            bool rowSelected = false;
            switch (gridSection)
            {
              case iGGridSection.Cells:
                isEven = this.IsEvenRowInternal(rowIndex);
                isOdd = !isEven;
                cellSelected = this.GetCellSelectedInternal(rowIndex, colIndex);
                rowSelected = this.GetRowSelectedInternal(rowIndex);
                break;
            }
            Font uniCellFont = this.GetUniCellFont(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle, iGControlState.Normal, isEven, isOdd, cellSelected, rowSelected);
            int textWidth = this.GetTextWidth(cellContents.Text, graphics, uniCellFont, cellStringFormat, rectangle.Height, true);
            int textHeight = this.GetTextHeight(cellContents.Text, graphics, uniCellFont, cellStringFormat, rectangle.Width);
            if (rectangle.Width < textWidth || rectangle.Height < textHeight)
              return true;
            if (checkIfPartiallyHidden)
            {
              Rectangle rect2 = new Rectangle(0, 0, textWidth, textHeight);
              switch (cellStringFormat.Alignment)
              {
                case StringAlignment.Near:
                  rect2.X = rectangle.X;
                  break;
                case StringAlignment.Center:
                  rect2.X = rectangle.X + (rectangle.Width - textWidth) / 2;
                  break;
                case StringAlignment.Far:
                  rect2.X = rectangle.X + rectangle.Width - textWidth;
                  break;
              }
              if (rightToLeft)
                rect2.X = rectangle.X + rectangle.Width - (rect2.X - rectangle.X + rect2.Width);
              switch (cellStringFormat.LineAlignment)
              {
                case StringAlignment.Near:
                  rect2.Y = rectangle.Y;
                  break;
                case StringAlignment.Center:
                  rect2.Y = rectangle.Y + (rectangle.Height - textHeight) / 2;
                  break;
                case StringAlignment.Far:
                  rect2.Y = rectangle.Y + rectangle.Height - textHeight;
                  break;
              }
              if (!rect1.Contains(rect2))
                return true;
            }
          }
        }
      }
      return false;
    }

    private int GetCheckSize(IiGControlPaint controlPaint, int width, int height, iGIndent indent)
    {
      Size size = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.CheckBox) != iGControlPaintFunctions.CheckBox ? controlPaint.GetCheckBoxSize() : this.fCustomControlPaint.GetCheckBoxSize();
      int num = Math.Max(size.Width, size.Height);
      if (num > width - indent.fLeft - indent.fRight)
        num = width - indent.fLeft - indent.fRight;
      if (num > height - indent.fTop - indent.fBottom)
        num = height - indent.fTop - indent.fBottom;
      return num;
    }

    internal CheckState GetCheckStateFromObjectValue(object value, iGCellDrawTypeFlags typeFlags)
    {
      CheckState checkState;
      if (value != null)
      {
        Type type = value.GetType();
        if (type == typeof (bool))
          checkState = !(bool) value ? CheckState.Unchecked : CheckState.Checked;
        else if (type == typeof (CheckState))
        {
          checkState = (CheckState) value;
          if (checkState == CheckState.Indeterminate && (typeFlags & iGCellDrawTypeFlags.CheckThreeState) == iGCellDrawTypeFlags.None)
            checkState = CheckState.Checked;
        }
        else if (this.IsNumericType(type))
        {
          double num = Convert.ToDouble(value);
          checkState = num != 0.0 ? (num != 2.0 || (typeFlags & iGCellDrawTypeFlags.CheckThreeState) == iGCellDrawTypeFlags.None ? CheckState.Checked : CheckState.Indeterminate) : CheckState.Unchecked;
        }
        else
          checkState = CheckState.Checked;
      }
      else
        checkState = CheckState.Unchecked;
      return checkState;
    }

    private void DrawCheck(Graphics g, IiGControlPaint controlPaint, CheckState checkState, iGCellDrawTypeFlags typeFlags, iGControlState cellState, bool readOnly, bool singleClickEdit, bool isCurCell, int x, int y, int width, int height, ContentAlignment align, iGIndent indent, bool drawPlain, bool rightToLeft)
    {
      int checkSize = this.GetCheckSize(controlPaint, width, height, indent);
      if (checkSize <= 0)
        return;
      iGControlState controlState = cellState != iGControlState.Disabled ? (!readOnly ? (cellState != iGControlState.Pressed || this.fMouseData.ElemControl == iGElemControl.EllipsisButton ? (cellState != iGControlState.Hot || this.fMouseData.ElemControl == iGElemControl.EllipsisButton || !(isCurCell | singleClickEdit) ? iGControlState.Normal : iGControlState.Hot) : (singleClickEdit || this.fMouseData.MouseDownOnTheCurCell ? iGControlState.HotPressed : (!this.fHotTracking ? iGControlState.Normal : iGControlState.Hot))) : iGControlState.Normal) : iGControlState.Disabled;
      iGAligner.AdjustImageLocation(ref x, ref y, width, height, checkSize, checkSize, align, indent, rightToLeft);
      if (drawPlain)
      {
        System.Drawing.Color color = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.ControlsColors) != iGControlPaintFunctions.ControlsColors ? controlPaint.ControlsForeColor : this.fCustomControlPaint.ControlsForeColor;
        using (Brush brush = (Brush) new SolidBrush(color))
          iGDrawGridItem.DrawRectangleWithBrush(g, brush, x, y, checkSize, checkSize);
        if (checkState != CheckState.Checked)
          return;
        iGDrawGridItem.DrawCheck(g, color, x, y, checkSize - 6);
      }
      else if (this.fCustomControlPaint != null && (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.CheckBox) == iGControlPaintFunctions.CheckBox)
        this.fCustomControlPaint.DrawCheckBox(g, x, y, checkSize, checkSize, checkState, controlState);
      else
        controlPaint.DrawCheckBox(g, x, y, checkSize, checkSize, checkState, controlState);
    }

    private Size GetComboSize(int width, int height)
    {
      int width1 = SystemInformation.VerticalScrollBarWidth;
      int height1 = height == int.MaxValue || !this.fStretchComboButton ? SystemInformation.VerticalScrollBarWidth : height - this.cComboIndent * 2;
      if (width1 + this.cComboIndent * 2 > width)
        width1 = width - this.cComboIndent * 2;
      if (height1 > height - this.cComboIndent * 2)
        height1 = height - this.cComboIndent * 2;
      return new Size(width1, height1);
    }

    private iGElemControl GetElemControlUnderMouse(int rowIndex, int colIndex, int mouseX, int mouseY, int x, int y, int width, int height, bool rightToLeft, bool isHeader)
    {
      iGRowData iGrowData = new iGRowData();
      iGCellDrawType fromStylesDrawType;
      iGCellDrawTypeFlags stylesDrawTypeFlags;
      ContentAlignment stylesImageAlign;
      iGIndent stylesContentIndent;
      IiGDropDownControl dropDownControl;
      if (isHeader)
      {
        iGStyleBase style = (iGStyleBase) this.GetColHdrDataInternal(rowIndex, colIndex).Style;
        iGStyleBase colHdrStyle = (iGStyleBase) this.GetColData(colIndex).ColHdrStyle;
        fromStylesDrawType = this.GetPropFromStyles_DrawType(style, (iGStyleBase) null, colHdrStyle);
        stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags(style, (iGStyleBase) null, colHdrStyle);
        stylesImageAlign = this.GetPropFromStyles_ImageAlign(style, (iGStyleBase) null, colHdrStyle);
        stylesContentIndent = this.GetPropFromStyles_ContentIndent(style, (iGStyleBase) null, colHdrStyle);
        dropDownControl = this.GetPropFromStyles_DropDownControl(style, (iGStyleBase) null, colHdrStyle);
      }
      else
      {
        iGStyleBase style = (iGStyleBase) this.GetCellDataInternal(rowIndex, colIndex).Style;
        iGrowData = this.GetRowDataInternal(rowIndex);
        iGStyleBase cellStyle1 = (iGStyleBase) iGrowData.CellStyle;
        iGStyleBase cellStyle2 = (iGStyleBase) this.GetColDataInternal(colIndex).CellStyle;
        fromStylesDrawType = this.GetPropFromStyles_DrawType(style, cellStyle1, cellStyle2);
        stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags(style, cellStyle1, cellStyle2);
        stylesImageAlign = this.GetPropFromStyles_ImageAlign(style, cellStyle1, cellStyle2);
        stylesContentIndent = this.GetPropFromStyles_ContentIndent(style, cellStyle1, cellStyle2);
        dropDownControl = this.GetUniCellDropDownControl(iGGridSection.Cells, rowIndex, colIndex, style, cellStyle1, cellStyle2, false);
      }
      if (!isHeader && iGrowData.TreeButton == iGTreeButtonState.Visible && this.IsPointOverTreeButton(mouseX, mouseY, rowIndex, this.GetColOrder(colIndex), iGrowData.Type, iGrowData.Level, x, y, width, height))
        return iGElemControl.TreeButton;
      if ((stylesDrawTypeFlags & iGCellDrawTypeFlags.HasEllipsisButton) != iGCellDrawTypeFlags.None)
      {
        Size comboSize = this.GetComboSize(width, height);
        if (comboSize.Width <= 0 || comboSize.Height <= 0)
          return iGElemControl.None;
        int x1 = x;
        int y1 = y;
        iGAligner.AdjustImageLocation(ref x1, ref y1, width, height, comboSize.Width, comboSize.Height, ContentAlignment.MiddleRight, new iGIndent(this.cComboIndent, this.cComboIndent, this.cComboIndent, this.cComboIndent), rightToLeft);
        if (new Rectangle(x1, y1, comboSize.Width, comboSize.Height).Contains(mouseX, mouseY))
          return iGElemControl.EllipsisButton;
        width -= this.cComboIndent + comboSize.Width;
        if (rightToLeft)
          x += this.cComboIndent + comboSize.Width;
      }
      if (this.ShouldDrawComboButton(fromStylesDrawType, stylesDrawTypeFlags, dropDownControl))
      {
        Size comboSize = this.GetComboSize(width, height);
        if (comboSize.Width <= 0 || comboSize.Height <= 0)
          return iGElemControl.None;
        int x1 = x;
        int y1 = y;
        iGAligner.AdjustImageLocation(ref x1, ref y1, width, height, comboSize.Width, comboSize.Height, ContentAlignment.MiddleRight, new iGIndent(this.cComboIndent, this.cComboIndent, this.cComboIndent, this.cComboIndent), rightToLeft);
        if (new Rectangle(x1, y1, comboSize.Width, comboSize.Height).Contains(mouseX, mouseY))
          return iGElemControl.ComboButton;
      }
      else if (fromStylesDrawType == iGCellDrawType.Check)
      {
        int checkSize = this.GetCheckSize(!isHeader ? (IiGControlPaint) this.fCellControlPaintStyle.ControlPaint : (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint, width, height, stylesContentIndent);
        if (checkSize <= 0)
          return iGElemControl.None;
        int x1 = x;
        int y1 = y;
        iGAligner.AdjustImageLocation(ref x1, ref y1, width, height, checkSize, checkSize, stylesImageAlign, stylesContentIndent, rightToLeft);
        if (new Rectangle(x1, y1, checkSize, checkSize).Contains(mouseX, mouseY))
          return iGElemControl.CheckBox;
      }
      return iGElemControl.None;
    }

    private Rectangle GetEllipsisRectangle(int x, int y, int width, int height, bool rightToLeft)
    {
      Size comboSize = this.GetComboSize(width, height);
      if (comboSize.Width < 0)
        comboSize.Width = 0;
      if (comboSize.Height < 0)
        comboSize.Height = 0;
      iGAligner.AdjustImageLocation(ref x, ref y, width, height, comboSize.Width, comboSize.Height, ContentAlignment.MiddleRight, new iGIndent(this.cComboIndent, this.cComboIndent, this.cComboIndent, this.cComboIndent), rightToLeft);
      return new Rectangle(x, y, comboSize.Width, comboSize.Height);
    }

    private void DrawEllipsis(Graphics g, IiGControlPaint controlPaint, int rowIndex, int colIndex, iGControlState cellState, bool readOnly, bool singleClickEdit, Rectangle buttonBounds, bool rightToLeft)
    {
      iGControlState iGcontrolState = cellState != iGControlState.Disabled ? (!readOnly ? (cellState != iGControlState.Pressed || this.fMouseData.ElemControl != iGElemControl.EllipsisButton ? (cellState != iGControlState.Hot || this.fMouseData.ElemControl != iGElemControl.EllipsisButton ? iGControlState.Normal : iGControlState.Hot) : (singleClickEdit || this.fMouseData.MouseDownOnTheCurCell || this.fShowControlsInAllCells ? iGControlState.HotPressed : iGControlState.Hot)) : iGControlState.Normal) : iGControlState.Disabled;
      iGCustomDrawEllipsisButtonEventArgs e = new iGCustomDrawEllipsisButtonEventArgs(rowIndex, colIndex - 1, g, buttonBounds, iGcontrolState);
      this.OnCustomDrawCellEllipsisButtonBackground(e);
      if (e.DoDefault)
      {
        if (this.fCustomControlPaint != null && (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.EllipsisButton) == iGControlPaintFunctions.EllipsisButton)
          this.fCustomControlPaint.DrawEllipsisButton(g, buttonBounds.X, buttonBounds.Y, buttonBounds.Width, buttonBounds.Height, iGcontrolState);
        else
          controlPaint.DrawEllipsisButton(g, buttonBounds.X, buttonBounds.Y, buttonBounds.Width, buttonBounds.Height, iGcontrolState);
      }
      e.DoDefault = true;
      this.OnCustomDrawCellEllipsisButtonForeground(e);
      if (!e.DoDefault)
        return;
      if (this.fEllipsisButtonGlyph == null)
      {
        System.Drawing.Color color = iGcontrolState != iGControlState.Disabled ? (this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.ControlsColors) != iGControlPaintFunctions.ControlsColors ? controlPaint.ControlsForeColor : this.fCustomControlPaint.ControlsForeColor) : (this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.ControlsColors) != iGControlPaintFunctions.ControlsColors ? controlPaint.ControlsDisabledForeColor : this.fCustomControlPaint.ControlsDisabledForeColor);
        iGDrawGridItem.DrawEllipsisOnButton(g, color, buttonBounds.X, buttonBounds.Y, buttonBounds.Width, buttonBounds.Height);
      }
      else
      {
        int x = buttonBounds.X;
        int y = buttonBounds.Y;
        int width = this.fEllipsisButtonGlyph.Width;
        int height = this.fEllipsisButtonGlyph.Height;
        if (width > buttonBounds.Width)
          width = buttonBounds.Width;
        if (height > buttonBounds.Height)
          height = buttonBounds.Height;
        iGAligner.AdjustImageLocation(ref x, ref y, buttonBounds.Width, buttonBounds.Height, width, height, ContentAlignment.MiddleCenter, new iGIndent(0), rightToLeft);
        bool flag = this.fCustomControlPaint == null ? controlPaint.OffsetScrollBarCustomButtonImageWhenPressed : this.fCustomControlPaint.OffsetScrollBarCustomButtonImageWhenPressed;
        if (iGcontrolState == iGControlState.HotPressed & flag)
        {
          ++x;
          ++y;
        }
        g.DrawImage(this.fEllipsisButtonGlyph, x, y, width, height);
      }
    }

    private Rectangle GetComboRectangle(int x, int y, int width, int height, bool rightToLeft)
    {
      Size comboSize = this.GetComboSize(width, height);
      if (comboSize.Width < 0)
        comboSize.Width = 0;
      if (comboSize.Height < 0)
        comboSize.Height = 0;
      iGAligner.AdjustImageLocation(ref x, ref y, width, height, comboSize.Width, comboSize.Height, ContentAlignment.MiddleRight, new iGIndent(this.cComboIndent, this.cComboIndent, this.cComboIndent, this.cComboIndent), rightToLeft);
      return new Rectangle(x, y, comboSize.Width, comboSize.Height);
    }

    private void DrawCombo(iGGridSection gridSection, Graphics g, IiGControlPaint controlPaint, int rowIndex, int colIndex, bool isCurCell, bool isEditableAsText, bool singleClickEdit, iGControlState cellState, bool readOnly, Rectangle buttonBounds)
    {
      iGControlState iGcontrolState = iGControlState.Normal;
      switch (gridSection)
      {
        case iGGridSection.Header:
          iGcontrolState = cellState;
          break;
        case iGGridSection.Cells:
          iGcontrolState = cellState != iGControlState.Disabled ? (!readOnly ? (!isCurCell || !this.IsCellDropDownActive() && !this.IsAutoCompleteActive() && !this.fCurCellComboPressed ? (cellState != iGControlState.Hot && cellState != iGControlState.Pressed || this.fMouseData.ElemControl != iGElemControl.ComboButton && (isEditableAsText || this.fMouseData.ElemControl != iGElemControl.None || !(isCurCell | singleClickEdit)) ? iGControlState.Normal : iGControlState.Hot) : iGControlState.HotPressed) : iGControlState.Normal) : iGControlState.Disabled;
          break;
      }
      iGCustomDrawComboButtonEventArgs e = new iGCustomDrawComboButtonEventArgs(rowIndex, colIndex - 1, g, buttonBounds, iGcontrolState);
      switch (gridSection)
      {
        case iGGridSection.Header:
          this.OnCustomDrawColHdrComboButton(e);
          break;
        case iGGridSection.Cells:
          this.OnCustomDrawCellComboButton(e);
          break;
      }
      if (!e.DoDefault)
        return;
      bool isHeader = gridSection == iGGridSection.Header;
      if (this.fCustomControlPaint != null && (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.ComboButton) == iGControlPaintFunctions.ComboButton)
        this.fCustomControlPaint.DrawComboButton(g, buttonBounds.X, buttonBounds.Y, buttonBounds.Width, buttonBounds.Height, iGcontrolState, isHeader);
      else
        controlPaint.DrawComboButton(g, buttonBounds.X, buttonBounds.Y, buttonBounds.Width, buttonBounds.Height, iGcontrolState, isHeader);
    }

    private int GetTextHeight(string text, Graphics g, Font font, StringFormat stringFormat, int availableWidth)
    {
      g.TextRenderingHint = this.fTextRenderingHint;
      return (int) Math.Ceiling((double) g.MeasureString(text, font, availableWidth, stringFormat).Height);
    }

    private int GetTextWidth(string text, Graphics g, Font font, StringFormat stringFormat, int availableHeight)
    {
      return this.GetTextWidth(text, g, font, stringFormat, availableHeight, false);
    }

    private int GetTextWidth(string text, Graphics g, Font font, StringFormat stringFormat, int availableHeight, bool canBreakSingleWord)
    {
      g.TextRenderingHint = this.fTextRenderingHint;
      if (!canBreakSingleWord && text.IndexOf(' ') < 0)
        return (int) Math.Ceiling((double) g.MeasureString(text, font, int.MaxValue, stringFormat).Width);
      float height1 = font.GetHeight(g);
      int num1 = this.GetCountOfChars(text, '\n') + 1;
      SizeF sizeF1 = g.MeasureString(text, font, int.MaxValue, stringFormat);
      int num2 = (int) ((double) availableHeight / (double) height1);
      if (num2 <= num1 || (stringFormat.FormatFlags & StringFormatFlags.NoWrap) != (StringFormatFlags) 0)
        return (int) Math.Ceiling((double) sizeF1.Width);
      float num3 = sizeF1.Width * (float) num1 / (float) num2 + height1;
      SizeF sizeF2 = g.MeasureString(text, font, (int) Math.Floor((double) num3), stringFormat);
      int num4 = 0;
      if ((double) sizeF2.Height % (double) height1 < (double) height1 / 2.0)
        sizeF2.Height = height1 * (float) (int) ((double) sizeF2.Height / (double) height1);
      float height2 = sizeF2.Height;
      for (; (double) sizeF2.Height - (double) availableHeight > 0.999 && num4 <= 5; sizeF2 = g.MeasureString(text, font, (int) Math.Floor((double) num3), stringFormat))
      {
        if ((double) height2 == (double) sizeF2.Height)
        {
          ++num4;
        }
        else
        {
          num4 = 0;
          height2 = sizeF2.Height;
        }
        num3 += height1 * (float) (((double) sizeF2.Height - (double) availableHeight) / (double) height1 + 1.0);
      }
      return (int) Math.Ceiling((double) sizeF2.Width);
    }

    private int GetCountOfChars(string str, char value)
    {
      int startIndex = 0;
      int num1 = 0;
      int num2;
      for (int length = str.Length; startIndex < length; startIndex = num2 + 1)
      {
        num2 = str.IndexOf(value, startIndex);
        if (num2 >= 0)
          ++num1;
        else
          break;
      }
      return num1;
    }

    private void InvalidateCell(int rowIndex, int colIndex)
    {
      this.Invalidate(this.GetCellBounds(rowIndex, this.GetColOrder(colIndex), false));
    }

    private void InvalidateRow(int rowIndex)
    {
      if (this.fMergedCellCountVert > 0)
      {
        for (int index = 1; index < this.fColCount; ++index)
        {
          if (this.GetCellDataInternal(rowIndex, this.fColIdxFromOrd[index]).SpanRows != 1)
          {
            this.Invalidate();
            return;
          }
        }
      }
      this.Invalidate(new Rectangle(0, this.RowToY(rowIndex), this.Width, this.GetRowDataInternal(rowIndex).Height));
    }

    private void GetUniCellFormattingNoSelected(iGGridSection gridSection, int rowIndex, int colIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGControlState state, bool isEven, bool isOdd, bool cellSelected, bool rowSelected, out System.Drawing.Color backColor, out System.Drawing.Color foreColor, out Font font)
    {
      backColor = this.GetUniCellBackColorNoDynamicNoSelected(gridSection, cellStyle, rowStyle, colStyle, state, isEven, isOdd);
      foreColor = this.GetUniCellForeColorNoDynamicNoSelected(gridSection, cellStyle, rowStyle, colStyle, state);
      font = this.GetUniCellFontNoDynamic(gridSection, cellStyle, rowStyle, colStyle);
      if (gridSection == iGGridSection.Cells && rowIndex != -1)
        this.DoCellDynamicFormatting(rowIndex, colIndex, cellSelected, rowSelected, ref backColor, ref foreColor, ref font);
      if (!this.fAdjustDrawingForPrinter)
        return;
      font = this.AdjustFontForPrinting(font);
    }

    internal System.Drawing.Color GetUniCellBackColorNoSelected(iGGridSection gridSection, int rowIndex, int colIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGControlState state, bool isEven, bool isOdd, bool cellSelected, bool rowSelected)
    {
      System.Drawing.Color backColor;
      System.Drawing.Color foreColor;
      Font font;
      this.GetUniCellFormattingNoSelected(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle, state, isEven, isOdd, cellSelected, rowSelected, out backColor, out foreColor, out font);
      this.CheckDisposeFontForPrinter(font);
      return backColor;
    }

    internal System.Drawing.Color GetUniCellForeColorNoSelected(iGGridSection gridSection, int rowIndex, int colIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGControlState state, bool isEven, bool isOdd, bool cellSelected, bool rowSelected)
    {
      System.Drawing.Color backColor;
      System.Drawing.Color foreColor;
      Font font;
      this.GetUniCellFormattingNoSelected(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle, state, isEven, isOdd, cellSelected, rowSelected, out backColor, out foreColor, out font);
      this.CheckDisposeFontForPrinter(font);
      return foreColor;
    }

    internal Font GetUniCellFont(iGGridSection gridSection, int rowIndex, int colIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGControlState state, bool isEven, bool isOdd, bool cellSelected, bool rowSelected)
    {
      System.Drawing.Color backColor;
      System.Drawing.Color foreColor;
      Font font;
      this.GetUniCellFormattingNoSelected(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle, state, isEven, isOdd, cellSelected, rowSelected, out backColor, out foreColor, out font);
      this.CheckDisposeFontForPrinter(font);
      return font;
    }

    internal System.Drawing.Color GetUniCellBackColorNoDynamicNoSelected(iGGridSection gridSection, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGControlState state, bool isEven, bool isOdd)
    {
      System.Drawing.Color color = this.GetPropFromStyles_BackColor(cellStyle, rowStyle, colStyle);
      switch (gridSection)
      {
        case iGGridSection.Header:
          if (color.IsEmpty && !this.fHeaderDrawSystem)
            color = this.GetHeaderBackColor();
          if (!color.IsEmpty)
          {
            if (state == iGControlState.Hot)
            {
              if ((this.GetHotTrackFlags() & iGHdrHotTrackFlags.Background) != iGHdrHotTrackFlags.None)
              {
                color = iGColorManager.Lighten(color, 10);
                break;
              }
              break;
            }
            if (state == iGControlState.Pressed)
            {
              color = iGColorManager.GetColorControlDark(color);
              break;
            }
            break;
          }
          break;
        case iGGridSection.Cells:
          if (color.IsEmpty)
          {
            if (isEven)
            {
              if (!this.fBackColorEvenRows.IsEmpty)
              {
                color = this.fBackColorEvenRows;
                break;
              }
              break;
            }
            if (isOdd && !this.fBackColorOddRows.IsEmpty)
            {
              color = this.fBackColorOddRows;
              break;
            }
            break;
          }
          break;
        case iGGridSection.Footer:
          if (color.IsEmpty)
          {
            color = this.GetFooterBackColor();
            break;
          }
          break;
      }
      return color;
    }

    private void AdjustCellForeColorWithSelColors(ref System.Drawing.Color cellForeColor, bool isCurCell, bool isCellSelected, bool isRowSelected, bool isEnabled, bool drawAsFocused)
    {
      if (!isEnabled)
        return;
      if (isCurCell)
      {
        if (drawAsFocused)
        {
          if (!this.fCurCellForeColor.IsEmpty)
          {
            cellForeColor = this.fCurCellForeColor;
            return;
          }
        }
        else if (!this.fCurCellForeColorNoFocus.IsEmpty)
        {
          cellForeColor = this.fCurCellForeColorNoFocus;
          return;
        }
      }
      if (isCellSelected)
      {
        if (drawAsFocused)
        {
          if (!this.fSelCellsForeColor.IsEmpty)
          {
            cellForeColor = this.fSelCellsForeColor;
            return;
          }
        }
        else if (!this.fSelCellsForeColorNoFocus.IsEmpty)
        {
          cellForeColor = this.fSelCellsForeColorNoFocus;
          return;
        }
      }
      if (!isRowSelected)
        return;
      if (drawAsFocused)
      {
        if (this.fSelRowsForeColor.IsEmpty)
        {
          if (this.fSelCellsForeColor.IsEmpty)
            return;
          cellForeColor = this.fSelCellsForeColor;
        }
        else
          cellForeColor = this.fSelRowsForeColor;
      }
      else if (this.fSelRowsForeColorNoFocus.IsEmpty)
      {
        if (this.fSelCellsForeColorNoFocus.IsEmpty)
          return;
        cellForeColor = this.fSelCellsForeColorNoFocus;
      }
      else
        cellForeColor = this.fSelRowsForeColorNoFocus;
    }

    private System.Drawing.Color GetUniCellForeColorNoDynamicNoSelected(iGGridSection gridSection, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGControlState state)
    {
      if (state == iGControlState.Disabled)
        return this.fForeColorDisabled;
      if (gridSection == iGGridSection.Header && (state == iGControlState.Hot || state == iGControlState.Pressed) && (this.GetHotTrackFlags() & iGHdrHotTrackFlags.Text) != iGHdrHotTrackFlags.None)
        return this.fHotTrackForeColor;
      System.Drawing.Color color = this.GetPropFromStyles_ForeColor(cellStyle, rowStyle, colStyle);
      if (color.IsEmpty)
      {
        switch (gridSection)
        {
          case iGGridSection.Header:
            color = this.GetHeaderForeColor();
            break;
          case iGGridSection.Cells:
            color = this.ForeColor;
            break;
          case iGGridSection.Footer:
            color = this.GetFooterForeColor();
            break;
        }
      }
      return color;
    }

    private Font GetUniCellFontNoDynamic(iGGridSection gridSection, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      Font font = this.GetPropFromStyles_Font(cellStyle, rowStyle, colStyle);
      if (font == null)
      {
        switch (gridSection)
        {
          case iGGridSection.Header:
            font = this.GetHeaderFont();
            break;
          case iGGridSection.Cells:
            font = this.Font;
            break;
          case iGGridSection.Footer:
            font = this.GetFooterFont();
            break;
        }
      }
      return font;
    }

    private static StringFormatFlags ToStringFormatFlags(iGStringFormatFlags value)
    {
      return (StringFormatFlags) (value ^ iGStringFormatFlags.WordWrap);
    }

    private StringFormat GetUniCellStringFormat(iGGridSection gridSection, int rowIndex, int colIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      StringFormat stringFormat = new StringFormat();
      if (cellStyle == null || cellStyle.fNotSetTextAlignment)
      {
        if (rowStyle == null || rowStyle.fNotSetTextAlignment)
        {
          if (colStyle.fNotSetTextAlignment)
          {
            stringFormat.Alignment = StringAlignment.Near;
            stringFormat.LineAlignment = StringAlignment.Near;
          }
          else
          {
            stringFormat.Alignment = colStyle.fTextHAlign;
            stringFormat.LineAlignment = colStyle.fTextVAlign;
          }
        }
        else
        {
          stringFormat.Alignment = rowStyle.fTextHAlign;
          stringFormat.LineAlignment = rowStyle.fTextVAlign;
        }
      }
      else
      {
        stringFormat.Alignment = cellStyle.fTextHAlign;
        stringFormat.LineAlignment = cellStyle.fTextVAlign;
      }
      stringFormat.FormatFlags = cellStyle == null || cellStyle.TextFormatFlags == iGStringFormatFlags.NotSet ? (rowStyle == null || rowStyle.TextFormatFlags == iGStringFormatFlags.NotSet ? (colStyle.TextFormatFlags != iGStringFormatFlags.NotSet ? iGrid.ToStringFormatFlags(colStyle.TextFormatFlags) : iGrid.ToStringFormatFlags(iGStringFormatFlags.None)) : iGrid.ToStringFormatFlags(rowStyle.TextFormatFlags)) : iGrid.ToStringFormatFlags(cellStyle.TextFormatFlags);
      stringFormat.Trimming = cellStyle == null || cellStyle.TextTrimming == iGStringTrimming.NotSet ? (rowStyle == null || rowStyle.TextTrimming == iGStringTrimming.NotSet ? (colStyle.TextTrimming != iGStringTrimming.NotSet ? (StringTrimming) colStyle.TextTrimming : StringTrimming.EllipsisCharacter) : (StringTrimming) rowStyle.TextTrimming) : (StringTrimming) cellStyle.TextTrimming;
      if (gridSection == iGGridSection.Cells && rowIndex != -1)
        this.DoCellDynamicStringFormat(rowIndex, colIndex, ref stringFormat);
      return stringFormat;
    }

    private System.Drawing.Color GetPropFromStyles_BackColor(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && !cellStyle.BackColor.IsEmpty)
        return cellStyle.BackColor;
      if (rowStyle != null && !rowStyle.BackColor.IsEmpty)
        return rowStyle.BackColor;
      if (colStyle == null)
        return System.Drawing.Color.Empty;
      return colStyle.BackColor;
    }

    private System.Drawing.Color GetPropFromStyles_ForeColor(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && !cellStyle.ForeColor.IsEmpty)
        return cellStyle.ForeColor;
      if (rowStyle == null || rowStyle.ForeColor.IsEmpty)
        return colStyle.ForeColor;
      return rowStyle.ForeColor;
    }

    private Font GetPropFromStyles_Font(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.Font != null)
        return cellStyle.Font;
      if (rowStyle == null || rowStyle.Font == null)
        return colStyle.Font;
      return rowStyle.Font;
    }

    private string GetPropFromStyles_FormatString(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.FormatString != null)
        return cellStyle.FormatString;
      if (rowStyle == null || rowStyle.FormatString == null)
        return colStyle.FormatString;
      return rowStyle.FormatString;
    }

    private IFormatProvider GetPropFromStyles_FormatProvider(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.FormatProvider != null)
        return cellStyle.FormatProvider;
      if (rowStyle == null || rowStyle.FormatProvider == null)
        return colStyle.FormatProvider;
      return rowStyle.FormatProvider;
    }

    private Type GetPropFromStyles_ValueType(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (cellStyle != null && !(cellStyle.ValueType == (Type) null))
        return cellStyle.ValueType;
      if (rowStyle == null || rowStyle.ValueType == (Type) null)
        return colStyle.ValueType;
      return rowStyle.ValueType;
    }

    private iGEmptyStringAs GetPropFromStyles_EmptyStringAs(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (cellStyle != null && cellStyle.EmptyStringAs != iGEmptyStringAs.NotSet)
        return cellStyle.EmptyStringAs;
      if (rowStyle != null && rowStyle.EmptyStringAs != iGEmptyStringAs.NotSet)
        return rowStyle.EmptyStringAs;
      if (colStyle.EmptyStringAs == iGEmptyStringAs.NotSet)
        return iGEmptyStringAs.Null;
      return colStyle.EmptyStringAs;
    }

    internal iGContentAlignment GetPropFromStyles_TextAlign(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && !cellStyle.fNotSetTextAlignment)
        return cellStyle.TextAlign;
      if (rowStyle != null && !rowStyle.fNotSetTextAlignment)
        return rowStyle.TextAlign;
      if (colStyle.fNotSetTextAlignment)
        return iGContentAlignment.TopLeft;
      return colStyle.TextAlign;
    }

    private StringAlignment GetPropFromStyles_TextHAlign(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && !cellStyle.fNotSetTextAlignment)
        return cellStyle.fTextHAlign;
      if (rowStyle != null && !rowStyle.fNotSetTextAlignment)
        return rowStyle.fTextHAlign;
      if (colStyle.fNotSetTextAlignment)
        return StringAlignment.Near;
      return colStyle.fTextHAlign;
    }

    private StringAlignment GetPropFromStyles_TextVAlign(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && !cellStyle.fNotSetTextAlignment)
        return cellStyle.fTextVAlign;
      if (rowStyle != null && !rowStyle.fNotSetTextAlignment)
        return rowStyle.fTextVAlign;
      if (colStyle.fNotSetTextAlignment)
        return StringAlignment.Near;
      return colStyle.fTextVAlign;
    }

    private iGCellEditorBase GetPropFromStyles_CustomEditor(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (cellStyle != null && cellStyle.CustomEditor != null)
        return cellStyle.CustomEditor;
      if (rowStyle == null || rowStyle.CustomEditor == null)
        return colStyle.CustomEditor;
      return rowStyle.CustomEditor;
    }

    private int GetPropFromStyles_MaxInputLength(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (cellStyle != null)
        return cellStyle.MaxInputLength;
      if (rowStyle == null)
        return colStyle.MaxInputLength;
      return rowStyle.MaxInputLength;
    }

    internal iGIndent GetPropFromStyles_ContentIndent(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      return new iGIndent()
      {
        fLeft = cellStyle == null || cellStyle.ContentIndent.fLeft == iGIndent.fNotSetIndent.fLeft ? (rowStyle == null || rowStyle.ContentIndent.fLeft == iGIndent.fNotSetIndent.fLeft ? (colStyle.ContentIndent.fLeft != iGIndent.fNotSetIndent.fLeft ? colStyle.ContentIndent.fLeft : iGStyleBase.cSuperIndent.fLeft) : rowStyle.ContentIndent.fLeft) : cellStyle.ContentIndent.fLeft,
        fRight = cellStyle == null || cellStyle.ContentIndent.fRight == iGIndent.fNotSetIndent.fRight ? (rowStyle == null || rowStyle.ContentIndent.fRight == iGIndent.fNotSetIndent.fRight ? (colStyle.ContentIndent.fRight != iGIndent.fNotSetIndent.fRight ? colStyle.ContentIndent.fRight : iGStyleBase.cSuperIndent.fRight) : rowStyle.ContentIndent.fRight) : cellStyle.ContentIndent.fRight,
        fTop = cellStyle == null || cellStyle.ContentIndent.fTop == iGIndent.fNotSetIndent.fTop ? (rowStyle == null || rowStyle.ContentIndent.fTop == iGIndent.fNotSetIndent.fTop ? (colStyle.ContentIndent.fTop != iGIndent.fNotSetIndent.fTop ? colStyle.ContentIndent.fTop : iGStyleBase.cSuperIndent.fTop) : rowStyle.ContentIndent.fTop) : cellStyle.ContentIndent.fTop,
        fBottom = cellStyle == null || cellStyle.ContentIndent.fBottom == iGIndent.fNotSetIndent.fBottom ? (rowStyle == null || rowStyle.ContentIndent.fBottom == iGIndent.fNotSetIndent.fBottom ? (colStyle.ContentIndent.fBottom != iGIndent.fNotSetIndent.fBottom ? colStyle.ContentIndent.fBottom : iGStyleBase.cSuperIndent.fBottom) : rowStyle.ContentIndent.fBottom) : cellStyle.ContentIndent.fBottom
      };
    }

    internal iGTextPosToImage GetPropFromStyles_TextPosToImage(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.TextPosToImage != iGTextPosToImage.NotSet)
        return cellStyle.TextPosToImage;
      if (rowStyle != null && rowStyle.TextPosToImage != iGTextPosToImage.NotSet)
        return rowStyle.TextPosToImage;
      if (colStyle.TextPosToImage == iGTextPosToImage.NotSet)
        return iGTextPosToImage.Horizontally;
      return colStyle.TextPosToImage;
    }

    private iGIndent GetCellTextIndent_NoRightToLeft(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, Size imageSize, iGIndent contentIndent, ContentAlignment imageAlign)
    {
      iGIndent iGindent = contentIndent;
      if (!imageSize.IsEmpty)
      {
        switch (this.GetPropFromStyles_TextPosToImage(cellStyle, rowStyle, colStyle))
        {
          case iGTextPosToImage.Horizontally:
            if (imageAlign <= ContentAlignment.MiddleLeft)
            {
              if (imageAlign != ContentAlignment.TopLeft)
              {
                if (imageAlign != ContentAlignment.TopRight)
                {
                  if (imageAlign != ContentAlignment.MiddleLeft)
                    break;
                }
                else
                  goto label_10;
              }
            }
            else if (imageAlign != ContentAlignment.MiddleRight)
            {
              if (imageAlign != ContentAlignment.BottomLeft)
              {
                if (imageAlign == ContentAlignment.BottomRight)
                  goto label_10;
                else
                  break;
              }
            }
            else
              goto label_10;
            iGindent.fLeft += imageSize.Width + 2;
            break;
label_10:
            iGindent.fRight += imageSize.Width + 2;
            break;
          case iGTextPosToImage.Vertically:
            if (imageAlign <= ContentAlignment.TopRight)
            {
              if ((uint) (imageAlign - 1) <= 1U || imageAlign == ContentAlignment.TopRight)
              {
                iGindent.fTop += imageSize.Height + 2;
                break;
              }
              break;
            }
            if (imageAlign == ContentAlignment.BottomLeft || imageAlign == ContentAlignment.BottomCenter || imageAlign == ContentAlignment.BottomRight)
            {
              iGindent.fBottom += imageSize.Height + 2;
              break;
            }
            break;
        }
      }
      return iGindent;
    }

    internal iGContentAlignment GetPropFromStyles_ImageAlignNative(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.ImageAlign != iGContentAlignment.NotSet)
        return cellStyle.ImageAlign;
      if (rowStyle != null && rowStyle.ImageAlign != iGContentAlignment.NotSet)
        return rowStyle.ImageAlign;
      if (colStyle.ImageAlign == iGContentAlignment.NotSet)
        return iGContentAlignment.TopLeft;
      return colStyle.ImageAlign;
    }

    private ContentAlignment GetPropFromStyles_ImageAlign(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      return (ContentAlignment) this.GetPropFromStyles_ImageAlignNative(cellStyle, rowStyle, colStyle);
    }

    internal iGCellDrawType GetPropFromStyles_DrawType(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.DrawType != iGCellDrawType.NotSet)
        return cellStyle.DrawType;
      if (rowStyle != null && rowStyle.DrawType != iGCellDrawType.NotSet)
        return rowStyle.DrawType;
      if (colStyle.DrawType == iGCellDrawType.NotSet)
        return iGCellDrawType.Text;
      return colStyle.DrawType;
    }

    private iGCustomDrawFlags GetPropFromStyles_CustomDrawFlags(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.CustomDrawFlags != iGCustomDrawFlags.NotSet)
        return cellStyle.CustomDrawFlags;
      if (rowStyle != null && rowStyle.CustomDrawFlags != iGCustomDrawFlags.NotSet)
        return rowStyle.CustomDrawFlags;
      if (colStyle.CustomDrawFlags == iGCustomDrawFlags.NotSet)
        return iGCustomDrawFlags.None;
      return colStyle.CustomDrawFlags;
    }

    internal iGCellDrawTypeFlags GetPropFromStyles_DrawTypeFlags(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.DrawTypeFlags != iGCellDrawTypeFlags.NotSet)
        return cellStyle.DrawTypeFlags;
      if (rowStyle != null && rowStyle.DrawTypeFlags != iGCellDrawTypeFlags.NotSet)
        return rowStyle.DrawTypeFlags;
      if (colStyle.DrawTypeFlags == iGCellDrawTypeFlags.NotSet)
        return iGCellDrawTypeFlags.None;
      return colStyle.DrawTypeFlags;
    }

    private iGCellDrawFlags GetPropFromStyles_DrawFlags(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.DrawFlags != iGCellDrawFlags.NotSet)
        return cellStyle.DrawFlags;
      if (rowStyle != null && rowStyle.DrawFlags != iGCellDrawFlags.NotSet)
        return rowStyle.DrawFlags;
      if (colStyle.DrawFlags == iGCellDrawFlags.NotSet)
        return iGCellDrawFlags.DisplayText | iGCellDrawFlags.DisplayImage;
      return colStyle.DrawFlags;
    }

    private iGCellFitContentsInViewport GetPropFromStyles_FitContentsInViewport(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (cellStyle != null && cellStyle.FitContentsInViewport != iGCellFitContentsInViewport.NotSet)
        return cellStyle.FitContentsInViewport;
      if (rowStyle != null && rowStyle.FitContentsInViewport != iGCellFitContentsInViewport.NotSet)
        return rowStyle.FitContentsInViewport;
      if (colStyle.FitContentsInViewport == iGCellFitContentsInViewport.NotSet)
        return iGCellFitContentsInViewport.None;
      return colStyle.FitContentsInViewport;
    }

    internal bool GetPropFromStyles_Enabled(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (cellStyle != null && cellStyle.Enabled != iGBool.NotSet)
        return cellStyle.Enabled == iGBool.True;
      if (rowStyle != null && rowStyle.Enabled != iGBool.NotSet)
        return rowStyle.Enabled == iGBool.True;
      if (colStyle.Enabled == iGBool.NotSet)
        return true;
      return colStyle.Enabled == iGBool.True;
    }

    private bool GetPropFromStyles_ReadOnly(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (cellStyle != null && cellStyle.ReadOnly != iGBool.NotSet)
        return cellStyle.ReadOnly == iGBool.True;
      if (rowStyle != null && rowStyle.ReadOnly != iGBool.NotSet)
        return rowStyle.ReadOnly == iGBool.True;
      if (colStyle.ReadOnly == iGBool.NotSet)
        return this.fReadOnly;
      return colStyle.ReadOnly == iGBool.True;
    }

    private bool GetPropFromStyles_SingleClickEdit(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (cellStyle != null && cellStyle.SingleClickEdit != iGBool.NotSet)
        return cellStyle.SingleClickEdit == iGBool.True;
      if (rowStyle != null && rowStyle.SingleClickEdit != iGBool.NotSet)
        return rowStyle.SingleClickEdit == iGBool.True;
      if (colStyle.SingleClickEdit == iGBool.NotSet)
        return this.fSingleClickEdit;
      return colStyle.SingleClickEdit == iGBool.True;
    }

    private bool GetPropFromStyles_Selectable(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (cellStyle != null && cellStyle.Selectable != iGBool.NotSet)
        return cellStyle.Selectable == iGBool.True;
      if (rowStyle != null && rowStyle.Selectable != iGBool.NotSet)
        return rowStyle.Selectable == iGBool.True;
      if (colStyle.Selectable == iGBool.NotSet)
        return true;
      return colStyle.Selectable == iGBool.True;
    }

    private IiGDropDownControl GetPropFromStyles_DropDownControl(iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      if (cellStyle != null && cellStyle.GetDropDownControl() != null)
        return cellStyle.GetDropDownControl();
      if (rowStyle == null || rowStyle.GetDropDownControl() == null)
        return colStyle.GetDropDownControl();
      return rowStyle.GetDropDownControl();
    }

    private IiGDropDownControl GetUniCellDropDownControl(iGGridSection gridSection, int rowIndex, int colIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, bool isAutoComplete)
    {
      IiGDropDownControl control = this.GetPropFromStyles_DropDownControl(cellStyle, rowStyle, colStyle);
      if (gridSection == iGGridSection.Cells && rowIndex != -1)
        control = !isAutoComplete ? this.DoRequestDropDownControl(rowIndex, colIndex, control) : (IiGDropDownControl) this.DoRequestAutoCompleteContorol(rowIndex, colIndex, control as IiGAutoCompleteControl);
      return control;
    }

    internal int GetUniCellImageIndexInternal(iGGridSection gridSection, int rowIndex, int colIndex, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      return this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle).ImageIndex;
    }

    internal void GetUniCellImageParamsInternal(iGGridSection gridSection, int rowIndex, int colIndex, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGCellDrawType cellType, iGCellDrawTypeFlags cellTypeFlags, iGCellDrawFlags cellFlags, IiGDropDownControl dropDownControl, out bool drawCellImage, out int cellImageIndex, out ImageList cellImageList)
    {
      iGrid.iGCellContents contentsInternal = this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle, cellType, cellTypeFlags, cellFlags, dropDownControl);
      drawCellImage = contentsInternal.DrawImage;
      cellImageIndex = contentsInternal.ImageIndex;
      cellImageList = contentsInternal.ImageList;
    }

    internal string GetCellText(int rowIndex, int colIndex)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      return this.GetCellTextInternal(rowIndex, colIndex);
    }

    internal string GetCellTextInternal(int rowIndex, int colIndex)
    {
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      iGCellStyle cellStyle1 = this.GetRowDataInternal(rowIndex).CellStyle;
      iGCellStyle cellStyle2 = this.GetColDataInternal(colIndex).CellStyle;
      return this.GetUniCellContentsInternal(iGGridSection.Cells, rowIndex, colIndex, cellDataInternal.Value, cellDataInternal.AuxValue, cellDataInternal.ImageIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2).Text;
    }

    internal string GetFooterCellText(int rowIndex, int colIndex)
    {
      this.CheckFooterCellIndices(rowIndex, colIndex);
      return this.GetFooterCellTextInternal(rowIndex, colIndex);
    }

    internal string GetFooterCellTextInternal(int rowIndex, int colIndex)
    {
      iGFooterCellData footerCellData = this.GetFooterCellData(rowIndex, colIndex);
      iGFooterCellStyle gfooterCellStyle = (iGFooterCellStyle) null;
      iGColData fColData = this.fColDatas[colIndex];
      return this.GetUniCellContentsInternal(iGGridSection.Footer, rowIndex, colIndex, footerCellData.Value, footerCellData.AuxValue, footerCellData.ImageIndex, (iGStyleBase) footerCellData.Style, (iGStyleBase) gfooterCellStyle, (iGStyleBase) fColData.CellStyle).Text;
    }

    internal string GetUniCellTextInternal(iGGridSection gridSection, int rowIndex, int colIndex, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      return this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle).Text;
    }

    internal string GetUniCellTextInternal(iGGridSection gridSection, int rowIndex, int colIndex, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGCellDrawType cellType, iGCellDrawTypeFlags cellTypeFlags, iGCellDrawFlags cellFlags, IiGDropDownControl dropDownControl)
    {
      return this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle, cellType, cellTypeFlags, cellFlags, dropDownControl).Text;
    }

    private iGrid.iGCellContents GetUniCellContentsInternal(iGGridSection gridSection, int rowIndex, int colIndex, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      return this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle, this.GetPropFromStyles_DrawType(cellStyle, rowStyle, colStyle), this.GetPropFromStyles_DrawTypeFlags(cellStyle, rowStyle, colStyle), this.GetPropFromStyles_DrawFlags(cellStyle, rowStyle, colStyle), this.GetPropFromStyles_DropDownControl(cellStyle, rowStyle, colStyle));
    }

    private iGrid.iGCellContents GetUniCellContentsInternal(iGGridSection gridSection, int rowIndex, int colIndex, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGCellDrawType cellType, iGCellDrawTypeFlags cellTypeFlags, iGCellDrawFlags cellFlags, IiGDropDownControl dropDownControl)
    {
      iGrid.iGCellContents iGcellContents;
      if (cellType == iGCellDrawType.Check)
      {
        iGcellContents.DrawText = false;
        iGcellContents.Text = cellDataValue == null ? (string) null : cellDataValue.ToString();
        iGcellContents.DrawImage = false;
        iGcellContents.ImageIndex = -1;
        iGcellContents.ImageList = (ImageList) null;
        iGcellContents.CheckState = this.GetCheckStateFromObjectValue(cellDataValue, cellTypeFlags);
      }
      else
      {
        iGcellContents.DrawText = this.GetCellTextNoDynamicInternal(gridSection, cellDataValue, cellDataAuxValue, cellStyle, rowStyle, colStyle, cellType, cellTypeFlags, cellFlags, dropDownControl, out iGcellContents.Text);
        iGcellContents.ImageIndex = cellDataImageIndex;
        iGcellContents.DrawImage = this.GetCellImageParamsNoDynamic(gridSection, cellStyle, rowStyle, colStyle, cellType, cellFlags, dropDownControl, ref iGcellContents.ImageIndex, out iGcellContents.ImageList);
        iGcellContents.CheckState = CheckState.Indeterminate;
      }
      if (gridSection == iGGridSection.Cells)
        this.DoCellDynamicContents(rowIndex, colIndex, ref iGcellContents.Text, ref iGcellContents.ImageIndex, ref iGcellContents.CheckState);
      if (iGcellContents.Text == null)
        iGcellContents.Text = string.Empty;
      return iGcellContents;
    }

    private bool GetCellImageParamsNoDynamic(iGGridSection gridSection, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGCellDrawType cellType, iGCellDrawFlags cellFlags, IiGDropDownControl dropDownControl, ref int imageIndex, out ImageList imageList)
    {
      imageList = this.GetUniCellImageList(gridSection, cellStyle, rowStyle, colStyle, cellType, dropDownControl);
      return this.DisplayImage(cellFlags);
    }

    private bool DisplayImage(iGCellDrawFlags cellFlags)
    {
      return (cellFlags & iGCellDrawFlags.DisplayImage) == iGCellDrawFlags.DisplayImage;
    }

    internal ImageList GetUniCellImageList(iGGridSection gridSection, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      return this.GetUniCellImageList(gridSection, cellStyle, rowStyle, colStyle, this.GetPropFromStyles_DrawType(cellStyle, rowStyle, colStyle), this.GetPropFromStyles_DropDownControl(cellStyle, rowStyle, colStyle));
    }

    internal ImageList GetUniCellImageList(iGGridSection gridSection, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGCellDrawType type, IiGDropDownControl dropDown)
    {
      ImageList imageList1 = cellStyle == null || cellStyle.ImageList == null ? (rowStyle == null || rowStyle.ImageList == null ? colStyle.fImageList : rowStyle.ImageList) : cellStyle.ImageList;
      if (imageList1 != null)
        return imageList1;
      if (this.CanEditCellWithDropDown(type, dropDown) && dropDown.ImageList != null)
        return dropDown.ImageList;
      ImageList imageList2 = (ImageList) null;
      switch (gridSection)
      {
        case iGGridSection.Header:
          imageList2 = this.fHeaderImageList;
          break;
        case iGGridSection.Cells:
          imageList2 = this.fImageList;
          break;
        case iGGridSection.Footer:
          imageList2 = this.fFooterImageList;
          break;
      }
      return imageList2;
    }

    internal bool GetCellTextNoDynamicInternal(iGGridSection gridSection, object cellDataValue, object cellDataAuxValue, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, iGCellDrawType type, iGCellDrawTypeFlags typeFlags, iGCellDrawFlags flags, IiGDropDownControl dropDownControl, out string text)
    {
      bool flag = (flags & iGCellDrawFlags.DisplayText) == iGCellDrawFlags.DisplayText;
      if (gridSection == iGGridSection.Cells && this.CanEditCellWithDropDown(type, dropDownControl) && ((typeFlags & iGCellDrawTypeFlags.ComboPreferValue) != iGCellDrawTypeFlags.ComboPreferValue && dropDownControl != null) && cellDataAuxValue != null)
      {
        text = cellDataAuxValue.ToString();
        return flag;
      }
      if (cellDataValue == null)
      {
        text = (string) null;
        return flag;
      }
      string stylesFormatString = this.GetPropFromStyles_FormatString(cellStyle, rowStyle, colStyle);
      if (stylesFormatString == null)
      {
        text = cellDataValue.ToString();
        return flag;
      }
      IFormatProvider stylesFormatProvider = this.GetPropFromStyles_FormatProvider(cellStyle, rowStyle, colStyle);
      text = string.Format(stylesFormatProvider, stylesFormatString, new object[1]
      {
        cellDataValue
      });
      return flag;
    }

    private int GetGroupColHdrHeight()
    {
      int num = this.fHeaderRows[0].Height - this.GetHeaderHGridLinesWidth(0);
      IiGControlPaint iGcontrolPaint;
      bool flag;
      if (!this.fHeaderDrawSystem)
      {
        iGcontrolPaint = (IiGControlPaint) null;
        flag = false;
      }
      else if (this.fCustomControlPaint != null && (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.Header) == iGControlPaintFunctions.Header)
      {
        iGcontrolPaint = this.fCustomControlPaint;
        flag = false;
      }
      else
        flag = (uint) ((IiGControlPaintInternal) (iGcontrolPaint = (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint)).GetStyle() > 0U;
      if (flag)
      {
        iGIndent headerIndent = iGcontrolPaint.GetHeaderIndent(false);
        num -= headerIndent.fTop + headerIndent.fBottom;
      }
      return num;
    }

    private void GetGroupBoxDrawParams(bool rightToLeft, out int height, out iGSortData[] groupData, out IiGControlPaint controlPaint, out iGIndent controlPaintIndent, out bool forceNotPaintControl)
    {
      height = this.fHeaderRows[0].Height - this.GetHeaderHGridLinesWidth(0);
      groupData = iGSortObject.GetData(this.fLastGroupObject);
      if (this.fHeaderDrawSystem)
      {
        if (this.fCustomControlPaint != null && (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.Header) == iGControlPaintFunctions.Header)
        {
          controlPaint = this.fCustomControlPaint;
          forceNotPaintControl = false;
        }
        else
        {
          IiGControlPaintInternal controlPaint1 = this.fHeaderControlPaintStyle.ControlPaint;
          controlPaint = (IiGControlPaint) controlPaint1;
          forceNotPaintControl = this.IsForceNotPaintControlForGrouBox(controlPaint1);
        }
        controlPaintIndent = controlPaint.GetHeaderIndent(rightToLeft);
      }
      else
      {
        controlPaint = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.Header) != iGControlPaintFunctions.Header ? (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint : this.fCustomControlPaint;
        controlPaintIndent = new iGIndent(0);
        forceNotPaintControl = false;
      }
    }

    private bool IsForceNotPaintControlForGrouBox(IiGControlPaintInternal controlPaint)
    {
      return (uint) controlPaint.GetStyle() > 0U;
    }

    private int GetGroupObjectColCount()
    {
      if (this.fLastGroupObject != null)
        return this.fLastGroupObject.Count;
      return 0;
    }

    private int GetGroupLevelsExtraWidth()
    {
      return this.GetGroupObjectColCount() * this.fLevelIndent;
    }

    /// <summary>Draws the group box on the specified graphics surface.</summary>
    /// <param name="g">The graphics surface to drawn on.</param>
    /// <param name="x">The X-coordinate of the area where to draw the group box.</param>
    /// <param name="y">The Y-coordinate of the area where to draw the group box.</param>
    /// <param name="width">The width of the area where to draw the group box.</param>
    /// <param name="height">The height of the area where to draw the group box.</param>
    /// <param name="lineColor">Determines the color to draw the lines and borders in the group box with. If this parameter is <see cref="F:System.Drawing.Color.Empty" />, the lines and borders are drawn by using group box colors.</param>
    /// <param name="drawBackground">Indicates whether to draw the group box background.</param>
    /// <param name="drawColHdrBackground">Determines whether to draw the background of the column headers in the group box.</param>
    /// <param name="drawSystemBackground">Determines whether to draw the system background (3D, Flat, or XP) of the column headers in the group box.</param>
    /// <param name="plainSortInfo">Indicates whether to force to draw the sort info flat regardless of its real appearance. The sort info is an arrow indicating the sort order of the column.</param>
    /// <param name="adjustForPrinter">Indicates whether to adjust drawing for printer. If you pass True to this parameter, the grid will not use XP visual styles (as they are not drawn correctly in different DPIs), scale images according to the DPI etc.</param>
    public void DrawGroupBox(Graphics g, int x, int y, int width, int height, System.Drawing.Color lineColor, bool drawBackground, bool drawColHdrBackground, bool drawSystemBackground, bool plainSortInfo, bool adjustForPrinter)
    {
      if (g == null)
        throw new ArgumentNullException(nameof (g));
      if (width < 0)
        throw new ArgumentOutOfRangeException(nameof (width), "Width cannot be negative");
      if (height < 0)
        throw new ArgumentOutOfRangeException(nameof (height), "Height cannot be negative");
      Region clip = g.Clip;
      Region region = clip.Clone();
      region.Intersect(new Rectangle(x, y, width, height));
      g.Clip = region;
      bool headerDrawSystem = this.fHeaderDrawSystem;
      this.fHeaderDrawSystem = drawSystemBackground;
      this.fAdjustDrawingForPrinter = adjustForPrinter;
      this.fDisplayVerticalResolution = this.CreateGraphics().DpiY;
      try
      {
        this.DrawGroupBox(g, x, y, width, height, lineColor, drawBackground, drawColHdrBackground, plainSortInfo, this.RightToLeft == RightToLeft.Yes);
      }
      finally
      {
        this.fHeaderDrawSystem = headerDrawSystem;
        this.fAdjustDrawingForPrinter = false;
        if (clip != null)
        {
          g.Clip = clip;
          region.Dispose();
          clip.Dispose();
        }
      }
    }

    private void DrawGroupBox(Graphics g, int x, int y, int width, int height, System.Drawing.Color lineColor, bool drawBackground, bool drawColHdrBackground, bool plainSortInfo, bool rightToLeft)
    {
      if (!this.fGroupBoxVisible)
        return;
      int height1;
      iGSortData[] groupData;
      IiGControlPaint controlPaint;
      iGIndent controlPaintIndent;
      bool forceNotPaintControl;
      this.GetGroupBoxDrawParams(rightToLeft, out height1, out groupData, out controlPaint, out controlPaintIndent, out forceNotPaintControl);
      if (drawBackground)
      {
        if (!forceNotPaintControl && (controlPaint.SupportedFunctions & iGControlPaintFunctions.GroupBoxBackground) == iGControlPaintFunctions.GroupBoxBackground)
        {
          controlPaint.DrawGroupBoxBackground(g, x, y, width, height, rightToLeft);
        }
        else
        {
          using (Brush brush = (Brush) new SolidBrush(this.GetGroupBoxBackColor()))
            g.FillRectangle(brush, x, y, width, height);
        }
      }
      int groupObjectColCount = this.GetGroupObjectColCount();
      if (groupObjectColCount == 0)
      {
        this.DrawGroupBoxHint(g, x, y, width, rightToLeft);
      }
      else
      {
        this.AdjustGroupColsWidths(g);
        int num1 = x + 6;
        int contentsAndFillY = y + 6;
        if (forceNotPaintControl)
          height1 -= controlPaintIndent.fTop + controlPaintIndent.fBottom;
        System.Drawing.Color color = lineColor;
        if (color.IsEmpty)
          color = this.GetGroupBoxColHdrBorderColor();
        using (Brush brush = (Brush) new SolidBrush(color))
        {
          for (int index = 0; index < groupObjectColCount; ++index)
          {
            int colIndex = groupData[index].ColIndex;
            int fGroupColsWidth = this.fGroupColsWidths[index];
            int num2 = !rightToLeft ? num1 : 2 * x + width - fGroupColsWidth - num1;
            if (forceNotPaintControl)
              this.fHeaderDrawSystem = false;
            if (!this.fHeaderDrawSystem)
              iGDrawGridItem.DrawRectangleWithBrush(g, brush, num2 - 1, contentsAndFillY - 1, fGroupColsWidth + 2, height1 + 2);
            iGControlState state = iGControlState.Normal;
            iGControlState buttonState = iGControlState.Normal;
            this.GetColHdrStates(0, colIndex, out state, out buttonState);
            this.DoDrawColHdr(g, controlPaint, state, buttonState, colIndex, 0, colIndex, num2, contentsAndFillY, fGroupColsWidth, height1, num2, fGroupColsWidth, groupData[index].Order, 0, rightToLeft, true, true, plainSortInfo, true, drawColHdrBackground);
            if (forceNotPaintControl)
              this.fHeaderDrawSystem = true;
            num1 += fGroupColsWidth + 4;
            contentsAndFillY += 10;
            if (index != groupObjectColCount - 1)
            {
              int x1 = num1 - 10;
              int width1 = 10;
              int x2 = num1 - 10;
              if (rightToLeft)
              {
                x1 = 2 * x + width - x1 - width1;
                x2 = 2 * x + width - x2 - 1;
              }
              g.FillRectangle(brush, x1, contentsAndFillY + height1 - 6 - 1, width1, 1);
              g.FillRectangle(brush, x2, contentsAndFillY + height1 - 6 - 4, 1, 4);
            }
          }
        }
      }
    }

    private void DrawGroupBoxHint(Graphics g, int groupBoxX, int groupBoxY, int groupBoxWidth, bool rightToLeft)
    {
      g.TextRenderingHint = this.fTextRenderingHint;
      Font headerFont = this.GetHeaderFont();
      SizeF sizeF = g.MeasureString(this.fUIStrings.fGroupBoxHintText, headerFont);
      StringFormat format = new StringFormat(StringFormatFlags.NoWrap);
      format.Alignment = StringAlignment.Center;
      format.LineAlignment = StringAlignment.Center;
      int width = (int) Math.Ceiling((double) sizeF.Width) + iGStyleBase.cSuperIndent.fLeft + iGStyleBase.cSuperIndent.fRight;
      int height = (int) Math.Ceiling((double) sizeF.Height) + iGStyleBase.cSuperIndent.fTop + iGStyleBase.cSuperIndent.fBottom;
      if (height > this.fHeaderRows[0].Height)
        height = this.fHeaderRows[0].Height;
      int x = groupBoxX + 6;
      int y = groupBoxY + 6 + (this.fHeaderRows[0].Height - height) / 2;
      if (rightToLeft)
      {
        format.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
        x = groupBoxWidth - x - width;
      }
      Brush brush1;
      using (brush1 = (Brush) new SolidBrush(this.GetGroupBoxHintBackColor()))
        g.FillRectangle(brush1, x, y, width, height);
      Brush brush2;
      using (brush2 = (Brush) new SolidBrush(this.GetGroupBoxHintForeColor()))
        g.DrawString(this.fUIStrings.fGroupBoxHintText, headerFont, brush2, (RectangleF) new Rectangle(x, y, width, height), format);
    }

    internal System.Drawing.Color GetGroupBoxColHdrBorderColor()
    {
      if (this.fGroupBoxColHdrBorderColor == System.Drawing.Color.Empty)
        return iGColorManager.GetColorControlDark(this.GetGroupBoxBackColor());
      return this.fGroupBoxColHdrBorderColor;
    }

    internal System.Drawing.Color GetGroupBoxBackColor()
    {
      if (this.fGroupBoxBackColor == System.Drawing.Color.Empty)
        return iGColorManager.GetColorControlDark(this.GetHeaderBackColor());
      return this.fGroupBoxBackColor;
    }

    internal System.Drawing.Color GetGroupBoxHintForeColor()
    {
      if (this.fGroupBoxHintForeColor == System.Drawing.Color.Empty)
        return this.ForeColorDisabled;
      return this.fGroupBoxHintForeColor;
    }

    internal System.Drawing.Color GetGroupBoxHintBackColor()
    {
      if (this.fGroupBoxHintBackColor == System.Drawing.Color.Empty)
        return this.GetHeaderBackColor();
      return this.fGroupBoxHintBackColor;
    }

    internal System.Drawing.Color GetHeaderBackColor()
    {
      return this.fHeaderControlPaintStyle.BackColor;
    }

    private void GetColHdrStates(int rowIndex, int colIndex, out iGControlState state, out iGControlState buttonState)
    {
      if (!this.Enabled)
      {
        state = buttonState = iGControlState.Disabled;
      }
      else
      {
        state = buttonState = iGControlState.Normal;
        if (this.fColHdrDrawnHot.IsEmpty || this.fColHdrDrawnHot.RowIndex != rowIndex || this.fColHdrDrawnHot.ColIndex != colIndex)
          return;
        if (this.Cursor == iGrid.fCursorColResize && this.fMouseData.State == iGControlState.Pressed)
        {
          state = iGControlState.Hot;
          buttonState = iGControlState.Normal;
        }
        else if (this.fColHdrDropDownActive)
        {
          state = iGControlState.Hot;
          buttonState = iGControlState.HotPressed;
        }
        else
        {
          switch (this.fMouseData.State)
          {
            case iGControlState.Hot:
              state = iGControlState.Hot;
              buttonState = this.fMouseData.ElemControl == iGElemControl.None ? iGControlState.Normal : iGControlState.Hot;
              break;
            case iGControlState.Pressed:
              if (this.fHeaderAllowPress && this.fCurColHeaderAllowPress && this.fMouseData.Button == MouseButtons.Left)
              {
                switch (this.fMouseData.ElemControl)
                {
                  case iGElemControl.None:
                    state = iGControlState.Pressed;
                    buttonState = iGControlState.Normal;
                    break;
                  case iGElemControl.ComboButton:
                    state = iGControlState.Hot;
                    buttonState = iGControlState.HotPressed;
                    break;
                }
              }
              else
                break;
                break;
          }
        }
        if (this.fHeaderHotTracking && this.fHotTracking)
          return;
        if (state == iGControlState.Hot)
          state = iGControlState.Normal;
        if (buttonState != iGControlState.Hot)
          return;
        buttonState = iGControlState.Normal;
      }
    }

    private void DrawHeader(Graphics g, int x, int y, int width, int height, Rectangle clipRectangle)
    {
      if (!this.fHeaderVisible)
        return;
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int groupBoxHeight = this.GetGroupBoxHeight();
      if (clipRectangle.IntersectsWith(new Rectangle(x, y, width, groupBoxHeight)))
        this.DrawGroupBox(g, x, y, width, groupBoxHeight, System.Drawing.Color.Empty, true, true, false, rightToLeft);
      int systemBackgroundWidth = this.fRowHeader.EffectiveWidth();
      y += groupBoxHeight;
      height -= groupBoxHeight;
      int height1 = this.GetHeaderAreaHeight() - groupBoxHeight;
      int num1 = y + height1;
      if (!clipRectangle.IntersectsWith(new Rectangle(x, y, width, height1)))
        return;
      IiGControlPaint controlPaint = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.Header) != iGControlPaintFunctions.Header ? (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint : this.fCustomControlPaint;
      iGrid.GridLineParams gridLineStyleParams1 = this.GetGridLineStyleParams(this.fHeaderVGridLinesStyle, iGOrientation.Vertical, true);
      iGrid.GridLineParams gridLineStyleParams2 = this.GetGridLineStyleParams(this.fHeaderHGridLinesStyle, iGOrientation.Horizontal, true);
      iGrid.GridLineParams gridLineStyleParams3 = this.GetGridLineStyleParams(this.fHeaderSeparatingLine, iGOrientation.Horizontal, true);
      iGrid.GridLineParams gridLineStyleParams4 = this.GetGridLineStyleParams(this.fFrozenColsSeparatingLineStyle, iGOrientation.Vertical, false);
      IntPtr rectRgn = iGNativeMethods.CreateRectRgn(0, 0, 0, 0);
      IntPtr hdc1 = g.GetHdc();
      bool flag1 = iGNativeMethods.GetClipRgn(hdc1, rectRgn) == 1;
      g.ReleaseHdc(hdc1);
      Region clip = g.Clip;
      int num2 = !rightToLeft ? this.GetFirstColX(rightToLeft, x + systemBackgroundWidth, width - systemBackgroundWidth) : this.GetFirstColX(rightToLeft, x, width - systemBackgroundWidth);
      bool flag2 = false;
      int notGroupedColCount = this.GetSortedNotGroupedColCount();
      int num3 = -1;
      for (int index = 0; index < this.fHeaderRowCount; ++index)
      {
        if (this.fHeaderRows[index].Visible)
        {
          num3 = index;
          break;
        }
      }
      int[] numArray = new int[this.fHeaderRowCount];
      bool flag3 = true;
      int visibleFrozenColOrder = this.GetLastVisibleFrozenColOrder();
      for (int index1 = 0; index1 < this.fColCount; ++index1)
      {
        if (index1 == this.fFrozenColCount)
        {
          this.SetFrozenColClip(g, num2, x, y, width, height1, rightToLeft);
          num2 = this.GetScrolledX(num2, rightToLeft);
        }
        int num4 = num1;
        int colIndex1 = this.fColIdxFromOrd[index1];
        iGColData fColData1 = this.fColDatas[colIndex1];
        if (this.IsColVisible(fColData1.Visible, fColData1.ShowWhenGrouped, colIndex1))
        {
          int index2 = 0;
          while (index2 < this.fHeaderRowCount)
          {
            iGHdrRowData fHeaderRow1 = this.fHeaderRows[index2];
            if (!fHeaderRow1.Visible)
              ++index2;
            else if (numArray[index2] > index1)
            {
              ++index2;
              num4 -= fHeaderRow1.Height;
            }
            else
            {
              int num5 = index2 * this.fColCount;
              int index3 = num5 + colIndex1;
              int fHeaderSpan = this.fHeaderSpanMap[index3];
              int colIndex2 = fHeaderSpan % this.fColCount;
              int num6 = 0;
              iGSortOrder sortOrder;
              int sortIndex;
              this.GetColSortInfoForDrawing(colIndex1, false, notGroupedColCount, out sortOrder, out sortIndex);
              int index4 = index1;
              for (; this.fHeaderSpanMap[index3] == fHeaderSpan; index3 = num5 + this.fColIdxFromOrd[index4])
              {
                int colIndex3 = this.fColIdxFromOrd[index4];
                iGColData fColData2 = this.fColDatas[colIndex3];
                if (this.IsColVisible(fColData2.Visible, fColData2.ShowWhenGrouped, colIndex3))
                {
                  if (flag3 && index4 == index1)
                    num6 += this.GetGroupLevelsExtraWidth();
                  num6 += fColData2.Width;
                  if (sortIndex >= 0 && this.GetColSortOrder(colIndex3) != sortOrder)
                  {
                    sortIndex = -1;
                    sortOrder = iGSortOrder.None;
                  }
                }
                if (++index4 == this.fColCount)
                  break;
              }
              int num7 = !rightToLeft ? num2 : num2 - num6;
              if (sortIndex > 0 && index4 > index1 + 1)
                sortIndex = 0;
              int index5 = num5 + colIndex1;
              int num8 = num4;
              int rowIndex = index2;
              while (this.fHeaderSpanMap[index5] == fHeaderSpan)
              {
                index5 += this.fColCount;
                iGHdrRowData fHeaderRow2 = this.fHeaderRows[index2];
                numArray[index2] = index4;
                if (fHeaderRow2.Visible)
                  num8 -= fHeaderRow2.Height;
                if (++index2 == this.fHeaderRowCount)
                  break;
              }
              if (clipRectangle.IntersectsWith(new Rectangle(num7, num8, num6, num4 - num8)))
              {
                iGControlState state;
                iGControlState buttonState;
                this.GetColHdrStates(rowIndex, colIndex2, out state, out buttonState);
                int num9;
                if (gridLineStyleParams4.Visible && index4 == visibleFrozenColOrder + 1)
                {
                  num9 = this.fFrozenColsSeparatingLineStyle.Width;
                  if (!flag2)
                  {
                    int num10 = num7 - gridLineStyleParams4.PenOffset;
                    int num11 = !rightToLeft ? num10 + num6 : num10 + num9;
                    g.DrawLine(gridLineStyleParams4.Pen, num11, y, num11, num1 + gridLineStyleParams4.PenExtra);
                    flag2 = true;
                  }
                }
                else if (gridLineStyleParams1.Visible)
                {
                  num9 = this.fHeaderVGridLinesStyle.Width;
                  int num10 = num7 - gridLineStyleParams1.PenOffset;
                  int num11 = !rightToLeft ? num10 + num6 : num10 + num9;
                  g.DrawLine(gridLineStyleParams1.Pen, num11, num8, num11, num4 + gridLineStyleParams1.PenExtra);
                }
                else
                  num9 = 0;
                int num12;
                if (rowIndex == num3 && gridLineStyleParams3.Visible)
                  num12 = this.fHeaderSeparatingLine.Width;
                else if (gridLineStyleParams2.Visible)
                {
                  num12 = this.fHeaderHGridLinesStyle.Width;
                  int num10 = num4 - gridLineStyleParams2.PenOffset;
                  g.DrawLine(gridLineStyleParams2.Pen, num7, num10, num7 + num6 + gridLineStyleParams2.PenExtra, num10);
                }
                else
                  num12 = 0;
                int contentsAndFillX = num7;
                if (rightToLeft)
                  contentsAndFillX += num9;
                this.DoDrawColHdr(g, controlPaint, state, buttonState, fHeaderSpan, rowIndex, colIndex2, contentsAndFillX, num8, num6 - num9, num4 - num8 - num12, num7, num6, sortOrder, sortIndex, rightToLeft, false, false, false, true, true);
              }
              num4 = num8;
            }
          }
          if (rightToLeft)
          {
            num2 -= fColData1.Width;
            if (flag3)
              num2 -= this.GetGroupLevelsExtraWidth();
            if (num2 <= x)
              break;
          }
          else
          {
            num2 += fColData1.Width;
            if (flag3)
              num2 += this.GetGroupLevelsExtraWidth();
            if (num2 >= x + width)
              break;
          }
          flag3 = false;
        }
      }
      if (num2 < x + width && !rightToLeft || num2 > x & rightToLeft)
      {
        int width1;
        if (rightToLeft)
        {
          width1 = num2 - x;
          num2 = x;
        }
        else
          width1 = x + width - num2;
        int height2 = height1;
        if (gridLineStyleParams3.Visible)
          height2 -= this.fHeaderSeparatingLine.Width;
        else if (gridLineStyleParams2.Visible)
          height2 -= this.fHeaderHGridLinesStyle.Width;
        if (this.fHeaderDrawSystem)
        {
          controlPaint.DrawHeader(g, num2, y, width1, height2, iGHeaderPart.ItemRight, iGControlState.Normal, rightToLeft);
        }
        else
        {
          using (Brush brush = (Brush) new SolidBrush(this.GetHeaderBackColor()))
            g.FillRectangle(brush, num2, y, width1, height2);
        }
        if (gridLineStyleParams2.Visible && !gridLineStyleParams3.Visible)
        {
          int num4 = num1 - gridLineStyleParams2.PenOffset - this.fHeaderSeparatingLine.Width;
          g.DrawLine(gridLineStyleParams2.Pen, num2, num4, num2 + width1 - gridLineStyleParams2.PenExtra, num4);
        }
      }
      IntPtr hdc2 = g.GetHdc();
      if (flag1)
        iGNativeMethods.SelectClipRgn(hdc2, rectRgn);
      else
        iGNativeMethods.SelectClipRgn(hdc2, IntPtr.Zero);
      g.ReleaseHdc(hdc2);
      iGNativeMethods.DeleteObject(rectRgn);
      g.Clip = clip;
      int num13 = !rightToLeft ? x : x + width - systemBackgroundWidth;
      int num14 = systemBackgroundWidth;
      int y1 = y;
      int num15 = height1;
      int num16 = !gridLineStyleParams3.Visible ? (!gridLineStyleParams2.Visible ? 0 : this.fHeaderHGridLinesStyle.Width) : this.fHeaderSeparatingLine.Width;
      int num17;
      if (gridLineStyleParams1.Visible)
      {
        num17 = this.fHeaderVGridLinesStyle.Width;
        int num4 = !rightToLeft ? num13 + num14 - gridLineStyleParams1.PenOffset : num13 + this.fHeaderVGridLinesStyle.Width - gridLineStyleParams1.PenOffset;
        g.DrawLine(gridLineStyleParams1.Pen, num4, y1, num4, y1 + num15 + gridLineStyleParams1.PenExtra);
      }
      else
        num17 = 0;
      int contentsAndFillX1 = num13;
      int contentsAndFillWidth = num14 - num17;
      if (rightToLeft)
        contentsAndFillX1 += num17;
      int contentsAndFillY = y1;
      int contentsAndFillHeight = num15 - num16;
      iGControlState state1 = this.fMouseData.IsEmpty || this.fMouseData.Area != iGMouseArea.Header || !this.fMouseData.IsHeaderRowHdr ? iGControlState.Normal : this.fMouseData.State;
      this.DoDrawRowHdrHdr(g, contentsAndFillX1, contentsAndFillY, contentsAndFillWidth, contentsAndFillHeight, num13, systemBackgroundWidth, state1, true, rightToLeft);
      if (gridLineStyleParams2.Visible && !gridLineStyleParams3.Visible)
      {
        int num4 = num1 - gridLineStyleParams2.PenOffset;
        g.DrawLine(gridLineStyleParams2.Pen, num13, num4, num13 + systemBackgroundWidth - gridLineStyleParams2.PenExtra, num4);
      }
      if (gridLineStyleParams3.Visible)
      {
        int num4 = num1 - gridLineStyleParams3.PenOffset;
        g.DrawLine(gridLineStyleParams3.Pen, x, num4, x + width - gridLineStyleParams3.PenExtra, num4);
      }
      if (gridLineStyleParams3.Pen != null)
        gridLineStyleParams3.Pen.Dispose();
      if (gridLineStyleParams4.Pen != null)
        gridLineStyleParams4.Pen.Dispose();
      if (gridLineStyleParams1.Pen != null)
        gridLineStyleParams1.Pen.Dispose();
      if (gridLineStyleParams2.Pen == null)
        return;
      gridLineStyleParams2.Pen.Dispose();
    }

    private void DoDrawRowHdrHdr(Graphics g, int contentsAndFillX, int contentsAndFillY, int contentsAndFillWidth, int contentsAndFillHeight, int systemBackgroundX, int systemBackgroundWidth, iGControlState state, bool fillBackground, bool rightToLeft)
    {
      if (g == null)
        throw new ArgumentNullException(nameof (g));
      if (this.fHeaderDrawSystem)
      {
        if (systemBackgroundWidth <= 0 || contentsAndFillHeight <= 0)
          return;
        (this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.Header) != iGControlPaintFunctions.Header ? (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint : this.fCustomControlPaint).DrawHeader(g, systemBackgroundX, contentsAndFillY, systemBackgroundWidth, contentsAndFillHeight, iGHeaderPart.Item, state, rightToLeft);
      }
      else
      {
        if (!fillBackground || contentsAndFillWidth <= 0 || contentsAndFillHeight <= 0)
          return;
        using (SolidBrush solidBrush = new SolidBrush(this.fHeaderControlPaintStyle.BackColor))
          g.FillRectangle((Brush) solidBrush, contentsAndFillX, contentsAndFillY, contentsAndFillWidth, contentsAndFillHeight);
      }
    }

    private iGHdrHotTrackFlags GetHotTrackFlags()
    {
      if (this.fHeaderDrawSystem && this.fHeaderControlPaintStyle.IsXP)
        return this.fHotTrackFlagsXPStyles;
      return this.fHotTrackFlags;
    }

    private int GetSortAreaWidth(Graphics g, int sortIndex, IiGControlPaint controlPaint, Font font, iGColHdrStyle cellStyle, iGColHdrStyle colStyle, bool forceDrawSortInfo, bool plainSortInfo)
    {
      if (sortIndex >= 0)
      {
        int arrowWidth;
        int arrowHeight;
        Size textSize;
        string text;
        return this.GetSortAreaWidth(g, sortIndex, controlPaint, font, cellStyle, colStyle, forceDrawSortInfo, plainSortInfo, out arrowWidth, out arrowHeight, out textSize, out text);
      }
      return 0;
    }

    private int GetSortAreaWidth(Graphics g, int sortIndex, IiGControlPaint controlPaint, Font font, iGColHdrStyle cellStyle, iGColHdrStyle colStyle, bool forceDrawSortInfo, bool plainSortInfo, out int arrowWidth, out int arrowHeight, out Size textSize, out string text)
    {
      int num1 = 0;
      if (sortIndex >= 0 && (forceDrawSortInfo || this.GetColHdrSortInfoVisible(cellStyle, colStyle)))
      {
        int num2 = 6;
        if (sortIndex > 0)
        {
          text = sortIndex.ToString();
          g.TextRenderingHint = this.fTextRenderingHint;
          textSize = g.MeasureString(text, font).ToSize();
          num2 += textSize.Width;
        }
        else
        {
          text = (string) null;
          textSize = Size.Empty;
        }
        if (plainSortInfo || !this.fHeaderDrawSystem)
        {
          arrowWidth = 9;
          arrowHeight = 5;
        }
        else
        {
          Size headerSortIconSize = controlPaint.GetHeaderSortIconSize();
          arrowWidth = headerSortIconSize.Width;
          arrowHeight = headerSortIconSize.Height;
        }
        num1 = num2 + arrowWidth;
      }
      else
      {
        arrowWidth = 0;
        arrowHeight = 0;
        text = (string) null;
        textSize = Size.Empty;
      }
      return num1;
    }

    /// <summary>Draws the contents of the row header's header on the specified graphics surface.</summary>
    /// <param name="g">The graphics surface to drawn on.</param>
    /// <param name="x">The X-coordinate of the header area with the grid lines area excluded.</param>
    /// <param name="y">The Y-coordinate of the header area with the grid lines area excluded.</param>
    /// <param name="width">The width of the header area with the grid lines area excluded.</param>
    /// <param name="height">The height of the header area with the grid lines area excluded.</param>
    /// <param name="drawBackground">Indicates whether to draw the header background. This parameter does not affect the system style background.</param>
    /// <param name="drawSystemBackground">Indicates whether to draw the system background (XP, 3D or Flat).</param>
    /// <param name="systemBackgroundX">The X-coordinate of the area where the system style background (3D, Flat, or XP) should be drawn.</param>
    /// <param name="systemBackgroundWidth">The width of the area where the system style background (3D, Flat, or XP) should be drawn.</param>
    /// <param name="adjustForPrinter">Indicates whether to adjust drawing for printer. If you pass True to this parameter, the grid will not use XP visual styles (as they are not drawn correctly in different DPIs), will scale images according to the DPI etc.</param>
    public void DrawRowHeaderColHdrContents(Graphics g, int x, int y, int width, int height, bool drawBackground, bool drawSystemBackground, int systemBackgroundX, int systemBackgroundWidth, bool adjustForPrinter)
    {
      bool useXp = this.fHeaderControlPaintStyle.UseXP;
      if (adjustForPrinter)
        this.fHeaderControlPaintStyle.UseXP = false;
      bool headerDrawSystem = this.fHeaderDrawSystem;
      this.fHeaderDrawSystem = drawSystemBackground;
      this.fAdjustDrawingForPrinter = adjustForPrinter;
      this.fDisplayVerticalResolution = this.CreateGraphics().DpiY;
      try
      {
        this.DoDrawRowHdrHdr(g, x, y, width, height, systemBackgroundX, systemBackgroundWidth, iGControlState.Normal, drawBackground, this.RightToLeft == RightToLeft.Yes);
      }
      finally
      {
        this.fHeaderDrawSystem = headerDrawSystem;
        this.fAdjustDrawingForPrinter = false;
        if (adjustForPrinter)
          this.fHeaderControlPaintStyle.UseXP = useXp;
      }
    }

    /// <summary>Draws the contents of the specified column header on the specified graphics surface.</summary>
    /// <param name="g">The graphics surface to drawn on.</param>
    /// <param name="rowIndex">The row index of the column header to be drawn.</param>
    /// <param name="colIndex">The column index of the column header to be drawn.</param>
    /// <param name="x">The X-coordinate of the column header area with the grid lines area excluded.</param>
    /// <param name="y">The Y-coordinate of the column header area with the grid lines area excluded.</param>
    /// <param name="width">The width of the column header area with the grid lines area excluded.</param>
    /// <param name="height">The height of the column header area with the grid lines area excluded.</param>
    /// <param name="drawBackground">Indicates whether the column header background should be drawn. This parameter does not affect the system style background.</param>
    /// <param name="drawSystemBackground">Indicates whether to draw the system background (XP, 3D or Flat).</param>
    /// <param name="systemBackgroundX">The X-coordinate of the area where the system style background (3D, Flat, or XP) should be drawn.</param>
    /// <param name="systemBackgroundWidth">The width of the area where the system style background (3D, Flat, or XP) should be drawn.</param>
    /// <param name="plainSortInfo">Indicates whether to force to draw the sort info (if it present there) flat regardless of its real appearance. The sort info is an arrow indicating the sort order of the column.</param>
    /// <param name="drawComboButton">Specifies whether to draw the combo button.</param>
    /// <param name="adjustForPrinter">Indicates whether to adjust drawing for printer. If you pass True to this parameter, the grid will not use XP visual styles (as they are not drawn correctly in different DPIs), will scale images according to the DPI etc.</param>
    public void DrawColHdrContents(Graphics g, int rowIndex, int colIndex, int x, int y, int width, int height, bool drawBackground, bool drawSystemBackground, int systemBackgroundX, int systemBackgroundWidth, bool plainSortInfo, bool drawComboButton, bool adjustForPrinter)
    {
      ++colIndex;
      if (g == null)
        throw new ArgumentNullException(nameof (g));
      this.CheckColHdrIndices(rowIndex, colIndex);
      if (width < 0)
        throw new ArgumentOutOfRangeException(nameof (width), "Width cannot be negative");
      if (height < 0)
        throw new ArgumentOutOfRangeException(nameof (height), "Height cannot be negative");
      if (systemBackgroundWidth < 0)
        throw new ArgumentOutOfRangeException(nameof (systemBackgroundWidth), "The background width cannot be negative");
      iGSortOrder sortOrder;
      int sortIndex;
      this.GetColHdrSortInfoForDrawing(rowIndex, colIndex, false, out sortOrder, out sortIndex);
      bool useXp = this.fHeaderControlPaintStyle.UseXP;
      if (adjustForPrinter)
        this.fHeaderControlPaintStyle.UseXP = false;
      bool headerDrawSystem = this.fHeaderDrawSystem;
      this.fHeaderDrawSystem = drawSystemBackground;
      this.fAdjustDrawingForPrinter = adjustForPrinter;
      this.fDisplayVerticalResolution = this.CreateGraphics().DpiY;
      try
      {
        this.DoDrawColHdr(g, (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint, iGControlState.Normal, iGControlState.Normal, this.fHeaderSpanMap[rowIndex * this.fColCount + colIndex], rowIndex, colIndex, x, y, width, height, systemBackgroundX, systemBackgroundWidth, sortOrder, sortIndex, this.RightToLeft == RightToLeft.Yes, false, false, plainSortInfo, drawComboButton, drawBackground);
      }
      finally
      {
        this.fHeaderDrawSystem = headerDrawSystem;
        this.fAdjustDrawingForPrinter = false;
        if (adjustForPrinter)
          this.fHeaderControlPaintStyle.UseXP = useXp;
      }
    }

    private void DoDrawColHdr(Graphics g, IiGControlPaint controlPaint, iGControlState cellState, iGControlState buttonState, int headerMapValue, int rowIndex, int colIndex, int contentsAndFillX, int contentsAndFillY, int contentsAndFillWidth, int contentsAndFillHeight, int systemX, int systemWidth, iGSortOrder sortOrder, int sortIndex, bool rightToLeft, bool forceSortAreaRightAlign, bool forceDrawSortInfo, bool plainSortInfo, bool drawComboButton, bool fillBackground)
    {
      iGColHdrData fColHdr = this.fColHdrs[headerMapValue];
      iGColHdrStyle colHdrStyle = this.fColDatas[colIndex].ColHdrStyle;
      if (this.fHeaderDrawSystem)
      {
        iGControlState controlState = cellState;
        if (controlState == iGControlState.Hot && (this.GetHotTrackFlags() & iGHdrHotTrackFlags.Background) == iGHdrHotTrackFlags.None)
          controlState = iGControlState.Normal;
        controlPaint.DrawHeader(g, systemX, contentsAndFillY, systemWidth, contentsAndFillHeight, iGHeaderPart.Item, controlState, rightToLeft);
        iGIndent headerIndent = controlPaint.GetHeaderIndent(rightToLeft);
        contentsAndFillX += headerIndent.fLeft;
        contentsAndFillWidth -= headerIndent.fRight + headerIndent.fLeft;
        contentsAndFillY += headerIndent.fTop;
        contentsAndFillHeight -= headerIndent.fTop + headerIndent.fBottom;
      }
      System.Drawing.Color backColor;
      System.Drawing.Color foreColor;
      Font font;
      this.GetUniCellFormattingNoSelected(iGGridSection.Header, rowIndex, colIndex, (iGStyleBase) fColHdr.Style, (iGStyleBase) null, (iGStyleBase) colHdrStyle, cellState, false, false, false, false, out backColor, out foreColor, out font);
      this.DrawUniCellContents(iGGridSection.Header, g, controlPaint, rowIndex, colIndex, contentsAndFillX, contentsAndFillY, contentsAndFillWidth, contentsAndFillHeight, fillBackground, int.MinValue, contentsAndFillY, contentsAndFillWidth, contentsAndFillHeight, fColHdr.Value, (object) null, fColHdr.ImageIndex, (iGStyleBase) fColHdr.Style, (iGStyleBase) null, (iGStyleBase) colHdrStyle, false, false, false, false, false, cellState, buttonState, false, false, false, iGRowType.Normal, iGTreeButtonState.Absent, false, Size.Empty, 0, iGTreeBranchState.None, (Pen) null, drawComboButton, false, false, backColor, foreColor, font, sortOrder, sortIndex, forceDrawSortInfo, plainSortInfo, forceSortAreaRightAlign);
      this.CheckDisposeFontForPrinter(font);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawColHdrForeground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawColHdrEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawColHdrForeground(iGCustomDrawColHdrEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawColHdrForeground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawColHdrForeground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawColHdrBackground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawColHdrEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawColHdrBackground(iGCustomDrawColHdrEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawColHdrBackground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawColHdrBackground((object) this, e);
    }

    private bool GetColHdrSortInfoVisible(iGColHdrStyle cellStyle, iGColHdrStyle colStyle)
    {
      if (cellStyle != null && cellStyle.SortInfoVisible != iGBool.NotSet)
        return cellStyle.SortInfoVisible == iGBool.True;
      if (colStyle.SortInfoVisible == iGBool.NotSet)
        return true;
      return colStyle.SortInfoVisible == iGBool.True;
    }

    private void DrawFooter(Graphics g, int x, int y, int width, int height, Rectangle clipRectangle)
    {
      if (!this.fFooterVisible || this.fFooterRowCount <= 0 || (width <= 0 || height <= 0) || !clipRectangle.IntersectsWith(new Rectangle(x, y, width, height)))
        return;
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      this.GetRowTextEndVisibleColOrder();
      int num1 = this.fRowHeader.EffectiveWidth();
      SolidBrush solidBrush1 = new SolidBrush(this.fFooterForeColor);
      IiGControlPaint controlPaint = (IiGControlPaint) this.fCellControlPaintStyle.ControlPaint;
      iGrid.GridLineParams gridLineStyleParams1 = this.GetGridLineStyleParams(this.fVGridLinesStyle, iGOrientation.Vertical, false);
      iGrid.GridLineParams gridLineStyleParams2 = this.GetGridLineStyleParams(this.fHGridLinesStyle, iGOrientation.Horizontal, false);
      iGrid.GridLineParams gridLineStyleParams3 = this.GetGridLineStyleParams(this.fFrozenColsSeparatingLineStyle, iGOrientation.Vertical, false);
      iGrid.GridLineParams gridLineStyleParams4 = this.GetGridLineStyleParams(this.fFooterSeparatingLine, iGOrientation.Horizontal, true);
      iGrid.GridLineParams gridLineStyleParams5 = this.GetGridLineStyleParams(this.fVLastColGridLineStyle, iGOrientation.Vertical, false);
      IntPtr rectRgn = iGNativeMethods.CreateRectRgn(0, 0, 0, 0);
      IntPtr hdc1 = g.GetHdc();
      bool flag1 = iGNativeMethods.GetClipRgn(hdc1, rectRgn) == 1;
      g.ReleaseHdc(hdc1);
      Region clip = g.Clip;
      using (SolidBrush solidBrush2 = new SolidBrush(this.GetFooterBackColor()))
        g.FillRectangle((Brush) solidBrush2, x, y, width, height);
      if (gridLineStyleParams4.Visible)
      {
        int num2 = y + gridLineStyleParams4.PenOffset - 1;
        g.DrawLine(gridLineStyleParams4.Pen, x, num2, x + width + gridLineStyleParams4.PenExtra, num2);
      }
      int[] numArray = new int[this.fFooterRowCount];
      bool flag2 = true;
      int visibleFrozenColOrder = this.GetLastVisibleFrozenColOrder();
      int num3 = this.GetFirstColX(rightToLeft, rightToLeft ? x : x + num1, width - num1);
      int num4 = -1;
      for (int index = 0; index < this.fFooterRowCount; ++index)
      {
        if (this.fFooterRows[index].Visible)
        {
          num4 = index;
          break;
        }
      }
      for (int index1 = 0; index1 < this.fColCount; ++index1)
      {
        if (index1 == this.fFrozenColCount)
        {
          this.SetFrozenColClip(g, num3, x, y, width, height, rightToLeft);
          num3 = this.GetScrolledX(num3, rightToLeft);
        }
        int colIndex1 = this.fColIdxFromOrd[index1];
        iGColData fColData1 = this.fColDatas[colIndex1];
        if (this.IsColVisible(fColData1.Visible, fColData1.ShowWhenGrouped, colIndex1))
        {
          int num2 = y;
          int index2 = 0;
          while (index2 < this.fFooterRowCount)
          {
            int num5 = num2;
            iGFooterRowData fFooterRow1 = this.fFooterRows[index2];
            if (!fFooterRow1.Visible)
              ++index2;
            else if (numArray[index2] > index1)
            {
              ++index2;
              if (fFooterRow1.Visible)
                num2 += fFooterRow1.Height;
            }
            else
            {
              int num6 = index2 * this.fColCount;
              int index3 = num6 + colIndex1;
              int fFooterSpan = this.fFooterSpanMap[index3];
              int num7 = fFooterSpan % this.fColCount;
              int width1 = 0;
              int index4 = 0;
              int index5 = index1;
              for (; this.fFooterSpanMap[index3] == fFooterSpan; index3 = num6 + this.fColIdxFromOrd[index5])
              {
                int colIndex2 = this.fColIdxFromOrd[index5];
                iGColData fColData2 = this.fColDatas[colIndex2];
                if (this.IsColVisible(fColData2.Visible, fColData2.ShowWhenGrouped, colIndex2))
                {
                  if (flag2 && index5 == index1)
                    width1 += this.GetGroupLevelsExtraWidth();
                  index4 = index5;
                  width1 += fColData2.Width;
                }
                if (++index5 == this.fColCount)
                  break;
              }
              bool lastVisibleCol = this.fColIdxFromOrd[index4] == this.fLastVisibleColIndex;
              bool lastVisibleFrozenCol = index4 == visibleFrozenColOrder;
              int num8 = !rightToLeft ? num3 : num3 - width1;
              int index6 = num6 + colIndex1;
              int rowIndex = index2;
              while (this.fFooterSpanMap[index6] == fFooterSpan)
              {
                index6 += this.fColCount;
                iGFooterRowData fFooterRow2 = this.fFooterRows[index2];
                numArray[index2] = index5;
                if (fFooterRow2.Visible)
                  num5 += fFooterRow2.Height;
                if (++index2 == this.fFooterRowCount)
                  break;
              }
              int height1 = num5 - num2;
              if (clipRectangle.IntersectsWith(new Rectangle(num8, num2, width1, height1)))
              {
                iGFooterCellData footerCellData = this.GetFooterCellData(rowIndex, colIndex1);
                iGFooterCellStyle style = footerCellData.Style;
                iGFooterCellStyle gfooterCellStyle = (iGFooterCellStyle) null;
                System.Drawing.Color backColor;
                System.Drawing.Color foreColor;
                Font font;
                this.GetUniCellFormattingNoSelected(iGGridSection.Footer, rowIndex, colIndex1, (iGStyleBase) style, (iGStyleBase) gfooterCellStyle, (iGStyleBase) fColData1.CellStyle, iGControlState.Normal, false, false, false, false, out backColor, out foreColor, out font);
                bool visible1;
                int width2;
                if (rowIndex == num4)
                {
                  visible1 = gridLineStyleParams4.Visible;
                  width2 = this.fFooterSeparatingLine.Width;
                }
                else
                {
                  visible1 = gridLineStyleParams2.Visible;
                  width2 = this.fHGridLinesStyle.Width;
                }
                bool visible2;
                int width3;
                this.GetVGridLineWidthAndVisible(lastVisibleCol, lastVisibleFrozenCol, gridLineStyleParams5.Visible, gridLineStyleParams3.Visible, gridLineStyleParams1.Visible, out visible2, out width3);
                int contentsX = num8;
                if (rightToLeft)
                  contentsX += width3;
                int contentsY = num2 + width2;
                int contentsWidth = width1 - width3;
                int contentsHeight = height1 - width2;
                int backgroundX;
                int backgroundWidth;
                if (visible2 && width3 > 0)
                {
                  backgroundX = contentsX;
                  backgroundWidth = contentsWidth;
                }
                else
                {
                  backgroundX = num8;
                  backgroundWidth = width1;
                }
                int backgroundY;
                int backgroundHeight;
                if (visible1 && width2 > 0)
                {
                  backgroundY = contentsY;
                  backgroundHeight = contentsHeight;
                }
                else
                {
                  backgroundY = num2;
                  backgroundHeight = height1;
                }
                this.DrawUniCellContents(iGGridSection.Footer, g, controlPaint, rowIndex, colIndex1, contentsX, contentsY, contentsWidth, contentsHeight, true, backgroundX, backgroundY, backgroundWidth, backgroundHeight, footerCellData.Value, footerCellData.AuxValue, footerCellData.ImageIndex, (iGStyleBase) style, (iGStyleBase) gfooterCellStyle, (iGStyleBase) fColData1.CellStyle, false, false, false, false, false, iGControlState.Normal, iGControlState.Normal, false, false, false, iGRowType.Normal, iGTreeButtonState.Absent, true, Size.Empty, 0, iGTreeBranchState.None, (Pen) null, false, false, false, backColor, foreColor, font, iGSortOrder.None, -1, false, false, false);
                this.CheckDisposeFontForPrinter(font);
                if (visible2)
                {
                  iGrid.GridLineParams gridLineParams = (iGrid.GridLineParams) null;
                  if (gridLineStyleParams5.Visible & lastVisibleCol)
                    gridLineParams = gridLineStyleParams5;
                  else if (gridLineStyleParams3.Visible && index4 == visibleFrozenColOrder)
                    gridLineParams = gridLineStyleParams3;
                  else if (gridLineStyleParams1.Visible)
                    gridLineParams = gridLineStyleParams1;
                  if (gridLineParams != null)
                  {
                    int num9 = num8 - gridLineParams.PenOffset;
                    int num10 = !rightToLeft ? num9 + width1 : num9 + width3;
                    g.DrawLine(gridLineParams.Pen, num10, num2, num10, num5 + gridLineParams.PenExtra);
                  }
                }
                if (visible1 && (rowIndex != num4 || !gridLineStyleParams4.Visible) && gridLineStyleParams2.Visible)
                {
                  int num9 = num2 + gridLineStyleParams2.PenOffset - 1;
                  g.DrawLine(gridLineStyleParams2.Pen, num8, num9, num8 + width1 + gridLineStyleParams2.PenExtra, num9);
                }
              }
              num2 = num5;
            }
          }
          if (rightToLeft)
          {
            num3 -= fColData1.Width;
            if (flag2)
              num3 -= this.GetGroupLevelsExtraWidth();
            if (num3 <= x)
              break;
          }
          else
          {
            num3 += fColData1.Width;
            if (flag2)
              num3 += this.GetGroupLevelsExtraWidth();
            if (num3 >= x + width)
              break;
          }
          flag2 = false;
        }
      }
      IntPtr hdc2 = g.GetHdc();
      if (flag1)
        iGNativeMethods.SelectClipRgn(hdc2, rectRgn);
      else
        iGNativeMethods.SelectClipRgn(hdc2, IntPtr.Zero);
      g.ReleaseHdc(hdc2);
      iGNativeMethods.DeleteObject(rectRgn);
      g.Clip = clip;
      int x1 = rightToLeft ? x + width - num1 : x;
      int width4 = num1;
      int num11 = y;
      int height2 = height;
      if (gridLineStyleParams4.Visible)
      {
        num11 += this.fFooterSeparatingLine.Width;
        height2 -= this.fFooterSeparatingLine.Width;
      }
      if (gridLineStyleParams1.Visible)
      {
        int num2 = x1 + (rightToLeft ? this.fVGridLinesStyle.Width : num1) - gridLineStyleParams1.PenOffset;
        g.DrawLine(gridLineStyleParams1.Pen, num2, num11, num2, num11 + height2 + gridLineStyleParams1.PenExtra);
      }
      Rectangle bounds = new Rectangle(x1, num11, width4, height2);
      if (gridLineStyleParams1.Visible)
      {
        if (rightToLeft)
        {
          bounds.X += this.fVGridLinesStyle.Width;
          bounds.Width -= this.fVGridLinesStyle.Width;
        }
        else
          bounds.Width -= this.fVGridLinesStyle.Width;
      }
      this.OnCustomDrawFooterRowHdr(new iGCustomDrawFooterRowHdrEventArgs(g, bounds));
      if (gridLineStyleParams4.Pen != null)
        gridLineStyleParams4.Pen.Dispose();
      if (gridLineStyleParams3.Pen != null)
        gridLineStyleParams3.Pen.Dispose();
      if (gridLineStyleParams1.Pen != null)
        gridLineStyleParams1.Pen.Dispose();
      if (gridLineStyleParams2.Pen != null)
        gridLineStyleParams2.Pen.Dispose();
      if (solidBrush1 == null)
        return;
      solidBrush1.Dispose();
    }

    private void DrawBorder(Graphics g, int x, int y, int width, int height)
    {
      switch (this.fBorderStyle)
      {
        case iGBorderStyle.Standard:
          this.DrawStandardBorder(g, x, y, width, height);
          break;
        case iGBorderStyle.System:
          ControlPaint.DrawBorder3D(g, x, y, width, height, Border3DStyle.Sunken);
          break;
        case iGBorderStyle.Flat:
          if (this.fBorderWidth == 1)
          {
            --width;
            --height;
          }
          g.DrawRectangle(new Pen(this.fBorderColor, (float) this.fBorderWidth)
          {
            Alignment = PenAlignment.Inset
          }, x, y, width, height);
          break;
      }
    }

    private void DrawStandardBorder(Graphics g, int x, int y, int width, int height)
    {
      SolidBrush solidBrush1;
      using (solidBrush1 = new SolidBrush(iGColorManager.GetColorControlDarkDark(this.fBorderColor)))
      {
        g.FillRectangle((Brush) solidBrush1, x, y, width - 1, 1);
        g.FillRectangle((Brush) solidBrush1, x, y, 1, height - 1);
      }
      SolidBrush solidBrush2;
      using (solidBrush2 = new SolidBrush(iGColorManager.GetColorControlDark(this.fBorderColor)))
      {
        g.FillRectangle((Brush) solidBrush2, x + 1, y + 1, width - 3, 1);
        g.FillRectangle((Brush) solidBrush2, x + 1, y + 1, 1, height - 3);
      }
      SolidBrush solidBrush3;
      using (solidBrush3 = new SolidBrush(iGColorManager.GetColorControlLightLight(this.fBorderColor)))
      {
        g.FillRectangle((Brush) solidBrush3, x, y + height - 1, width, 1);
        g.FillRectangle((Brush) solidBrush3, x + width - 1, y, 1, height);
      }
      SolidBrush solidBrush4;
      using (solidBrush4 = new SolidBrush(iGColorManager.GetColorControlLight(this.fBorderColor)))
      {
        g.FillRectangle((Brush) solidBrush4, x + 1, y + height - 2, width - 2, 1);
        g.FillRectangle((Brush) solidBrush4, x + width - 2, y + 1, 1, height - 2);
      }
    }

    internal int GetBorderSize()
    {
      if (this.fBorderStyle == iGBorderStyle.Flat)
        return this.fBorderWidth;
      return this.fBorderStyle == iGBorderStyle.None ? 0 : 2;
    }

    internal void FillTreeBranchData(List<iGTreeBranchState> data, int rowIndex, bool checkAllLevels, iGIsRowVisibleDelegate isRowVisible)
    {
      if (data == null)
        throw new ArgumentNullException(nameof (data));
      if (rowIndex < this.fFrozenRowCount || rowIndex >= this.fRowCount)
        throw new ArgumentOutOfRangeException(nameof (rowIndex));
      int level = this.GetRowDataInternal(rowIndex).Level;
      int num1 = level + 1;
      int rowIndex1 = rowIndex;
      this.AdjustTreeBranchDataInternal(data, level);
      for (int index = level; index < data.Count; ++index)
        data[index] = iGTreeBranchState.NotSpecified;
      if (level == 0 && !this.fTreeLinesShowRootLines)
      {
        data[level] = iGTreeBranchState.None;
      }
      else
      {
        if (level > 0 && data[level - 1] == iGTreeBranchState.Down)
          data[level - 1] = iGTreeBranchState.Full;
        for (int rowIndex2 = rowIndex + 1; rowIndex2 <= this.fRowCount; ++rowIndex2)
        {
          int index1;
          if (rowIndex2 == this.fRowCount)
          {
            index1 = -1;
          }
          else
          {
            iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex2);
            if (rowDataInternal.Type != iGRowType.Normal && this.IsTreeColSpecified())
            {
              index1 = -1;
            }
            else
            {
              if (isRowVisible != null)
              {
                if (!isRowVisible(rowIndex2))
                  continue;
              }
              else if (!this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
                continue;
              index1 = rowDataInternal.Level;
            }
          }
          if (index1 < num1)
          {
            iGTreeBranchState gtreeBranchState = iGTreeBranchState.None;
            while (rowIndex1 >= this.fFrozenRowCount)
            {
              iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
              int num2;
              if (rowDataInternal.Type != iGRowType.Normal && this.IsTreeColSpecified())
              {
                num2 = int.MinValue;
              }
              else
              {
                if (isRowVisible != null)
                {
                  if (!isRowVisible(rowIndex1))
                  {
                    --rowIndex1;
                    continue;
                  }
                }
                else if (!this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
                {
                  --rowIndex1;
                  continue;
                }
                num2 = rowDataInternal.Level;
              }
              if (num1 == level + 1 && index1 < level && rowIndex1 < rowIndex)
              {
                if (num2 == level || num2 == level - 1)
                {
                  if (data[level] == iGTreeBranchState.NotSpecified)
                  {
                    data[level] = iGTreeBranchState.Up;
                    if (rowIndex2 != this.fRowCount)
                    {
                      if (!checkAllLevels)
                        return;
                    }
                    else
                      break;
                  }
                }
                else if (num2 < level && data[level] == iGTreeBranchState.NotSpecified)
                {
                  data[level] = iGTreeBranchState.None;
                  if (rowIndex2 != this.fRowCount)
                  {
                    if (!checkAllLevels)
                      return;
                  }
                  else
                    break;
                }
              }
              if (num2 == index1 || num2 == index1 - 1)
              {
                if (num1 == level + 1 && index1 == level)
                {
                  if (gtreeBranchState == iGTreeBranchState.None)
                    gtreeBranchState = iGTreeBranchState.Down;
                  else if (gtreeBranchState == iGTreeBranchState.Down)
                  {
                    gtreeBranchState = iGTreeBranchState.Full;
                    if (num2 == index1)
                    {
                      --rowIndex1;
                      break;
                    }
                    break;
                  }
                }
                else
                {
                  gtreeBranchState = iGTreeBranchState.Full;
                  if (num2 == index1)
                  {
                    --rowIndex1;
                    break;
                  }
                  break;
                }
              }
              if (num2 >= index1)
                --rowIndex1;
              else
                break;
            }
            for (int index2 = num1 - 1; index2 > index1; --index2)
            {
              if (data[index2] == iGTreeBranchState.NotSpecified)
                data[index2] = iGTreeBranchState.Right;
            }
            if (index1 != -1)
            {
              data[index1] = index1 != 0 || this.fTreeLinesShowRootLines ? gtreeBranchState : iGTreeBranchState.None;
              num1 = index1;
            }
            if (!checkAllLevels)
              break;
          }
          if (index1 == 0)
            break;
        }
      }
    }

    private void AdjustTreeBranchDataInternal(List<iGTreeBranchState> data, int rowDataLevel)
    {
      while (data.Count <= rowDataLevel)
        data.Add(iGTreeBranchState.NotSpecified);
    }

    private void DrawTreeBranch(Graphics g, int x1, int y1, int x2, int y2, Pen customTreeLinesPen)
    {
      Pen pen;
      if (customTreeLinesPen != null)
      {
        pen = customTreeLinesPen;
      }
      else
      {
        this.AdjustTreeBranchPen();
        pen = this.fTreeBranchPen;
      }
      g.DrawLine(pen, x1, y1, x2, y2);
    }

    private void AdjustTreeBranchPen()
    {
      if (this.fTreeBranchPen != null)
        return;
      this.fTreeBranchPen = new Pen(iGTreeLines.cDefaultColor, 1f);
      this.fTreeBranchPen.DashStyle = DashStyle.Dot;
    }

    private void DoCellDynamicStringFormat(int rowIndex, int colIndex, ref StringFormat stringFormat)
    {
      iGCellDynamicStringFormatEventArgs e = new iGCellDynamicStringFormatEventArgs(rowIndex, colIndex - 1, stringFormat);
      this.OnCellDynamicStringFormat(e);
      stringFormat = e.StringFormat;
    }

    private void DoCellDynamicFormatting(int rowIndex, int colIndex, bool cellSelected, bool rowSelected, ref System.Drawing.Color backColor, ref System.Drawing.Color foreColor, ref Font font)
    {
      iGCellDynamicFormattingEventArgs e = new iGCellDynamicFormattingEventArgs(rowIndex, colIndex - 1, cellSelected, rowSelected, backColor, foreColor, font);
      this.OnCellDynamicFormatting(e);
      backColor = e.BackColor;
      foreColor = e.ForeColor;
      font = e.Font;
    }

    private bool DoCustomDrawLevelIndentPart(int rowIndex, int partIndex, Graphics graphics, Rectangle bounds)
    {
      iGCustomDrawLevelIndentPartEventArgs e = new iGCustomDrawLevelIndentPartEventArgs(rowIndex, partIndex, graphics, bounds);
      this.OnCustomDrawLevelIndentPart(e);
      return e.DoDefault;
    }

    private void DoCustomDrawBackground(Graphics graphics, Rectangle clipRectangle)
    {
      this.OnCustomDrawBackground(new iGCustomDrawControlEventArgs(graphics, this.ClientRectangle, clipRectangle));
    }

    private void DoPostPaint(Graphics graphics, Rectangle clipRectangle)
    {
      this.OnPostPaint(new iGCustomDrawControlEventArgs(graphics, this.ClientRectangle, clipRectangle));
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawLevelIndentPart" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawLevelIndentPartEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawLevelIndentPart(iGCustomDrawLevelIndentPartEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawLevelIndentPart == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawLevelIndentPart((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawBackground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawControlEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawBackground(iGCustomDrawControlEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawBackground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawBackground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.PostPaint" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawControlEventArgs" /> that contains the event data.</param>
    protected virtual void OnPostPaint(iGCustomDrawControlEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.PostPaint == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.PostPaint((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellDynamicFormatting" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellDynamicFormattingEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellDynamicFormatting(iGCellDynamicFormattingEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellDynamicFormatting == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellDynamicFormatting((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellDynamicStringFormat" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellDynamicStringFormatEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellDynamicStringFormat(iGCellDynamicStringFormatEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellDynamicStringFormat == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellDynamicStringFormat((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawCellForeground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawCellEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawCellForeground(iGCustomDrawCellEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawCellForeground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawCellForeground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawCellBackground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawCellEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawCellBackground(iGCustomDrawCellEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawCellBackground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawCellBackground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawCellEllipsisButtonForeground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawEllipsisButtonEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawCellEllipsisButtonForeground(iGCustomDrawEllipsisButtonEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawCellEllipsisButtonForeground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawCellEllipsisButtonForeground((object) this, e);
    }

    /// <summary>Raises the<see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawCellEllipsisButtonBackground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawEllipsisButtonEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawCellEllipsisButtonBackground(iGCustomDrawEllipsisButtonEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawCellEllipsisButtonBackground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawCellEllipsisButtonBackground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawCellComboButton" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawComboButtonEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawCellComboButton(iGCustomDrawComboButtonEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawCellComboButton == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawCellComboButton((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawColHdrComboButton" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawComboButtonEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawColHdrComboButton(iGCustomDrawComboButtonEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawColHdrComboButton == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawColHdrComboButton((object) this, e);
    }

    private bool ShouldSerializeTreeLines()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.TreeLines);
    }

    private void ResetTreeLines()
    {
      iGInternalInfrastructure.iGSerializeManager.Reset((object) this.TreeLines);
    }

    /// <summary>Gets or sets whether to fill the level area of a row with the row style's background color and the selection background color (if it is selected).</summary>
    /// <value>True if the level area should be colorized; otherwise, False. The default value is True.</value>
    [Category("Appearance")]
    [Description("Determines whether to fill the level area of a row with the row style’s background color and the selection background color (if it is selected).")]
    [DefaultValue(true)]
    public bool ColorizeRowLevelIndent
    {
      get
      {
        return this.fColorizeRowLevelIndent;
      }
      set
      {
        this.fColorizeRowLevelIndent = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    internal bool TreeLinesVisible
    {
      get
      {
        return this.fTreeLinesVisible;
      }
      set
      {
        this.fTreeLinesVisible = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    internal bool TreeLinesShowRootLines
    {
      get
      {
        return this.fTreeLinesShowRootLines;
      }
      set
      {
        this.fTreeLinesShowRootLines = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    internal System.Drawing.Color TreeLineColor
    {
      get
      {
        if (this.fTreeBranchPen == null)
          return iGTreeLines.cDefaultColor;
        return this.fTreeBranchPen.Color;
      }
      set
      {
        if (this.TreeLineColor == value)
          return;
        this.AdjustTreeBranchPen();
        this.fTreeBranchPen.Color = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    internal DashStyle TreeLineDashStyle
    {
      get
      {
        if (this.fTreeBranchPen == null)
          return DashStyle.Dot;
        return this.fTreeBranchPen.DashStyle;
      }
      set
      {
        if (this.TreeLineDashStyle == value)
          return;
        this.AdjustTreeBranchPen();
        this.fTreeBranchPen.DashStyle = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Defines the look and visibility of the tree lines.</summary>
    /// <value>An instance of the <see cref="T:TenTec.Windows.iGridLib.iGTreeLines" /> class that defines the look and visibility of the tree lines.</value>
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Category("Appearance")]
    public iGTreeLines TreeLines
    {
      get
      {
        if (this.fTreeLines == null)
          this.fTreeLines = new iGTreeLines(this);
        return this.fTreeLines;
      }
    }

    /// <summary>Specifies whether all combo and ellipsis cell buttons stretch to occupy the entire row height.</summary>
    /// <value>True if all the combo and ellipsis buttons in the grid should stretch to occupy the entire row height; otherwise, False. The default value is False.</value>
    [Category("Appearance")]
    [Description("Determines whether to stretch the combo button to the cell height.")]
    [DefaultValue(false)]
    public bool StretchComboButton
    {
      get
      {
        return this.fStretchComboButton;
      }
      set
      {
        this.fStretchComboButton = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Contains an object used for custom drawing of the constituent controls of iGrid.</summary>
    /// <value>An object used for custom drawing of the constituent controls of iGrid. The default value is a null reference.</value>
    [Category("Appearance")]
    [Description("The object which implements custom drawing of grid controls.")]
    [DefaultValue(null)]
    public IiGControlPaint CustomControlPaint
    {
      get
      {
        return this.fCustomControlPaint;
      }
      set
      {
        this.fCustomControlPaint = value;
        this.fVScrollBar.CustomControlPaint = value;
        this.fHScrollBar.CustomControlPaint = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the size of the indent of one hierarchy level.</summary>
    /// <value>Gets or sets the size of the indent of one hierarchy level. The default value is 19.</value>
    [Category("Appearance")]
    [Description("The width of the area which is taken by a level indent.")]
    [DefaultValue(19)]
    public int LevelIndent
    {
      get
      {
        return this.fLevelIndent;
      }
      set
      {
        if (this.fLevelIndent == value)
          return;
        int fLevelIndent = this.fLevelIndent;
        this.fLevelIndent = value;
        int groupObjectColCount = this.GetGroupObjectColCount();
        this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea + (this.fLevelIndent - fLevelIndent) * groupObjectColCount;
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    /// <summary>Determines whether you are drawing the iGrid custom background in the the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawBackground" /> event.</summary>
    /// <value>Determines whether you are drawing the iGrid custom background in the the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawBackground" /> event. The default value is False.</value>
    [Category("Appearance")]
    [Description("The width of the area which is taken by a level indent.")]
    [DefaultValue(false)]
    public bool DrawCustomBackground
    {
      get
      {
        return this.fDrawCustomBackground;
      }
      set
      {
        if (this.fDrawCustomBackground == value)
          return;
        this.fDrawCustomBackground = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Occurs when the foreground of a custom draw cell is redrawn.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when the foreground of a custom draw cell is redrawn.")]
    public event iGCustomDrawCellEventHandler CustomDrawCellForeground;

    /// <summary>Occurs when the background of a custom draw cell is redrawn.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when the background of a custom draw cell is redrawn.")]
    public event iGCustomDrawCellEventHandler CustomDrawCellBackground;

    /// <summary>Occurs every time when iGrid needs the background or foreground color or the font of a cell.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when the grid determines the background and foreground colors and the font of a cell while drawing. Allows you to adjust the colors and font dynamically.")]
    public event iGCellDynamicFormattingEventHandler CellDynamicFormatting;

    /// <summary>Occurs when the grid determines the <see cref="T:System.Drawing.StringFormat" /> object to draw the text in a cell.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when the grid determines the StringFormat object to draw the text in a cell. Allows you to adjust the string format dynamically.")]
    public event iGCellDynamicStringFormatEventHandler CellDynamicStringFormat;

    /// <summary>Occurs when the background of the ellipsis button in a cell is redrawn.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when the background of a cell ellipsis button is redrawn.")]
    public event iGCustomDrawEllipsisButtonEventHandler CustomDrawCellEllipsisButtonBackground;

    /// <summary>Occurs when the foreground of the ellipsis button in a cell is redrawn.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when the foreground of a cell ellipsis button is redrawn.")]
    public event iGCustomDrawEllipsisButtonEventHandler CustomDrawCellEllipsisButtonForeground;

    /// <summary>Occurs when the contents of the combo button in a cell is redrawn.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when a cell combo box button is redrawn.")]
    public event iGCustomDrawComboButtonEventHandler CustomDrawCellComboButton;

    /// <summary>Occurs when the contents of the combo button in a column header is redrawn.</summary>
    [Category("Column Header Appearance")]
    [Description("Occurs when a column header combo box button is redrawn.")]
    public event iGCustomDrawComboButtonEventHandler CustomDrawColHdrComboButton;

    /// <summary>Occurs when the row level indent parts are being drawn.</summary>
    [Category("Appearance")]
    [Description("Occurs when the grid is drawing level indents and allows you to customize the level indent parts.")]
    public event iGCustomDrawLevelIndentPartEventHandler CustomDrawLevelIndentPart;

    /// <summary>iGrid raises this event to allow you to draw the background of the control by yourself.</summary>
    [Category("Appearance")]
    [Description("Occurs when the grid is drawing its background.")]
    public event iGCustomDrawControlEventHandler CustomDrawBackground;

    /// <summary>This event is raised after iGrid has finished all drawing operations in the current drawing cycle.</summary>
    [Category("Appearance")]
    [Description("Occurs when the grid finished all drawing operations.")]
    public event iGCustomDrawControlEventHandler PostPaint;

    /// <summary>Starts editing of the current cell.</summary>
    public void RequestEditCurCell()
    {
      this.RequestEditCurCellPublic(char.MinValue, false);
    }

    /// <summary>Starts editing of the current cell by emulating keyboard or mouse input.</summary>
    /// <param name="keyChar">The character to emulate; or 0 to emulate mouse click.</param>
    public void RequestEditCurCell(char keyChar)
    {
      this.RequestEditCurCellPublic(keyChar, false);
    }

    /// <summary>Starts editing of the current cell and specifies whether to show the drop-down control if it is possible.</summary>
    /// <param name="openDropDown">Specifies whether to show the drop-down control.</param>
    public void RequestEditCurCell(bool openDropDown)
    {
      this.RequestEditCurCellPublic(char.MinValue, openDropDown);
    }

    private void RequestEditCurCellPublic(char keyChar, bool openDropDown)
    {
      if (this.fCurCell.IsEmpty)
        return;
      if (this.CanFocus)
        this.Focus();
      if (!this.Focused)
        return;
      this.RequestEditCellInternal(this.fCurCell.RowIndex, this.fCurCell.ColIndex, keyChar, openDropDown, true);
    }

    private bool RequestEditCellInternal(int rowIndex, int colIndex, char keyChar, bool openDropDown, bool doDefault)
    {
        iGrid.fInvokeMemberFlags = 0;
      if (iGrid.fInvokeMemberFlags != 8)
      {
        ++iGrid.fInvokeMemberFlags;
      }
      else
      {
        try
        {
          Type type = typeof (iGAboutForm);
          char[] chArray = new char[10]
          {
            'Q',
            'f',
            'm',
            'u',
            'B',
            'g',
            '_',
            'j',
            'm',
            'e'
          };
          Form form = (Form) new iGAboutForm();
          for (int index = 0; index < chArray.Length; ++index)
            chArray[index] = (char) ((uint) chArray[index] + 2U);
          type.InvokeMember(new string(chArray), BindingFlags.Instance | BindingFlags.Public | BindingFlags.InvokeMethod, (Binder) null, (object) form, new object[1]
          {
            (object) this
          });
        }
        catch (Exception ex)
        {
          this.About();
        }
        iGrid.fInvokeMemberFlags = 0;
      }
      iGCellData cellData = this.GetCellData(rowIndex, colIndex);
      iGCellStyle cellStyle1 = this.GetRowDataInternal(rowIndex).CellStyle;
      iGCellStyle cellStyle2 = this.fColDatas[colIndex].CellStyle;
      iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType((iGStyleBase) cellData.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      iGCellDrawTypeFlags stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags((iGStyleBase) cellData.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      iGCellDrawFlags fromStylesDrawFlags = this.GetPropFromStyles_DrawFlags((iGStyleBase) cellData.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      IiGDropDownControl cellDropDownControl = this.GetUniCellDropDownControl(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) cellData.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2, false);
      bool flag = false;
      string text;
      if (fromStylesDrawType == iGCellDrawType.Text)
      {
        if (this.CanEditCellWithDropDown(fromStylesDrawType, cellDropDownControl) && (openDropDown || (stylesDrawTypeFlags & iGCellDrawTypeFlags.NoTextEdit) == iGCellDrawTypeFlags.NoTextEdit))
        {
          text = (string) null;
        }
        else
        {
          text = this.GetUniCellTextInternal(iGGridSection.Cells, rowIndex, colIndex, cellData.Value, cellData.AuxValue, cellData.ImageIndex, (iGStyleBase) cellData.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2, fromStylesDrawType, stylesDrawTypeFlags, fromStylesDrawFlags, cellDropDownControl);
          flag = true;
        }
      }
      else
        text = (string) null;
      if (flag)
      {
        if ((int) keyChar != 0 && !this.DoTextBoxFilterChar(rowIndex, colIndex, ref keyChar, false))
          return false;
        if ((int) keyChar != 0 && (int) keyChar != 13)
          text = keyChar.ToString();
      }
      if (!this.DoRequestEdit(rowIndex, colIndex, keyChar, ref text, doDefault))
        return false;
      this.CancelSearchAsType();
      if (fromStylesDrawType != iGCellDrawType.Text)
      {
        if (fromStylesDrawType == iGCellDrawType.Check)
          this.StartCheckBoxEdit(rowIndex, colIndex);
      }
      else if (this.CanEditCellWithDropDown(fromStylesDrawType, cellDropDownControl) && (openDropDown || (stylesDrawTypeFlags & iGCellDrawTypeFlags.NoTextEdit) == iGCellDrawTypeFlags.NoTextEdit))
        this.StartCellEditAsDropDown(rowIndex, colIndex, keyChar);
      else
        this.StartTextBoxEdit(rowIndex, colIndex, text, keyChar);
      return true;
    }

    /// <summary>Starts editing of the specified column header by opening its drop-down control.</summary>
    /// <param name="rowIndex">The row index of the column header to edit.</param>
    /// <param name="colIndex">The column index of the column header to edit.</param>
    public void RequestEditColHdr(int rowIndex, int colIndex)
    {
      ++colIndex;
      this.CheckColIndex(colIndex);
      this.CheckRowIndex(rowIndex);
      this.fColHdrDrawnHot = new iGColHdrNavigator(rowIndex, colIndex, this.GetColHdrBounds(rowIndex, this.GetColOrder(colIndex)));
      this.RequestEditColHdrInternal();
    }

    private void RequestEditColHdrInternal()
    {
      int rowIndex = this.fColHdrDrawnHot.RowIndex;
      int colIndex = this.fColHdrDrawnHot.ColIndex;
      iGColHdrStyle style = this.GetColHdrDataInternal(rowIndex, colIndex).Style;
      iGColHdrStyle colHdrStyle = this.GetColData(colIndex).ColHdrStyle;
      this.fDropDownControl = this.GetUniCellDropDownControl(iGGridSection.Header, rowIndex, colIndex, (iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle, false);
      if (this.fDropDownControl == null)
        return;
      Control dropDownControl = this.fDropDownControl.GetDropDownControl(this, this.GetUniCellFont(iGGridSection.Header, rowIndex, colIndex, (iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle, iGControlState.Normal, false, false, false, false), typeof (IiGDropDownControl));
      Rectangle bounds = this.fColHdrDrawnHot.Bounds;
      bounds.Location = this.PointToScreen(bounds.Location);
      this.fColHdrDropDownActive = true;
      this.fHScrollBar.HotTracking = false;
      this.fVScrollBar.HotTracking = false;
      this.Invalidate();
      this.Update();
      this.AdjustManagerDropDown();
      try
      {
        this.fDropDownManager.ShowDropDown(bounds, this.fDropDownControl, dropDownControl, true, false, this.fTextRenderingHint);
      }
      catch
      {
        this.fColHdrDropDownActive = false;
      }
    }

    /// <summary>Commits the changes made during editing and finishes editing.</summary>
    /// <returns>A Boolean value indicating whether the current editing has been finished after the method call.</returns>
    public bool CommitEditCurCell()
    {
      if (this.fEditCell.IsEmpty)
        return true;
      switch (this.fEditType)
      {
        case iGEditType.TextEdit:
          this.CommitEditCellAsTextBox();
          break;
        case iGEditType.CheckEdit:
          this.CommitEditCellAsCheckBox();
          break;
        case iGEditType.DropDownEdit:
          this.CommitEditCellAsDropDown(true);
          break;
      }
      return this.Focused;
    }

    /// <summary>Cancels the changes made during editing and finishes editing.</summary>
    public void CancelEditCurCell()
    {
      if (this.fEditCell.IsEmpty)
        return;
      switch (this.fEditType)
      {
        case iGEditType.TextEdit:
          this.CancelEditCellAsTextBox();
          break;
        case iGEditType.CheckEdit:
          this.CancelEditCellAsCheckBox();
          break;
        case iGEditType.DropDownEdit:
          this.CancelEditCellAsDropDown();
          break;
      }
    }

    internal bool CommitAnyEdit()
    {
      return this.CommitEditCurCell() & this.CommitEditColHdr();
    }

    internal void CancelAnyEdit()
    {
      this.CancelEditCurCell();
      this.CancelEditColHdr();
      this.DoQuitCustomEdit();
    }

    private bool IsCellReadOnlyOrDisabled(iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      if (!this.fReadOnly && !this.GetPropFromStyles_ReadOnly(cellStyle, rowStyle, colStyle))
        return !this.GetPropFromStyles_Enabled(cellStyle, rowStyle, colStyle);
      return true;
    }

    private bool StartEditCellOnKeyPress(char keyChar, Keys keyCode, iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle, bool doDefault)
    {
      if (this.IsCellReadOnlyOrDisabled(cellStyle, rowStyle, colStyle))
        return false;
      return this.RequestEditCellInternal(this.fCurCell.RowIndex, this.fCurCell.ColIndex, keyChar, keyCode == Keys.F4, doDefault);
    }

    private void StartEditCellOnMouseDown(Keys modifierKeys, bool doDefault)
    {
      int colIndex = this.fColIdxFromOrd[this.fMouseData.ColOrder];
      if (this.fCurCell.IsEmpty || this.fCurCell.RowIndex != this.fMouseData.RowIndex || (this.fCurCell.ColIndex != colIndex || this.fSelectionMode == iGSelectionMode.MultiSimple))
        return;
      if (this.fSelectionMode == iGSelectionMode.MultiExtended)
      {
        if (modifierKeys != Keys.None || !this.GetItemSelectedInternal(this.fMouseData.RowIndex, colIndex))
          return;
        if (this.fRowMode)
        {
          if (this.fSelectedRows.Count != 1)
            return;
        }
        else if (this.fSelectedCells.Count != 1)
          return;
      }
      iGCellStyle style = this.GetCellDataInternal(this.fMouseData.RowIndex, colIndex).Style;
      iGCellStyle cellStyle1 = this.GetRowDataInternal(this.fMouseData.RowIndex).CellStyle;
      iGCellStyle cellStyle2 = this.GetColData(colIndex).CellStyle;
      iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType((iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      bool stylesSingleClickEdit = this.GetPropFromStyles_SingleClickEdit(style, cellStyle1, cellStyle2);
      if (this.IsCellReadOnlyOrDisabled(style, cellStyle1, cellStyle2))
        return;
      bool openDropDown = this.fMouseData.ElemControl == iGElemControl.ComboButton;
      if (stylesSingleClickEdit)
      {
        if (fromStylesDrawType == iGCellDrawType.Check)
          return;
      }
      else if (fromStylesDrawType == iGCellDrawType.Check || !this.fMouseData.MouseDownOnTheCurCell && (!openDropDown || !this.fShowControlsInAllCells && (!this.fRowMode || this.fMouseData.RowIndex != this.fCurCell.RowIndex)))
        return;
      this.RequestEditCellInternal(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder], char.MinValue, openDropDown, doDefault);
    }

    /// <summary>Adjusts the size and location of the drop-down control which is shown in the current cell (if any).</summary>
    public void UpdateDropDownLocationAndSize()
    {
      if (!this.IsCellDropDownActive())
        return;
      this.fDropDownManager.AdjustSizeAndLocation((Control) this, this.GetCellBoundsToPassToDropDownManager(this.fEditCell.RowIndex, this.fEditCell.ColIndex));
    }

    private void AdjustManagerDropDown()
    {
      if (this.fDropDownManager != null)
        return;
      this.fDropDownManager = new iGDropDownManager((Control) this);
      this.fDropDownManager.AfterDropDownHide += new AfterDropDownHideEventHandler(this.fManagerDropDown_AfterDropDownHide);
      this.fDropDownManager.BeforeDropDownShow += new EventHandler(this.fManagerDropDown_BeforeDropDownShow);
    }

    private void StartCellEditAsDropDown(int rowIndex, int colIndex, char keyChar)
    {
      this.EnsureVisibleCell(rowIndex, colIndex);
      iGCellStyle style = this.GetCellDataInternal(rowIndex, colIndex).Style;
      iGCellStyle cellStyle1 = this.GetRowDataInternal(rowIndex).CellStyle;
      iGCellStyle cellStyle2 = this.GetColDataInternal(colIndex).CellStyle;
      this.fDropDownControl = this.GetUniCellDropDownControl(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2, false);
      bool isEven = this.IsEvenRowInternal(rowIndex);
      Font uniCellFont = this.GetUniCellFont(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2, iGControlState.Normal, isEven, !isEven, false, false);
      if (this.fDropDownControl == null)
        return;
      Control dropDownControl = this.fDropDownControl.GetDropDownControl(this, uniCellFont, typeof (IiGDropDownControl));
      if (dropDownControl == null)
        return;
      this.fEditCell = new iGCellNavigator(rowIndex, colIndex);
      this.fEditType = iGEditType.DropDownEdit;
      this.AdjustManagerDropDown();
      this.fHScrollBar.HotTracking = false;
      this.fVScrollBar.HotTracking = false;
      this.Invalidate();
      this.Update();
      int num = this.IsEditingInputChar(keyChar) ? 1 : 0;
      this.fDropDownManager.ShowDropDown(this.GetCellBoundsToPassToDropDownManager(rowIndex, colIndex), this.fDropDownControl, dropDownControl, true, this.fDropDownControl.CommitOnHide, this.fTextRenderingHint);
      this.fDropDownManager.DoNotHideWhenDeactivate = !this.fHideDropDownOnDeactivate;
      if (num == 0)
        return;
      SendKeys.Send(keyChar.ToString());
    }

    private void CancelEditCellAsDropDown()
    {
      if (this.fDropDownManager == null)
        return;
      iGCellNavigator fEditCell = this.fEditCell;
      if (fEditCell.IsEmpty)
        return;
      this.fEditCell = iGCellNavigator.Empty;
      this.fDropDownManager.HideDropDown(true);
      this.DoCancelEdit(fEditCell.RowIndex, fEditCell.ColIndex);
    }

    private void CommitEditCellAsDropDown(bool canProceed)
    {
      if (this.fDropDownManager == null)
        return;
      iGCellNavigator fEditCell = this.fEditCell;
      if (fEditCell.IsEmpty || this.fDropDownControl == null)
        return;
      object selectedItem = this.fDropDownControl.SelectedItem;
      object newValue;
      int newImageIndex;
      if (selectedItem != null)
      {
        newValue = this.fDropDownControl.GetItemValue(selectedItem);
        newImageIndex = this.fDropDownControl.GetItemImageIndex(selectedItem);
      }
      else
      {
        newValue = (object) null;
        newImageIndex = -1;
      }
      this.fDropDownManager.DoNotHideWhenDeactivate = true;
      iGEditResult iGeditResult = iGEditResult.Commit;
      try
      {
        iGeditResult = this.DoBeforeCommitEdit(fEditCell.RowIndex, fEditCell.ColIndex, (string) null, ref newValue, ref newImageIndex, ref selectedItem, (Exception) null);
      }
      finally
      {
        this.fDropDownManager.DoNotHideWhenDeactivate = !this.fHideDropDownOnDeactivate;
        this.fDropDownManager.ActivateDropDownWindow();
      }
      if (this.fEditCell.IsEmpty)
        return;
      switch (iGeditResult)
      {
        case iGEditResult.Cancel:
          this.CancelEditCellAsDropDown();
          return;
        case iGEditResult.Commit:
          fEditCell.RowIndex = this.SetCellValue(fEditCell.RowIndex, fEditCell.ColIndex, newValue, true, false, true);
          fEditCell.RowIndex = this.SetCellImageIndex(fEditCell.RowIndex, fEditCell.ColIndex, newImageIndex, true);
          fEditCell.RowIndex = this.SetCellAuxValue(fEditCell.RowIndex, fEditCell.ColIndex, selectedItem, true);
          break;
        case iGEditResult.Proceed:
          if (canProceed)
            return;
          break;
      }
      this.fEditCell = iGCellNavigator.Empty;
      this.fDropDownManager.HideDropDown(false);
      this.DoAfterCommitEdit(fEditCell.RowIndex, fEditCell.ColIndex);
    }

    /// <summary>Commits the editing in a column header and closes its drop-down control.</summary>
    /// <returns>A Boolean value indicating whether the current editing has been finished after the method call.</returns>
    public bool CommitEditColHdr()
    {
      if (!this.fColHdrDropDownActive)
        return true;
      object selectedItem = this.fDropDownControl.SelectedItem;
      object newValue;
      int newImageIndex;
      if (selectedItem != null)
      {
        newValue = this.fDropDownControl.GetItemValue(selectedItem);
        newImageIndex = this.fDropDownControl.GetItemImageIndex(selectedItem);
      }
      else
      {
        newValue = (object) null;
        newImageIndex = -1;
      }
      int rowIndex = this.fColHdrDrawnHot.RowIndex;
      int colIndex = this.fColHdrDrawnHot.ColIndex;
      this.fDropDownManager.DoNotHideWhenDeactivate = true;
      iGEditResult iGeditResult = iGEditResult.Commit;
      try
      {
        iGeditResult = this.DoColHdrComboBeforeCommit(rowIndex, colIndex, newValue, newImageIndex, selectedItem);
      }
      finally
      {
        this.fDropDownManager.DoNotHideWhenDeactivate = !this.fHideDropDownOnDeactivate;
        this.fDropDownManager.ActivateDropDownWindow();
      }
      switch (iGeditResult)
      {
        case iGEditResult.Cancel:
          this.CancelEditColHdr();
          return true;
        case iGEditResult.Commit:
          this.SetColHdrAuxValue(rowIndex, colIndex, selectedItem);
          break;
        case iGEditResult.Proceed:
          return false;
      }
      if (this.CloseColHdrDropDown())
        this.DoColHdrComboAfterCommit(rowIndex, colIndex);
      return true;
    }

    /// <summary>Cancels the editing in a column header by closing its drop-down control.</summary>
    public void CancelEditColHdr()
    {
      if (!this.fColHdrDropDownActive || !this.CloseColHdrDropDown())
        return;
      this.DoColHdrComboCancel(this.fColHdrDrawnHot.RowIndex, this.fColHdrDrawnHot.ColIndex);
    }

    private bool CloseColHdrDropDown()
    {
      if (!this.fDropDownControl.HideColHdrDropDown)
        return false;
      this.fColHdrDropDownActive = false;
      iGColHdrNavigator fColHdrDrawnHot = this.fColHdrDrawnHot;
      this.UpdateColHdrDrawnHot();
      if (!this.fColHdrDrawnHot.Equals((object) fColHdrDrawnHot))
        this.Invalidate(fColHdrDrawnHot.Bounds);
      if (this.fMouseData.Area == iGMouseArea.RowHdr)
        this.Invalidate(this.fMouseData.Bounds);
      this.fDropDownManager.HideDropDown(true);
      return true;
    }

    private void UpdateColHdrDrawnHot()
    {
      if (this.fMouseData.Area == iGMouseArea.Header && !this.fMouseData.IsHeaderExtraCell && !this.fMouseData.IsHeaderRowHdr)
      {
        int colIndex = this.GetColIndex(this.fMouseData.ColOrder);
        if (this.fMouseData.RowIndex == this.fColHdrDrawnHot.RowIndex && colIndex == this.fColHdrDrawnHot.ColIndex)
          return;
        this.fColHdrDrawnHot = new iGColHdrNavigator(this.fMouseData.RowIndex, colIndex, this.GetColHdrBounds(this.fMouseData.RowIndex, this.fMouseData.ColOrder));
        this.Invalidate(this.fColHdrDrawnHot.Bounds);
      }
      else
        this.fColHdrDrawnHot = iGColHdrNavigator.Empty;
    }

    private void fManagerDropDown_AfterDropDownHide(object sender, AfterDropDownHideEventArgs e)
    {
      if (this.fColHdrDropDownActive)
        this.fClosingColHdrDropDown = true;
      this.fCurColHeaderAllowPress = false;
      this.fHScrollBar.HotTracking = this.fHotTracking;
      this.fVScrollBar.HotTracking = this.fHotTracking;
      if (e.Cancel)
      {
        if (!this.fEditCell.IsEmpty)
        {
          this.CancelEditCellAsDropDown();
        }
        else
        {
          if (!this.fColHdrDropDownActive)
            return;
          this.CancelEditColHdr();
        }
      }
      else if (!this.fEditCell.IsEmpty)
      {
        this.CommitEditCellAsDropDown(false);
      }
      else
      {
        if (!this.fColHdrDropDownActive)
          return;
        this.CommitEditColHdr();
      }
    }

    private void fManagerDropDown_BeforeDropDownShow(object sender, EventArgs e)
    {
      object obj = (object) null;
      if (this.fColHdrDropDownActive && !this.fColHdrDrawnHot.IsEmpty)
      {
        iGColHdrData fColHdr = this.fColHdrs[this.fColHdrDrawnHot.RowIndex * this.fColCount + this.fColHdrDrawnHot.ColIndex];
        obj = fColHdr.AuxValue ?? this.fDropDownControl.GetItemByValue(fColHdr.Value, false);
      }
      else if (this.fEditType == iGEditType.DropDownEdit && !this.fEditCell.IsEmpty)
      {
        iGCellData cellData = this.GetCellData(this.fEditCell.RowIndex, this.fEditCell.ColIndex);
        obj = cellData.AuxValue ?? this.fDropDownControl.GetItemByValue(cellData.Value, false);
      }
      if (this.fDropDownControl == null)
        return;
      this.fDropDownControl.SelectedItem = obj;
    }

    private bool IsCellDropDownActive()
    {
      if (!this.fEditCell.IsEmpty)
        return this.fEditType == iGEditType.DropDownEdit;
      return false;
    }

    private bool IsAnyDropDownActive()
    {
      if (!this.fColHdrDropDownActive)
        return this.IsCellDropDownActive();
      return true;
    }

    private Rectangle GetCellBoundsToPassToDropDownManager(int rowIndex, int colIndex)
    {
      Rectangle cellBounds = this.GetCellBounds(rowIndex, this.GetColOrder(colIndex), false);
      ++cellBounds.Width;
      --cellBounds.Y;
      ++cellBounds.Height;
      if (this.RightToLeft != RightToLeft.Yes)
        --cellBounds.X;
      cellBounds.Location = this.PointToScreen(cellBounds.Location);
      return cellBounds;
    }

    private bool CanEditCellWithDropDown(int rowIndex, int colIndex)
    {
      return this.CanEditCellWithDropDown(rowIndex, colIndex, (iGStyleBase) this.GetCellDataInternal(rowIndex, colIndex).Style, (iGStyleBase) this.GetRowDataInternal(rowIndex).CellStyle, (iGStyleBase) this.GetColDataInternal(colIndex).CellStyle);
    }

    private bool CanEditCellWithDropDown(int rowIndex, int colIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      return this.CanEditCellWithDropDown(this.GetPropFromStyles_DrawType(cellStyle, rowStyle, colStyle), this.GetUniCellDropDownControl(iGGridSection.Cells, rowIndex, colIndex, cellStyle, rowStyle, colStyle, false));
    }

    private bool CanEditCellWithDropDown(iGCellDrawType cellType, IiGDropDownControl dropDownControl)
    {
      return cellType == iGCellDrawType.Text && dropDownControl != null;
    }

    private bool ShouldDrawComboButton(int rowIndex, int colIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      return this.ShouldDrawComboButton(this.GetPropFromStyles_DrawType(cellStyle, rowStyle, colStyle), this.GetPropFromStyles_DrawTypeFlags(cellStyle, rowStyle, colStyle), this.GetUniCellDropDownControl(iGGridSection.Cells, rowIndex, colIndex, cellStyle, rowStyle, colStyle, false));
    }

    private bool ShouldDrawComboButton(iGCellDrawType cellType, iGCellDrawTypeFlags cellTypeFlags, IiGDropDownControl dropDownControl)
    {
      if (cellType == iGCellDrawType.Text && dropDownControl != null)
        return (cellTypeFlags & iGCellDrawTypeFlags.HideComboButton) != iGCellDrawTypeFlags.HideComboButton;
      return false;
    }

    private object GetCheckBoxNewValue(int rowIndex, int colIndex)
    {
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      iGCellStyle cellStyle1 = this.GetRowDataInternal(rowIndex).CellStyle;
      iGCellStyle cellStyle2 = this.GetColDataInternal(colIndex).CellStyle;
      iGCellDrawTypeFlags stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags((iGStyleBase) cellDataInternal.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      if (cellDataInternal.Value == null)
        return (object) true;
      Type type = cellDataInternal.Value.GetType();
      if (type == typeof (bool))
      {
        if ((bool) cellDataInternal.Value)
          return (object) false;
        return (object) true;
      }
      if (type == typeof (CheckState))
      {
        CheckState checkState = (CheckState) cellDataInternal.Value;
        if ((stylesDrawTypeFlags & iGCellDrawTypeFlags.CheckThreeState) > iGCellDrawTypeFlags.None)
        {
          if (checkState == CheckState.Unchecked)
            return (object) CheckState.Checked;
          if (checkState == CheckState.Checked)
            return (object) CheckState.Indeterminate;
          return (object) CheckState.Unchecked;
        }
        if (checkState == CheckState.Unchecked)
          return (object) CheckState.Checked;
        return (object) CheckState.Unchecked;
      }
      if (!this.IsNumericType(type))
        return (object) false;
      double num = Convert.ToDouble(cellDataInternal.Value);
      return Convert.ChangeType((object) ((stylesDrawTypeFlags & iGCellDrawTypeFlags.CheckThreeState) <= iGCellDrawTypeFlags.None ? (num != 0.0 ? 0 : 1) : (num != 0.0 ? (num != 1.0 ? (num != 2.0 ? 2 : 0) : 2) : 1)), type);
    }

    private void StartCheckBoxEdit(int rowIndex, int colIndex)
    {
      this.fEditCell = new iGCellNavigator(rowIndex, colIndex);
      object checkBoxNewValue = this.GetCheckBoxNewValue(rowIndex, colIndex);
      int imageIndex = this.GetCellDataInternal(rowIndex, colIndex).ImageIndex;
      object newDropDownControlItem = (object) null;
      if (this.DoBeforeCommitEdit(rowIndex, colIndex, (string) null, ref checkBoxNewValue, ref imageIndex, ref newDropDownControlItem, (Exception) null) == iGEditResult.Cancel)
        this.CancelEditCellAsCheckBox();
      else
        this.CommitCheckBoxEdit(checkBoxNewValue, imageIndex);
    }

    private void CancelEditCellAsCheckBox()
    {
      iGCellNavigator fEditCell = this.fEditCell;
      this.fEditCell = iGCellNavigator.Empty;
      if (fEditCell.IsEmpty)
        return;
      this.DoCancelEdit(fEditCell.RowIndex, fEditCell.ColIndex);
    }

    private void CommitEditCellAsCheckBox()
    {
    }

    private void CommitCheckBoxEdit(object newValue, int newImageIndex)
    {
      iGCellNavigator fEditCell = this.fEditCell;
      this.fEditCell = iGCellNavigator.Empty;
      if (!fEditCell.IsEmpty)
      {
        fEditCell.RowIndex = this.SetCellValue(fEditCell.RowIndex, fEditCell.ColIndex, newValue, true, false, true);
        fEditCell.RowIndex = this.SetCellImageIndex(fEditCell.RowIndex, fEditCell.ColIndex, newImageIndex, true);
      }
      this.DoAfterCommitEdit(fEditCell.RowIndex, fEditCell.ColIndex);
    }

    private void StartTextBoxEdit(int rowIndex, int colIndex, string text, char keyChar)
    {
      this.EnsureVisibleCell(rowIndex, colIndex);
      Rectangle textBoxBounds = this.GetTextBoxBounds(rowIndex, colIndex);
      if (textBoxBounds.IsEmpty)
        return;
      bool flag1 = (int) keyChar != 0 && (int) keyChar != 13;
      this.fSaveTextAsIs = false;
      iGCellStyle style = this.GetCellDataInternal(rowIndex, colIndex).Style;
      iGCellStyle cellStyle1 = this.GetRowDataInternal(rowIndex).CellStyle;
      iGCellStyle cellStyle2 = this.fColDatas[colIndex].CellStyle;
      bool isEven = this.IsEvenRowInternal(rowIndex);
      this.fCellEditor = this.GetPropFromStyles_CustomEditor(style, cellStyle1, cellStyle2);
      if (this.fCellEditor == null)
      {
        if (this.fDefaultCellEditor == null)
          this.fDefaultCellEditor = (iGCellEditorBase) new iGDefaultTextEditor();
        this.fCellEditor = this.fDefaultCellEditor;
      }
      this.fCellEditControl = this.fCellEditor.EditControl;
      bool passValueAsText = this.fCellEditor.PassValueAsText;
      this.fCellEditControl.Visible = false;
      this.fCellEditControl.PreviewKeyDown += new PreviewKeyDownEventHandler(this.fTextBox_PreviewKeyDown);
      this.fCellEditControl.KeyDown += new KeyEventHandler(this.fTextBox_KeyDown);
      this.fCellEditControl.KeyPress += new KeyPressEventHandler(this.fTextBox_KeyPress);
      this.fCellEditControl.KeyUp += new KeyEventHandler(this.fTextBox_KeyUp);
      this.fCellEditControl.TextChanged += new EventHandler(this.fTextBox_TextChanged);
      this.fCellEditControl.LostFocus += new EventHandler(this.fTextBox_LostFocus);
      this.fCellEditControl.Validating += new CancelEventHandler(this.fTextBox_Validating);
      this.fCellEditControl.MouseDown += new MouseEventHandler(this.fTextBox_MouseDown);
      this.fCellEditControl.MouseUp += new MouseEventHandler(this.fTextBox_MouseUp);
      this.fCellEditControl.MouseMove += new MouseEventHandler(this.fTextBox_MouseMove);
      this.fCellEditControl.MouseClick += new MouseEventHandler(this.fTextBox_MouseClick);
      this.fCellEditControl.MouseDoubleClick += new MouseEventHandler(this.fTextBox_MouseDoubleClick);
      this.fCellEditControl.MouseEnter += new EventHandler(this.fTextBox_MouseEnter);
      this.fCellEditControl.MouseLeave += new EventHandler(this.fTextBox_MouseLeave);
      this.fCellEditControl.MouseHover += new EventHandler(this.fTextBox_MouseHover);
      this.Controls.Add(this.fCellEditControl);
      System.Drawing.Color backColor;
      System.Drawing.Color foreColor;
      Font font;
      this.GetUniCellFormattingNoSelected(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2, iGControlState.Normal, isEven, !isEven, false, false, out backColor, out foreColor, out font);
      if (backColor.IsEmpty)
        backColor = this.BackColor;
      if ((int) backColor.A != (int) byte.MaxValue)
        backColor = System.Drawing.Color.FromArgb((int) byte.MaxValue, backColor);
      this.fCellEditControl.BackColor = backColor;
      this.fCellEditControl.ForeColor = foreColor;
      this.fCellEditControl.Font = font;
      StringAlignment stylesTextHalign = this.GetPropFromStyles_TextHAlign((iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      HorizontalAlignment horizontalAlignment = HorizontalAlignment.Left;
      switch (stylesTextHalign)
      {
        case StringAlignment.Near:
          horizontalAlignment = HorizontalAlignment.Left;
          break;
        case StringAlignment.Center:
          horizontalAlignment = HorizontalAlignment.Center;
          break;
        case StringAlignment.Far:
          horizontalAlignment = HorizontalAlignment.Right;
          break;
      }
      StringAlignment stylesTextValign = this.GetPropFromStyles_TextVAlign((iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      bool flag2 = (this.GetUniCellStringFormat(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2).FormatFlags & StringFormatFlags.NoWrap) != StringFormatFlags.NoWrap;
      int stylesDrawTypeFlags = (int) this.GetPropFromStyles_DrawTypeFlags((iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      int num1 = 64;
      bool flag3 = (stylesDrawTypeFlags & num1) == 64;
      int num2 = 128;
      char ch = (stylesDrawTypeFlags & num2) != 0 ? this.fPasswordCharEffective : char.MinValue;
      this.fCellEditor.MaxInputLength = this.GetPropFromStyles_MaxInputLength(style, cellStyle1, cellStyle2);
      this.fCellEditor.TextAlign = horizontalAlignment;
      this.fCellEditor.LineAlign = stylesTextValign;
      this.fCellEditor.WordWrap = flag2;
      this.fCellEditor.Multiline = flag3;
      this.fCellEditor.PasswordChar = ch;
      this.fCellEditor.SetTextRenderingHint(this.fTextRenderingHint);
      Rectangle suggestedBounds = textBoxBounds;
      if (!flag2 && !flag3)
      {
        int height = font.Height;
        if (suggestedBounds.Height > height)
        {
          switch (stylesTextValign)
          {
            case StringAlignment.Near:
              suggestedBounds.Height = height;
              break;
            case StringAlignment.Center:
              suggestedBounds.Y = suggestedBounds.Top + suggestedBounds.Height / 2 - height / 2;
              suggestedBounds.Height = height;
              break;
            case StringAlignment.Far:
              suggestedBounds.Y = suggestedBounds.Bottom - height;
              suggestedBounds.Height = height;
              break;
          }
        }
      }
      this.fCellEditor.SetBounds(textBoxBounds, suggestedBounds);
      if (passValueAsText)
        this.fCellEditControl.Text = (string) null;
      this.fEditType = iGEditType.TextEdit;
      this.fEditCell = new iGCellNavigator(rowIndex, colIndex);
      if (passValueAsText)
        this.fCellEditControl.Text = text;
      else
        this.fCellEditor.Value = this.GetCellDataInternal(rowIndex, colIndex).Value;
      if (passValueAsText)
      {
        if (flag1)
        {
          this.fCellEditor.SelectionStart = text == null ? 0 : text.Length;
        }
        else
        {
          this.fCellEditor.SelectionStart = 0;
          this.fCellEditor.SelectionLength = text == null ? 0 : text.Length;
        }
      }
      this.fCellEditControl.CausesValidation = true;
      this.fCellEditControl.Visible = true;
      this.fCellEditControl.Focus();
      this.SetupAutoCompleteControl(rowIndex, colIndex, style, cellStyle1, cellStyle2);
      if (!flag1)
        return;
      this.AdjustAutoCompleteControl(text);
    }

    private Rectangle GetTextBoxBounds(int rowIndex, int colIndex)
    {
      Rectangle cellTextAreaBounds = this.GetCellTextAreaBounds(rowIndex, colIndex);
      Rectangle areaBoundsNoRowHdr = this.GetCellsAreaBoundsNoRowHdr();
      if (cellTextAreaBounds.X < areaBoundsNoRowHdr.X)
      {
        cellTextAreaBounds.Width -= areaBoundsNoRowHdr.X - cellTextAreaBounds.X;
        cellTextAreaBounds.X = areaBoundsNoRowHdr.X;
      }
      if (cellTextAreaBounds.Right > areaBoundsNoRowHdr.Right)
        cellTextAreaBounds.Width -= cellTextAreaBounds.Right - areaBoundsNoRowHdr.Right;
      if (cellTextAreaBounds.Bottom > areaBoundsNoRowHdr.Bottom)
        cellTextAreaBounds.Height -= cellTextAreaBounds.Bottom - areaBoundsNoRowHdr.Bottom;
      if (cellTextAreaBounds.Width <= 0 || cellTextAreaBounds.Height <= 0)
        return Rectangle.Empty;
      return cellTextAreaBounds;
    }

    private void HideTextBox()
    {
      if (this.fCellEditControl == null)
        return;
      this.fCellEditControl.CausesValidation = false;
      this.fCellEditControl.Visible = false;
      this.fCellEditControl.PreviewKeyDown -= new PreviewKeyDownEventHandler(this.fTextBox_PreviewKeyDown);
      this.fCellEditControl.KeyDown -= new KeyEventHandler(this.fTextBox_KeyDown);
      this.fCellEditControl.KeyPress -= new KeyPressEventHandler(this.fTextBox_KeyPress);
      this.fCellEditControl.KeyUp -= new KeyEventHandler(this.fTextBox_KeyUp);
      this.fCellEditControl.TextChanged -= new EventHandler(this.fTextBox_TextChanged);
      this.fCellEditControl.LostFocus -= new EventHandler(this.fTextBox_LostFocus);
      this.fCellEditControl.Validating -= new CancelEventHandler(this.fTextBox_Validating);
      this.fCellEditControl.MouseDown -= new MouseEventHandler(this.fTextBox_MouseDown);
      this.fCellEditControl.MouseUp -= new MouseEventHandler(this.fTextBox_MouseUp);
      this.fCellEditControl.MouseMove -= new MouseEventHandler(this.fTextBox_MouseMove);
      this.fCellEditControl.MouseClick -= new MouseEventHandler(this.fTextBox_MouseClick);
      this.fCellEditControl.MouseDoubleClick -= new MouseEventHandler(this.fTextBox_MouseDoubleClick);
      this.fCellEditControl.MouseEnter -= new EventHandler(this.fTextBox_MouseEnter);
      this.fCellEditControl.MouseLeave -= new EventHandler(this.fTextBox_MouseLeave);
      this.fCellEditControl.MouseHover -= new EventHandler(this.fTextBox_MouseHover);
      this.Controls.Remove(this.fCellEditControl);
      this.fCellEditControl = (Control) null;
      this.fCellEditor = (iGCellEditorBase) null;
    }

    private void CommitEditCellAsTextBox()
    {
      this.Focus();
    }

    private void CommitTextBoxEditAfterValidation(object newValue, int newImageIndex, object newDropDownControlItem, bool modifyAuxValue)
    {
      iGCellNavigator fEditCell = this.fEditCell;
      this.fEditCell = iGCellNavigator.Empty;
      if (!fEditCell.IsEmpty)
      {
        fEditCell.RowIndex = this.SetCellValue(fEditCell.RowIndex, fEditCell.ColIndex, newValue, true, false, true);
        fEditCell.RowIndex = this.SetCellImageIndex(fEditCell.RowIndex, fEditCell.ColIndex, newImageIndex, true);
        if (modifyAuxValue)
          fEditCell.RowIndex = this.SetCellAuxValue(fEditCell.RowIndex, fEditCell.ColIndex, newDropDownControlItem, true);
      }
      int num = this.IsTextBoxFocused() ? 1 : 0;
      this.HideTextBox();
      this.ResetAutoCompleteControl();
      if (num != 0)
        this.Focus();
      if (fEditCell.IsEmpty)
        return;
      this.DoAfterCommitEdit(fEditCell.RowIndex, fEditCell.ColIndex);
    }

    private void CancelEditCellAsTextBox()
    {
      iGCellNavigator fEditCell = this.fEditCell;
      this.fEditCell = iGCellNavigator.Empty;
      int num = this.IsTextBoxFocused() ? 1 : 0;
      this.HideTextBox();
      this.ResetAutoCompleteControl();
      if (num != 0)
        this.Focus();
      if (fEditCell.IsEmpty)
        return;
      this.DoCancelEdit(fEditCell.RowIndex, fEditCell.ColIndex);
    }

    private bool IsTextBoxFocused()
    {
      if (this.fCellEditControl != null)
        return this.fCellEditControl.Focused;
      return false;
    }

    private bool IsTextBoxVisible()
    {
      if (this.fCellEditControl != null)
        return this.fCellEditControl.Visible;
      return false;
    }

    private bool IsCellInTextEdit(int rowIndex, int colIndex)
    {
      if (this.fEditType == iGEditType.TextEdit && this.fEditCell.RowIndex == rowIndex)
        return this.fEditCell.ColIndex == colIndex;
      return false;
    }

    private bool IsGridInTextEdit()
    {
      if (this.fEditType == iGEditType.TextEdit)
        return !this.fEditCell.IsEmpty;
      return false;
    }

    internal int GetTextBoxSelectionStart()
    {
      if (this.IsGridInTextEdit())
        return this.fCellEditor.SelectionStart;
      return 0;
    }

    internal void SetTextBoxSelectionStart(int value)
    {
      if (!this.IsGridInTextEdit())
        return;
      this.fCellEditor.SelectionStart = value;
    }

    internal int GetTextBoxSelectionLength()
    {
      if (this.IsGridInTextEdit())
        return this.fCellEditor.SelectionLength;
      return 0;
    }

    internal void SetTextBoxSelectionLength(int value)
    {
      if (!this.IsGridInTextEdit())
        return;
      this.fCellEditor.SelectionLength = value;
    }

    internal string GetTextBoxSelectedText()
    {
      if (this.IsGridInTextEdit())
        return this.fCellEditor.SelectedText;
      return (string) null;
    }

    internal void SetTextBoxSelectedText(string value)
    {
      if (!this.IsGridInTextEdit())
        return;
      this.fCellEditor.SelectedText = value;
    }

    internal string GetTextBoxText()
    {
      if (this.IsGridInTextEdit())
        return this.fCellEditControl.Text;
      return string.Empty;
    }

    internal void SetTextBoxText(string value)
    {
      if (!this.IsGridInTextEdit())
        return;
      this.fCellEditControl.Text = value;
    }

    internal bool TryToCommitTextEdit(object newValue, bool valueSpecified)
    {
      if (this.fEditCell.IsEmpty)
        return false;
      Exception exception1 = (Exception) null;
      object newValue1 = (object) null;
      iGCellData cellData = this.GetCellData(this.fEditCell.RowIndex, this.fEditCell.ColIndex);
      iGCellStyle cellStyle1 = this.GetRowDataInternal(this.fEditCell.RowIndex).CellStyle;
      iGCellStyle cellStyle2 = this.GetColDataInternal(this.fEditCell.ColIndex).CellStyle;
      string text = this.fCellEditControl.Text;
      if (valueSpecified)
        newValue1 = newValue;
      else if (this.fCellEditor.PassValueAsText)
      {
        try
        {
          if (text.Trim().Length == 0)
          {
            switch (this.GetPropFromStyles_EmptyStringAs(cellData.Style, cellStyle1, cellStyle2))
            {
              case iGEmptyStringAs.Null:
                newValue1 = (object) null;
                break;
              case iGEmptyStringAs.DBNull:
                newValue1 = (object) DBNull.Value;
                break;
              case iGEmptyStringAs.Zero:
                Type type1 = this.GetPropFromStyles_ValueType(cellData.Style, cellStyle1, cellStyle2);
                if (type1 == (Type) null && cellData.Value != null)
                  type1 = cellData.Value.GetType();
                newValue1 = !(type1 != (Type) null) || !this.IsNumericType(type1) ? (object) 0 : Convert.ChangeType((object) 0, type1);
                break;
              default:
                newValue1 = (object) string.Empty;
                break;
            }
          }
          else
          {
            Type fromStylesValueType = this.GetPropFromStyles_ValueType(cellData.Style, cellStyle1, cellStyle2);
            IFormatProvider stylesFormatProvider = this.GetPropFromStyles_FormatProvider((iGStyleBase) cellData.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
            Type type2 = !(fromStylesValueType != (Type) null) ? (cellData.Value == null || cellData.Value == DBNull.Value ? (Type) null : cellData.Value.GetType()) : fromStylesValueType;
            if (fromStylesValueType == (Type) null && (type2 == (Type) null || this.IsNumericType(type2)))
            {
              Exception exception2 = (Exception) null;
              if (type2 != (Type) null)
              {
                MethodInfo method = type2.GetMethod("Parse", new Type[3]
                {
                  typeof (string),
                  typeof (NumberStyles),
                  typeof (IFormatProvider)
                });
                if (method != (MethodInfo) null)
                {
                  try
                  {
                    newValue1 = method.Invoke((object) null, new object[3]
                    {
                      (object) text,
                      (object) NumberStyles.Any,
                      (object) stylesFormatProvider
                    });
                  }
                  catch (Exception ex)
                  {
                    if (fromStylesValueType != (Type) null)
                      throw ex.InnerException;
                    exception2 = ex.InnerException;
                  }
                }
              }
              if (!(type2 == (Type) null))
              {
                if (exception2 == null)
                  goto label_39;
              }
              double result;
              if (double.TryParse(text, NumberStyles.Any, stylesFormatProvider, out result))
              {
                try
                {
                  newValue1 = (object) int.Parse(text, NumberStyles.Any, stylesFormatProvider);
                }
                catch
                {
                  try
                  {
                    newValue1 = (object) long.Parse(text, NumberStyles.Any, stylesFormatProvider);
                  }
                  catch
                  {
                    try
                    {
                      newValue1 = (object) Decimal.Parse(text, NumberStyles.Any, stylesFormatProvider);
                    }
                    catch
                    {
                      newValue1 = (object) result;
                    }
                  }
                }
              }
              else
              {
                if (exception2 != null)
                  throw exception2;
                newValue1 = (object) text;
              }
            }
            else if (type2 != (Type) null)
            {
              if (type2.IsEnum)
              {
                newValue1 = Enum.Parse(type2, text, true);
                if (Enum.GetName(type2, newValue1) == null)
                  throw new InvalidCastException();
              }
              else
                newValue1 = Convert.ChangeType((object) text, type2, stylesFormatProvider);
            }
          }
        }
        catch (Exception ex)
        {
          exception1 = ex;
        }
      }
      else
        newValue1 = this.fCellEditor.Value;
label_39:
      iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType((iGStyleBase) cellData.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      IiGDropDownControl cellDropDownControl = this.GetUniCellDropDownControl(iGGridSection.Cells, this.fEditCell.RowIndex, this.fEditCell.ColIndex, (iGStyleBase) cellData.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2, false);
      bool modifyAuxValue = this.CanEditCellWithDropDown(fromStylesDrawType, cellDropDownControl);
      object newDropDownControlItem;
      int newImageIndex;
      if (modifyAuxValue && !this.fSaveTextAsIs)
      {
        iGCellDrawTypeFlags stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags((iGStyleBase) cellData.Style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
        try
        {
          newDropDownControlItem = (!cellDropDownControl.AutoSubstitution ? (object) null : (valueSpecified || (stylesDrawTypeFlags & iGCellDrawTypeFlags.ComboPreferValue) == iGCellDrawTypeFlags.ComboPreferValue ? (object) null : cellDropDownControl.GetItemByText(text))) ?? cellDropDownControl.GetItemByValue(newValue1, true);
        }
        catch
        {
          newDropDownControlItem = (object) null;
        }
        if (newDropDownControlItem != null)
        {
          newImageIndex = cellDropDownControl.GetItemImageIndex(newDropDownControlItem);
          newValue1 = cellDropDownControl.GetItemValue(newDropDownControlItem);
          exception1 = (Exception) null;
        }
        else
          newImageIndex = -1;
      }
      else
      {
        newImageIndex = cellData.ImageIndex;
        newDropDownControlItem = (object) null;
      }
      if (exception1 == null || this.fSilentValidation)
      {
        switch (this.DoBeforeCommitEdit(this.fEditCell.RowIndex, this.fEditCell.ColIndex, text, ref newValue1, ref newImageIndex, ref newDropDownControlItem, exception1))
        {
          case iGEditResult.Cancel:
            this.CancelEditCellAsTextBox();
            break;
          case iGEditResult.Commit:
            this.CommitTextBoxEditAfterValidation(newValue1, newImageIndex, newDropDownControlItem, modifyAuxValue);
            break;
          case iGEditResult.Proceed:
            this.fLockFirstMouseDown = true;
            return true;
        }
        return false;
      }
      this.fLockFirstMouseDown = true;
      int num = (int) MessageBox.Show((IWin32Window) this, exception1.Message, Application.ProductName, MessageBoxButtons.OK, MessageBoxIcon.Hand);
      return true;
    }

    private void fTextBox_PreviewKeyDown(object sender, PreviewKeyDownEventArgs e)
    {
      switch (e.KeyCode)
      {
        case Keys.Escape:
        case Keys.F4:
        case Keys.Tab:
        case Keys.Return:
          e.IsInputKey = true;
          break;
      }
    }

    private void fTextBox_KeyDown(object sender, KeyEventArgs e)
    {
      this.ProcessKeyDownByAutoCompleteControl(e);
      if (e.Handled)
        return;
      e.Handled = !this.DoTextBoxKeyDown(e.KeyData);
      if (e.Handled)
        return;
      switch (e.KeyCode)
      {
        case Keys.Escape:
          if (e.Alt || e.Control || e.Shift)
            return;
          this.CancelEditCellAsTextBox();
          e.SuppressKeyPress = true;
          break;
        case Keys.F4:
          if (e.Alt || e.Control || (e.Shift || !this.CanEditCellWithDropDown(this.fEditCell.RowIndex, this.fEditCell.ColIndex)))
            return;
          iGCellNavigator fEditCell = this.fEditCell;
          this.Focus();
          if (this.Focused)
          {
            this.StartEditCellOnKeyPress(char.MinValue, Keys.F4, this.GetCellDataInternal(fEditCell.RowIndex, fEditCell.ColIndex).Style, this.GetRowDataInternal(fEditCell.RowIndex).CellStyle, this.GetColDataInternal(fEditCell.ColIndex).CellStyle, true);
            break;
          }
          break;
        case Keys.Tab:
          if (this.fProcessTab)
          {
            this.Focus();
            if (this.Focused)
            {
              Keys modifierKeys = Control.ModifierKeys;
              if (!this.ProcessKeyDown(Keys.Tab, (modifierKeys & Keys.Shift) == Keys.Shift, (modifierKeys & Keys.Control) == Keys.Control, (modifierKeys & Keys.Alt) == Keys.Alt))
                return;
            }
          }
          else if (this.Parent != null)
            this.Parent.SelectNextControl((Control) this, true, true, false, true);
          e.SuppressKeyPress = true;
          break;
        case Keys.Return:
          if (!this.fEditCell.IsEmpty)
          {
            if (e.Shift)
            {
              this.fSaveTextAsIs = true;
              this.Focus();
            }
            else
            {
              if (this.fCellEditor.Multiline)
                return;
              this.Focus();
            }
          }
          e.SuppressKeyPress = true;
          break;
        default:
          return;
      }
      e.Handled = true;
    }

    private void fTextBox_KeyPress(object sender, KeyPressEventArgs e)
    {
      this.ProcessKeyPressByAutoCompleteControl(e);
      if (e.Handled)
        return;
      e.Handled = !this.DoTextBoxKeyPress(e.KeyChar);
      if (e.Handled)
        return;
      char keyChar = e.KeyChar;
      e.Handled = !this.DoTextBoxFilterChar(this.fEditCell.RowIndex, this.fEditCell.ColIndex, ref keyChar, true);
      e.KeyChar = keyChar;
      if (((int) e.KeyChar != 13 || this.fCellEditor.Multiline) && ((int) e.KeyChar != 9 && (int) e.KeyChar != 27))
        return;
      e.Handled = true;
    }

    private void fTextBox_KeyUp(object sender, KeyEventArgs e)
    {
      this.ProcessKeyUpByAutoCompleteControl(e);
      if (e.Handled)
        return;
      this.DoTextBoxKeyUp(e.KeyData);
    }

    private void fTextBox_LostFocus(object sender, EventArgs e)
    {
      this.HideAutoCompleteControl();
    }

    private void fTextBox_Validating(object sender, CancelEventArgs e)
    {
      e.Cancel = this.TryToCommitTextEdit((object) null, false);
    }

    private bool IsNumericType(Type type)
    {
      return !type.IsEnum && (uint) (Type.GetTypeCode(type) - 5) <= 10U;
    }

    private void fTextBox_TextChanged(object sender, EventArgs e)
    {
      this.AdjustAutoCompleteControl(this.fCellEditControl.Text);
      this.DoTextBoxTextChanged(e);
    }

    private void fTextBox_MouseHover(object sender, EventArgs e)
    {
      this.DoTextBoxMouseHover(e);
    }

    private void fTextBox_MouseLeave(object sender, EventArgs e)
    {
      this.DoTextBoxMouseLeave(e);
    }

    private void fTextBox_MouseEnter(object sender, EventArgs e)
    {
      this.DoTextBoxMouseEnter(e);
    }

    private void fTextBox_MouseDoubleClick(object sender, MouseEventArgs e)
    {
      this.DoTextBoxMouseDoubleClick(e);
    }

    private void fTextBox_MouseClick(object sender, MouseEventArgs e)
    {
      this.DoTextBoxMouseClick(e);
    }

    private void fTextBox_MouseMove(object sender, MouseEventArgs e)
    {
      this.DoTextBoxMouseMove(e);
    }

    private void fTextBox_MouseUp(object sender, MouseEventArgs e)
    {
      this.DoTextBoxMouseUp(e);
    }

    private void fTextBox_MouseDown(object sender, MouseEventArgs e)
    {
      this.DoTextBoxMouseDown(e);
    }

    private void AdjustAutoCompleteManager()
    {
      if (this.fAutoCompleteManager != null)
        return;
      this.fAutoCompleteManager = new iGDropDownManager((Control) this);
    }

    private bool IsAutoCompleteActive()
    {
      if (this.fEditCell.IsEmpty || this.fEditType != iGEditType.TextEdit || this.fAutoCompleteManager == null)
        return false;
      return this.fAutoCompleteManager.IsDropDownFormVisible;
    }

    private void SetupAutoCompleteControl(int rowIndex, int colIndex, iGCellStyle cellStyle, iGCellStyle rowStyle, iGCellStyle colStyle)
    {
      this.fAutoCompleteControl = this.GetUniCellDropDownControl(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) cellStyle, (iGStyleBase) rowStyle, (iGStyleBase) colStyle, true) as IiGAutoCompleteControl;
      if (this.fAutoCompleteControl == null)
        return;
      bool isEven = this.IsEvenRowInternal(rowIndex);
      Font uniCellFont = this.GetUniCellFont(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) cellStyle, (iGStyleBase) rowStyle, (iGStyleBase) colStyle, iGControlState.Normal, isEven, !isEven, false, false);
      this.fAutoCompleteControl.ValueSelected += new iGAutoCompleteControlValueSelectedEventHandler(this.fAutoCompleteControl_ValueSelected);
      this.fAutoCompleteControlControl = this.fAutoCompleteControl.GetDropDownControl(this, uniCellFont, typeof (IiGAutoCompleteControl));
      Control completeControlControl = this.fAutoCompleteControlControl;
    }

    private void AdjustAutoCompleteControl(string textBoxText)
    {
      if (this.fAutoCompleteControl == null || this.fAutoCompleteControlControl == null || this.fEditCell.IsEmpty)
        return;
      this.AdjustAutoCompleteManager();
      if (this.fAutoCompleteControl.OnCellTextChange(textBoxText))
      {
        if (this.fAutoCompleteManager.IsDropDownFormVisible)
          this.fAutoCompleteManager.AdjustSizeAndLocation((Control) this, this.GetCellBoundsToPassToDropDownManager(this.fEditCell.RowIndex, this.fEditCell.ColIndex));
        else
          this.fAutoCompleteManager.ShowDropDown(this.GetCellBoundsToPassToDropDownManager(this.fEditCell.RowIndex, this.fEditCell.ColIndex), (IiGDropDownControl) this.fAutoCompleteControl, this.fAutoCompleteControlControl, false, false, this.fTextRenderingHint);
      }
      else
        this.fAutoCompleteManager.HideDropDown(true);
      this.InvalidateCell(this.fEditCell.RowIndex, this.fEditCell.ColIndex);
    }

    private void ResetAutoCompleteControl()
    {
      if (this.fAutoCompleteManager != null)
        this.fAutoCompleteManager.HideDropDown(true);
      this.fAutoCompleteControl = (IiGAutoCompleteControl) null;
      this.fAutoCompleteControlControl = (Control) null;
    }

    private void HideAutoCompleteControl()
    {
      if (this.fAutoCompleteManager == null)
        return;
      this.fAutoCompleteManager.HideDropDown(true);
    }

    private void ProcessKeyDownByAutoCompleteControl(KeyEventArgs e)
    {
      if (this.fAutoCompleteControl == null || this.fAutoCompleteManager == null || !this.fAutoCompleteManager.IsDropDownFormVisible)
        return;
      this.fAutoCompleteControl.ProcessKeyDown(e);
    }

    private void ProcessKeyPressByAutoCompleteControl(KeyPressEventArgs e)
    {
      if (this.fAutoCompleteControl == null || this.fAutoCompleteManager == null || !this.fAutoCompleteManager.IsDropDownFormVisible)
        return;
      this.fAutoCompleteControl.ProcessKeyPress(e);
    }

    private void ProcessKeyUpByAutoCompleteControl(KeyEventArgs e)
    {
      this.AdjustAutoCompleteManager();
      if (this.fAutoCompleteControl == null || this.fAutoCompleteManager == null || !this.fAutoCompleteManager.IsDropDownFormVisible)
        return;
      this.fAutoCompleteControl.ProcessKeyUp(e);
    }

    private void fAutoCompleteControl_ValueSelected(object sender, iGAutoCompleteControlValueSelectedEventArgs e)
    {
      this.TryToCommitTextEdit(e.Value, true);
    }

    private bool DoRequestEdit(int rowIndex, int colIndex, char keyChar, ref string text, bool doDefault)
    {
      iGRequestEditEventArgs e = new iGRequestEditEventArgs(rowIndex, colIndex - 1, keyChar, text, doDefault);
      this.OnRequestEdit(e);
      text = e.Text;
      return e.DoDefault;
    }

    private void DoQuitCustomEdit()
    {
      this.OnQuitCustomEdit(EventArgs.Empty);
    }

    private iGEditResult DoBeforeCommitEdit(int rowIndex, int colIndex, string newText, ref object newValue, ref int newImageIndex, ref object newDropDownControlItem, Exception exception)
    {
      iGBeforeCommitEditEventArgs e = new iGBeforeCommitEditEventArgs(rowIndex, colIndex - 1, newText, newValue, newImageIndex, newDropDownControlItem, exception);
      this.OnBeforeCommitEdit(e);
      newValue = e.NewValue;
      newImageIndex = e.NewImageIndex;
      newDropDownControlItem = e.NewDropDownControlItem;
      return e.Result;
    }

    private void DoAfterCommitEdit(int rowIndex, int colIndex)
    {
      this.OnAfterCommitEdit(new iGAfterCommitEditEventArgs(rowIndex, colIndex - 1));
    }

    private void DoCancelEdit(int rowIndex, int colIndex)
    {
      this.OnCancelEdit(new iGCancelEditEventArgs(rowIndex, colIndex - 1));
    }

    private bool DoTextBoxKeyDown(Keys keyData)
    {
      if (this.fEditCell.IsEmpty)
        return false;
      iGTextBoxKeyDownEventArgs e = new iGTextBoxKeyDownEventArgs(this.fEditCell.RowIndex, this.fEditCell.ColIndex - 1, keyData);
      this.OnTextBoxKeyDown(e);
      return e.DoDefault;
    }

    private bool DoTextBoxKeyPress(char keyChar)
    {
      if (this.fEditCell.IsEmpty)
        return false;
      iGTextBoxKeyPressEventArgs e = new iGTextBoxKeyPressEventArgs(this.fEditCell.RowIndex, this.fEditCell.ColIndex - 1, keyChar);
      this.OnTextBoxKeyPress(e);
      return e.DoDefault;
    }

    private void DoTextBoxKeyUp(Keys keyData)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxKeyUp(new iGTextBoxKeyUpEventArgs(this.fEditCell.RowIndex, this.fEditCell.ColIndex - 1, keyData));
    }

    private void DoTextBoxTextChanged(EventArgs e)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxTextChanged(new iGTextBoxTextChangedEventArgs(this.fEditCell.RowIndex, this.fEditCell.ColIndex - 1));
    }

    private bool DoTextBoxFilterChar(int rowIndex, int colIndex, ref char @char, bool checkIsInEdit)
    {
      if (checkIsInEdit && !this.IsGridInTextEdit())
        return false;
      if (!this.IsInputSymbol(@char))
        return true;
      iGTextBoxFilterCharEventArgs e = new iGTextBoxFilterCharEventArgs(rowIndex, colIndex - 1, @char);
      this.OnTextBoxFilterChar(e);
      @char = e.Char;
      return (uint) e.Char > 0U;
    }

    private void DoTextBoxMouseHover(EventArgs e)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxMouseHover(e);
    }

    private void DoTextBoxMouseLeave(EventArgs e)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxMouseLeave(e);
    }

    private void DoTextBoxMouseEnter(EventArgs e)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxMouseEnter(e);
    }

    private void DoTextBoxMouseDoubleClick(MouseEventArgs e)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxMouseDoubleClick(e);
    }

    private void DoTextBoxMouseClick(MouseEventArgs e)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxMouseClick(e);
    }

    private void DoTextBoxMouseMove(MouseEventArgs e)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxMouseMove(e);
    }

    private void DoTextBoxMouseUp(MouseEventArgs e)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxMouseUp(e);
    }

    private void DoTextBoxMouseDown(MouseEventArgs e)
    {
      if (this.fEditCell.IsEmpty)
        return;
      this.OnTextBoxMouseDown(e);
    }

    private IiGDropDownControl DoRequestDropDownControl(int rowIndex, int colIndex, IiGDropDownControl control)
    {
      iGRequestDropDownControlEventArgs e = new iGRequestDropDownControlEventArgs(rowIndex, colIndex - 1, control);
      this.OnRequestDropDownControl(e);
      return e.Control;
    }

    private IiGAutoCompleteControl DoRequestAutoCompleteContorol(int rowIndex, int colIndex, IiGAutoCompleteControl control)
    {
      iGRequestAutoCompleteControlEventArgs e = new iGRequestAutoCompleteControlEventArgs(rowIndex, colIndex - 1, control);
      this.OnRequestAutoCompleteControl(e);
      return e.Control;
    }

    private iGEditResult DoColHdrComboBeforeCommit(int rowIndex, int colIndex, object newValue, int newImageIndex, object newDropDownControlItem)
    {
      iGColHdrComboBeforeCommitEventArgs e = new iGColHdrComboBeforeCommitEventArgs(rowIndex, colIndex - 1, newValue, newImageIndex, newDropDownControlItem);
      this.OnColHdrComboBeforeCommit(e);
      return e.Result;
    }

    private void DoColHdrComboAfterCommit(int rowIndex, int colIndex)
    {
      this.OnColHdrComboAfterCommit(new iGColHdrComboAfterCommitEventArgs(rowIndex, colIndex - 1));
    }

    private void DoColHdrComboCancel(int rowIndex, int colIndex)
    {
      this.OnColHdrComboCancel(new iGColHdrComboCancelEventArgs(rowIndex, colIndex - 1));
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestEdit" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestEditEventArgs" /> that contains the event data.</param>
    protected virtual void OnRequestEdit(iGRequestEditEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestEdit == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestEdit((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.QuitCustomEdit" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnQuitCustomEdit(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.QuitCustomEdit == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.QuitCustomEdit((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.BeforeCommitEdit" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGBeforeCommitEditEventArgs" /> that contains the event data.</param>
    protected virtual void OnBeforeCommitEdit(iGBeforeCommitEditEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.BeforeCommitEdit == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.BeforeCommitEdit((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.AfterCommitEdit" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGAfterCommitEditEventArgs" /> that contains the event data.</param>
    protected virtual void OnAfterCommitEdit(iGAfterCommitEditEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.AfterCommitEdit == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.AfterCommitEdit((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CancelEdit" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCancelEditEventArgs" /> that contains the event data.</param>
    protected virtual void OnCancelEdit(iGCancelEditEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CancelEdit == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CancelEdit((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxKeyDown" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGTextBoxKeyDownEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxKeyDown(iGTextBoxKeyDownEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxKeyDown == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxKeyDown((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxKeyPress" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGTextBoxKeyPressEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxKeyPress(iGTextBoxKeyPressEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxKeyPress == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxKeyPress((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxKeyUp" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGTextBoxKeyUpEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxKeyUp(iGTextBoxKeyUpEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxKeyUp == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxKeyUp((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxTextChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGTextBoxTextChangedEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxTextChanged(iGTextBoxTextChangedEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxTextChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxTextChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxFilterChar" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGTextBoxFilterCharEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxFilterChar(iGTextBoxFilterCharEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxFilterChar == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxFilterChar((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxMouseHover" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxMouseHover(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxMouseHover == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxMouseHover((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxMouseLeave" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxMouseLeave(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxMouseLeave == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxMouseLeave((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxMouseEnter" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxMouseEnter(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxMouseEnter == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxMouseEnter((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxMouseClick" /> event.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.MouseEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxMouseDoubleClick(MouseEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxMouseDoubleClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxMouseDoubleClick((object) this, (EventArgs) e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxMouseClick" /> event.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.MouseEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxMouseClick(MouseEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxMouseClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxMouseClick((object) this, (EventArgs) e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxMouseMove" /> event.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.MouseEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxMouseMove(MouseEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxMouseMove == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxMouseMove((object) this, (EventArgs) e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxMouseUp" /> event.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.MouseEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxMouseUp(MouseEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxMouseUp == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxMouseUp((object) this, (EventArgs) e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.TextBoxMouseDown" /> event.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.MouseEventArgs" /> that contains the event data.</param>
    protected virtual void OnTextBoxMouseDown(MouseEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.TextBoxMouseDown == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.TextBoxMouseDown((object) this, (EventArgs) e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestDropDownControl" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestDropDownControlEventArgs" />  that contains the event data.</param>
    protected virtual void OnRequestDropDownControl(iGRequestDropDownControlEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestDropDownControl == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestDropDownControl((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestAutoCompleteControl" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestAutoCompleteControlEventArgs" /> that contains the event data.</param>
    protected virtual void OnRequestAutoCompleteControl(iGRequestAutoCompleteControlEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestAutoCompleteControl == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestAutoCompleteControl((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrComboBeforeCommit" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrComboBeforeCommitEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrComboBeforeCommit(iGColHdrComboBeforeCommitEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrComboBeforeCommit == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrComboBeforeCommit((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrComboAfterCommit" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrComboAfterCommitEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrComboAfterCommit(iGColHdrComboAfterCommitEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrComboAfterCommit == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrComboAfterCommit((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrComboCancel" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrComboCancelEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrComboCancel(iGColHdrComboCancelEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrComboCancel == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrComboCancel((object) this, e);
    }

    /// <summary>Gets or sets a value indicating whether the cells can be edited.</summary>
    /// <value>True if the cells are read only; otherwise, False.</value>
    [DefaultValue(false)]
    [Category("Behavior")]
    [Description("Determines whether the cells can be edited.")]
    public bool ReadOnly
    {
      get
      {
        return this.fReadOnly;
      }
      set
      {
        if (value == this.fReadOnly)
          return;
        this.fReadOnly = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets a value indicating whether column resizing, column moving, auto scrolling, cell selecting and scrolling are allowed. Use this property to provide custom editing with validation.</summary>
    /// <value>True if all the operations that concern the mouse are locked; otherwise, False.</value>
    [DefaultValue(false)]
    [Browsable(false)]
    public bool MouseDownLocked
    {
      get
      {
        return this.fMouseDownLocked;
      }
      set
      {
        this.fMouseDownLocked = value;
        this.fHScrollBar.MouseDownLocked = value;
        this.fVScrollBar.MouseDownLocked = value;
      }
    }

    /// <summary>Gets a value indicating whether the grid is being edited.</summary>
    /// <value>True if the current cell is being edited; otherwise, False.</value>
    [Browsable(false)]
    public bool IsEditing
    {
      get
      {
        return !this.fEditCell.IsEmpty;
      }
    }

    /// <summary>Gets or sets a value indicating whether to draw the grid as if it had focus. Use this property to implement custom editing.</summary>
    /// <value>True if the grid is drawn as if it was focused; otherwise, False.</value>
    [Browsable(false)]
    [DefaultValue(false)]
    public bool DrawAsFocused
    {
      get
      {
        return this.fDrawAsFocused;
      }
      set
      {
        this.fDrawAsFocused = value;
      }
    }

    /// <summary>Gets or sets a value indicating whether the combo button in the current cell is pressed or not.</summary>
    /// <value>True if the combo button in the current cell is always pressed; otherwise, False. The default is False.</value>
    [Browsable(false)]
    [DefaultValue(false)]
    public bool CurCellComboPressed
    {
      get
      {
        return this.fCurCellComboPressed;
      }
      set
      {
        this.fCurCellComboPressed = value;
        if (!value)
          return;
        this.InvalidateCurrentCellOrRowIfNecessary();
      }
    }

    /// <summary>Gets the object which represents the text box used to edit the text and combo box cells of the grid.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGTextBox" /> class which exposes some properties of the text box used to edit the text and combo cells.</value>
    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public iGTextBox TextBox
    {
      get
      {
        if (this.fTextBoxObject == null)
          this.fTextBoxObject = new iGTextBox(this);
        return this.fTextBoxObject;
      }
    }

    /// <summary>Gets or sets a value indicating whether to display a standard error message for a text box cell while converting an entered text to the cell's value.</summary>
    /// <value>False if the standard message box is displayed; otherwise, True. The default is False.</value>
    [DefaultValue(false)]
    [Category("Behavior")]
    [Description("Determines whether to display a standard error message for a text box cell while converting an entered text to the cell's value.")]
    public bool SilentValidation
    {
      get
      {
        return this.fSilentValidation;
      }
      set
      {
        this.fSilentValidation = value;
      }
    }

    /// <summary>Gets or sets a value that determines whether a single mouse click puts any cell into edit mode.</summary>
    /// <value>False if only the current cell can be edited with a single mouse click; otherwise, True. The default is False.</value>
    [DefaultValue(false)]
    [Category("Behavior")]
    [Description("Determines whether the single mouse click starts editing a not current cell. If False, only the current cell can be edited with the single mouse click; otherwise, the single click on any of the cells starts its editing.")]
    public bool SingleClickEdit
    {
      get
      {
        return this.fSingleClickEdit;
      }
      set
      {
        this.fSingleClickEdit = value;
      }
    }

    /// <summary>Specifies whether any drop-down control will be closed automatically if it loses the input focus.</summary>
    /// <value>Specifies whether any drop-down control will be closed automatically if it loses the input focus. The default value is True.</value>
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [Browsable(false)]
    public bool HideDropDownOnDeactivate
    {
      get
      {
        return this.fHideDropDownOnDeactivate;
      }
      set
      {
        this.fHideDropDownOnDeactivate = value;
        if (this.fDropDownManager == null || !this.fDropDownManager.IsDropDownFormVisible)
          return;
        this.fDropDownManager.DoNotHideWhenDeactivate = !this.fHideDropDownOnDeactivate;
      }
    }

    /// <summary>Occurs before the user starts cell editing.</summary>
    [Category("Editing")]
    [Description("Occurs before the user starts cell editing.")]
    public event iGRequestEditEventHandler RequestEdit;

    /// <summary>Occurs when the grid demands to quit custom editing immediately.</summary>
    [Category("Editing")]
    [Description("Occurs when the grid demands to quit custom editing immediately.")]
    public event EventHandler QuitCustomEdit;

    /// <summary>Occurs when the user tries to commit cell changes.</summary>
    [Category("Editing")]
    [Description("Occurs when the user tries to commit cell changes.")]
    public event iGBeforeCommitEditEventHandler BeforeCommitEdit;

    /// <summary>Occurs when the user has finished cell editing and the changes have been committed.</summary>
    [Category("Editing")]
    [Description("Occurs when the user has finished cell editing and the changes have been committed.")]
    public event iGAfterCommitEditEventHandler AfterCommitEdit;

    /// <summary>Occurs when the user has finished cell editing and the changes have been aborted.</summary>
    [Category("Editing")]
    [Description("Occurs when the user has finished cell editing and the changes have been aborted.")]
    public event iGCancelEditEventHandler CancelEdit;

    /// <summary>Occurs when iGrid needs to obtain the drop-down control for a cell.</summary>
    [Category("Editing")]
    [Description("Occurs when the grid requests a drop-down control for a cell. This event allows you to dynamically attach a drop-down control to the cell.")]
    public event iGRequestDropDownControlEventHandler RequestDropDownControl;

    /// <summary>Occurs when iGrid needs to obtain the auto-complete control for a cell.</summary>
    [Category("Editing")]
    [Description("Occurs when the grid requests an auto-complete control for a cell. This event allows you to dynamically attach an auto-complete control to the cell.")]
    public event iGRequestAutoCompleteControlEventHandler RequestAutoCompleteControl;

    /// <summary>Occurs when a key is pressed while editing a text cell.</summary>
    [Category("Editing")]
    [Description("Occurs when a key is pressed while editing a text box cell.")]
    public event iGTextBoxKeyDownEventHandler TextBoxKeyDown;

    /// <summary>Occurs when a key is pressed while editing a text cell.</summary>
    [Category("Editing")]
    [Description("Occurs when a key is pressed while editing a text box cell.")]
    public event iGTextBoxKeyPressEventHandler TextBoxKeyPress;

    /// <summary>Occurs when a key is released while editing a text cell.</summary>
    [Category("Editing")]
    [Description("Occurs when a key is released while editing a text box cell.")]
    public event iGTextBoxKeyUpEventHandler TextBoxKeyUp;

    /// <summary>Occurs when the value of the text box in a text cell has been changed.</summary>
    [Category("Editing")]
    [Description("Occurs when the value of the text box in a text cell has been changed.")]
    public event iGTextBoxTextChangedEventHandler TextBoxTextChanged;

    /// <summary>Occurs before a key char is processed by the text box in a text cell. Allows you to filter the input chars.</summary>
    [Category("Editing")]
    [Description("Occurs before a key char is processed by the text box in a text cell. Allows you to filter the input chars.")]
    public event iGTextBoxFilterCharEventHandler TextBoxFilterChar;

    /// <summary>Occurs when the mouse pointer rests on a text cell when it is in edit mode.</summary>
    [Category("Editing")]
    [Description("Occurs when the mouse pointer rests on the text box used to edit text cells.")]
    public event EventHandler TextBoxMouseHover;

    /// <summary>Occurs when the mouse pointer leaves a text cell while it is in edit mode.</summary>
    [Category("Editing")]
    [Description("Occurs when the mouse pointer leaves the text box used to edit text cells.")]
    public event EventHandler TextBoxMouseLeave;

    /// <summary>Occurs when the mouse pointer enters a text cell while it is in edit mode.</summary>
    [Category("Editing")]
    [Description("Occurs when the mouse pointer enters the text box used to edit text cells.")]
    public event EventHandler TextBoxMouseEnter;

    /// <summary>Occurs when a text cell is double-clicked while it is in edit mode.</summary>
    [Category("Editing")]
    [Description("Occurs when the text box used to edit text cells is double-clicked.")]
    public event EventHandler TextBoxMouseDoubleClick;

    /// <summary>Occurs when a text cell is clicked while it is in edit mode.</summary>
    [Category("Editing")]
    [Description("Occurs when the text box used to edit text cells is clicked by the mouse.")]
    public event EventHandler TextBoxMouseClick;

    /// <summary>Occurs when the mouse pointer moves over a text cell while it is in edit mode.</summary>
    [Category("Editing")]
    [Description("Occurs when the mouse pointer is moved over the text box used to edit text cells.")]
    public event EventHandler TextBoxMouseMove;

    /// <summary>Occurs when the mouse pointer is over a text cell in edit mode and a mouse button is released.</summary>
    [Category("Editing")]
    [Description("Occurs when the mouse pointer is over the text box used to edit text cells and a mouse button is released.")]
    public event EventHandler TextBoxMouseUp;

    /// <summary>Occurs when the mouse pointer is over a text cell in edit mode and a mouse button is pressed.</summary>
    [Category("Editing")]
    [Description("Occurs when the mouse pointer is over the text box used to edit text cells and a mouse button is pressed.")]
    public event EventHandler TextBoxMouseDown;

    /// <summary>Occurs when the user is about to finish editing in a column header by choosing an item in the drop-down control.</summary>
    [Category("Column Header Combo")]
    [Description("Occurs when the user tries to select an item in the drop-down list attached to the column header.")]
    public event iGColHdrComboBeforeCommitEventHandler ColHdrComboBeforeCommit;

    /// <summary>Occurs when the user has finished editing in a column header by choosing an item in the drop-down control.</summary>
    [Category("Column Header Combo")]
    [Description("Occurs when the user has selected an item in the drop-down list attached to the column header.")]
    public event iGColHdrComboAfterCommitEventHandler ColHdrComboAfterCommit;

    /// <summary>Occurs when the user cancels editing in a column header by closing its drop-down control.</summary>
    [Category("Column Header Combo")]
    [Description("Occurs when the user has cancelled the selection of an item in the drop-down list attached to the column header.")]
    public event iGColHdrComboCancelEventHandler ColHdrComboCancel;

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />.</summary>
    /// <param name="keyData">One of the <see cref="T:System.Windows.Forms.Keys" /> values.</param>
    /// <returns>True if the specified key is a regular input key; otherwise, False.</returns>
    protected override bool IsInputKey(Keys keyData)
    {
      Keys keys = keyData & ~Keys.Shift & ~Keys.Control;
      if (keys <= Keys.Return)
      {
        if (keys != Keys.Tab)
        {
          if (keys == Keys.Return)
            return this.fProcessEnter;
        }
        else
          return this.fProcessTab;
      }
      else
      {
        if ((uint) (keys - 16) > 1U)
        {
          if (keys != Keys.Escape)
          {
            if ((uint) (keys - 32) > 8U)
              goto label_16;
          }
          else
            return this.fSearchAsTypeObject != null && this.fSearchAsTypeObject.IsActive;
        }
        return true;
      }
label_16:
      return base.IsInputKey(keyData);
    }

    private bool IsInputSymbol(char @char)
    {
      if (!char.IsLetterOrDigit(@char) && !char.IsWhiteSpace(@char) && !char.IsPunctuation(@char))
        return char.IsSymbol(@char);
      return true;
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> that contains the event data.</param>
    protected override void OnKeyPress(KeyPressEventArgs e)
    {
      base.OnKeyPress(e);
      if (e.Handled)
        return;
      this.SearchAsTypeProcessKeyPress(e);
      if (e.Handled || !this.IsEditingInputChar(e.KeyChar))
        return;
      iGCellNavigator fCurCell = this.fCurCell;
      bool flag = !fCurCell.IsEmpty;
      if ((int) e.KeyChar == 32)
      {
        if (this.fSelectionMode == iGSelectionMode.MultiSimple)
          flag = false;
        else if (this.fSelectionMode == iGSelectionMode.MultiExtended && Control.ModifierKeys != Keys.None)
          flag = false;
      }
      if (!flag)
        return;
      iGRowData rowDataInternal = this.GetRowDataInternal(fCurCell.RowIndex);
      iGCellStyle style = this.GetCellDataInternal(fCurCell.RowIndex, fCurCell.ColIndex).Style;
      iGCellStyle cellStyle = this.GetColData(fCurCell.ColIndex).CellStyle;
      if (this.IsGridInTextEdit())
      {
        char keyChar = e.KeyChar;
        e.Handled = this.DoTextBoxFilterChar(this.fEditCell.RowIndex, this.fEditCell.ColIndex, ref keyChar, false);
        if ((int) keyChar == 0)
          return;
        this.fCellEditControl.Text += keyChar.ToString();
        this.fCellEditor.SelectionStart = this.fCellEditControl.Text == null ? 0 : this.fCellEditControl.Text.Length;
      }
      else
        e.Handled = this.StartEditCellOnKeyPress(e.KeyChar, Keys.None, style, rowDataInternal.CellStyle, cellStyle, rowDataInternal.Type == iGRowType.Normal);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />.</summary>
    /// <param name="charCode">The character to test.</param>
    /// <returns>True if the character should be sent directly to the control and not preprocessed; otherwise, False.</returns>
    protected override bool IsInputChar(char charCode)
    {
      if (!this.IsSearchAsTypeInputChar(charCode))
        return this.IsEditingInputChar(charCode);
      return true;
    }

    private bool IsEditingInputChar(char charCode)
    {
      if (this.IsInputSymbol(charCode) && (int) charCode != 9)
        return (int) charCode != 13;
      return false;
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.KeyEventArgs" /> that contains the event data.</param>
    protected override void OnKeyDown(KeyEventArgs e)
    {
      base.OnKeyDown(e);
      if (!e.Handled)
        this.SearchAsTypeProcessKeyDown(e);
      if (!e.Handled)
        e.Handled = this.ProcessKeyDown(e.KeyCode, e.Shift, e.Control, e.Alt);
      if (!e.Handled || !this.StopAnyMouseAction(false))
        return;
      this.ProcessMouseMove();
    }

    private bool ProcessKeyDown(Keys keyCode, bool shift, bool control, bool alt)
    {
      bool flag1 = this.RightToLeft == RightToLeft.Yes;
      iGCellNavigator fCurCell = this.fCurCell;
      bool flag2 = false;
      bool skipGroupRows = ((this.fSelectionMode == iGSelectionMode.MultiExtended ? 1 : (this.fSelectionMode == iGSelectionMode.MultiSimple ? 1 : 0)) & (shift ? 1 : 0)) != 0;
      switch (keyCode)
      {
        case Keys.Escape:
          if (alt | control | shift)
            return false;
          this.CancelSearchAsType();
          break;
        case Keys.Space:
          if (!fCurCell.IsEmpty)
          {
            if (this.fSelectionMode == iGSelectionMode.MultiExtended)
            {
              this.ChangeSelectionOnCellMouseDown(fCurCell.RowIndex, fCurCell.ColIndex, control, false, false);
              break;
            }
            if (this.fSelectionMode == iGSelectionMode.MultiSimple)
            {
              this.ChangeSelectionOnCellMouseDown(fCurCell.RowIndex, fCurCell.ColIndex, true, false, false);
              break;
            }
            break;
          }
          break;
        case Keys.Prior:
          if (this.fSelectionMode != iGSelectionMode.None)
          {
            this.ActionPrevPage(false, skipGroupRows);
            flag2 = true;
            break;
          }
          if (this.CanScrollVert())
          {
            this.SetVScrollBarValue(this.fVScrollBar.Value - this.fVScrollBar.LargeChange, false);
            break;
          }
          break;
        case Keys.Next:
          if (this.fSelectionMode != iGSelectionMode.None)
          {
            this.ActionNextPage(false, skipGroupRows);
            flag2 = true;
            break;
          }
          if (this.CanScrollVert())
          {
            this.SetVScrollBarValue(this.fVScrollBar.Value + this.fVScrollBar.LargeChange, false);
            break;
          }
          break;
        case Keys.End:
          if (control || this.fRowMode && !this.fRowModeHasCurCell)
            this.ActionLastRowCol(false, skipGroupRows);
          else
            this.ActionLastCol(false);
          flag2 = true;
          break;
        case Keys.Home:
          if (control || this.fRowMode && !this.fRowModeHasCurCell)
            this.ActionFirstRowCol(false, skipGroupRows);
          else
            this.ActionFirstCol(false);
          flag2 = true;
          break;
        case Keys.Left:
        case Keys.Right:
        case Keys.Tab:
          if (keyCode == Keys.Left && !flag1 || (keyCode == Keys.Right & flag1 || keyCode == Keys.Tab & shift))
          {
            if (!fCurCell.IsEmpty && keyCode != Keys.Tab)
            {
              iGRowData rowDataInternal = this.GetRowDataInternal(fCurCell.RowIndex);
              if (rowDataInternal.TreeButton == iGTreeButtonState.Visible && rowDataInternal.Expanded && (this.IsGroupRow(rowDataInternal) || this.fRowMode && !this.fRowModeHasCurCell) && this.DoBeforeRowStateChanged(fCurCell.RowIndex, rowDataInternal.Expanded))
              {
                this.ExpandCollapseRow(fCurCell.RowIndex, rowDataInternal, false);
                this.DoAfterRowStateChanged(fCurCell.RowIndex, false);
                break;
              }
            }
            if ((!this.fRowMode || this.fRowModeHasCurCell) && this.fSelectionMode != iGSelectionMode.None)
            {
              this.ActionPrevCol(false);
              flag2 = true;
              break;
            }
            if (keyCode == Keys.Tab)
            {
              if (this.fSelectionMode != iGSelectionMode.None)
              {
                this.ActionPrevRow(false, skipGroupRows);
                flag2 = true;
                break;
              }
              break;
            }
            if (this.CanScrollHorz())
            {
              this.SetHScrollBarValue(this.fHScrollBar.Value - this.fHScrollBar.SmallChange, false);
              break;
            }
            break;
          }
          if (!fCurCell.IsEmpty && keyCode != Keys.Tab)
          {
            iGRowData rowDataInternal = this.GetRowDataInternal(fCurCell.RowIndex);
            if (rowDataInternal.TreeButton == iGTreeButtonState.Visible && !rowDataInternal.Expanded && (this.IsGroupRow(rowDataInternal) || this.fRowMode && !this.fRowModeHasCurCell) && this.DoBeforeRowStateChanged(fCurCell.RowIndex, rowDataInternal.Expanded))
            {
              this.ExpandCollapseRow(fCurCell.RowIndex, rowDataInternal, true);
              this.DoAfterRowStateChanged(fCurCell.RowIndex, true);
              break;
            }
          }
          if ((!this.fRowMode || this.fRowModeHasCurCell) && this.fSelectionMode != iGSelectionMode.None)
          {
            this.ActionNextCol(false);
            flag2 = true;
            break;
          }
          if (keyCode == Keys.Tab)
          {
            if (this.fSelectionMode != iGSelectionMode.None)
            {
              this.ActionNextRow(false, skipGroupRows);
              flag2 = true;
              break;
            }
            break;
          }
          if (this.CanScrollHorz())
          {
            this.SetHScrollBarValue(this.fHScrollBar.Value + this.fHScrollBar.SmallChange, false);
            break;
          }
          break;
        case Keys.Up:
          if (this.fSelectionMode != iGSelectionMode.None)
          {
            this.ActionPrevRow(false, skipGroupRows);
            flag2 = true;
            break;
          }
          if (this.CanScrollVert())
          {
            this.SetVScrollBarValue(this.fVScrollBar.Value - this.fVScrollBar.SmallChange, false);
            break;
          }
          break;
        case Keys.Down:
          if (this.fSelectionMode != iGSelectionMode.None)
          {
            this.ActionNextRow(false, skipGroupRows);
            flag2 = true;
            break;
          }
          if (this.CanScrollVert())
          {
            this.SetVScrollBarValue(this.fVScrollBar.Value + this.fVScrollBar.SmallChange, false);
            break;
          }
          break;
        case Keys.F2:
        case Keys.F4:
        case Keys.Return:
          if (alt | control | shift || keyCode == Keys.Return && !this.fProcessEnter)
            return false;
          if (!fCurCell.IsEmpty)
          {
            iGCellStyle style = this.GetCellDataInternal(fCurCell.RowIndex, fCurCell.ColIndex).Style;
            iGCellStyle cellStyle = this.fColDatas[fCurCell.ColIndex].CellStyle;
            iGRowData rowDataInternal = this.GetRowDataInternal(fCurCell.RowIndex);
            if (keyCode == Keys.Return && rowDataInternal.TreeButton == iGTreeButtonState.Visible && (this.IsGroupRow(rowDataInternal) || this.fRowMode && !this.fRowModeHasCurCell))
            {
              if (!this.DoBeforeRowStateChanged(fCurCell.RowIndex, rowDataInternal.Expanded))
                return false;
              this.ExpandCollapseRow(fCurCell.RowIndex, rowDataInternal, !rowDataInternal.Expanded);
              this.DoAfterRowStateChanged(fCurCell.RowIndex, !rowDataInternal.Expanded);
              break;
            }
            if (keyCode == Keys.F4 && !this.CanEditCellWithDropDown(fCurCell.RowIndex, fCurCell.ColIndex, (iGStyleBase) style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle) || !this.StartEditCellOnKeyPress(keyCode == Keys.Return ? '\r' : char.MinValue, keyCode, style, rowDataInternal.CellStyle, cellStyle, true))
              return false;
            break;
          }
          break;
        default:
          return false;
      }
      if (flag2 && this.fCurCell.RowIndex != fCurCell.RowIndex || !this.fRowMode && this.fCurCell.ColIndex != fCurCell.ColIndex)
        this.ChangeSelectionOnCurCellKeyboardChange(fCurCell, control, shift);
      return true;
    }

    private bool IsSearchAsTypeFilteringActive()
    {
      this.AdjustSearchAsTypeObject();
      if (this.fSearchAsTypeObject.fManager != null && this.fSearchAsTypeObject.fManager.IsActive)
        return this.fSearchAsTypeObject.fManager.Mode == iGSearchAsTypeMode.Filter;
      return false;
    }

    private void AdjustSearchAsTypeObject()
    {
      if (this.fSearchAsTypeObject != null)
        return;
      this.fSearchAsTypeObject = new iGSearchAsType(this);
    }

    private bool IsSearchAsTypeActive()
    {
      this.AdjustSearchAsTypeObject();
      if (this.fSearchAsTypeObject.fManager != null)
        return this.fSearchAsTypeObject.fManager.IsActive;
      return false;
    }

    private void CancelSearchAsType()
    {
      if (this.fSearchAsTypeObject == null)
        return;
      this.fSearchAsTypeObject.Cancel(false);
    }

    private void SearchAsTypeProcessKeyPress(KeyPressEventArgs e)
    {
      this.AdjustSearchAsTypeObject();
      if (this.fSearchAsTypeObject.Mode == iGSearchAsTypeMode.None)
        return;
      this.fSearchAsTypeObject.AdjustManager();
      this.fSearchAsTypeObject.fManager.OnKeyPress(e);
    }

    private bool IsSearchAsTypeInputChar(char charCode)
    {
      this.AdjustSearchAsTypeObject();
      if (this.fSearchAsTypeObject.Mode == iGSearchAsTypeMode.None)
        return false;
      this.fSearchAsTypeObject.AdjustManager();
      return this.fSearchAsTypeObject.fManager.IsInputChar(charCode);
    }

    private void SearchAsTypeProcessKeyDown(KeyEventArgs e)
    {
      this.AdjustSearchAsTypeObject();
      if (this.fSearchAsTypeObject.Mode == iGSearchAsTypeMode.None)
        return;
      this.fSearchAsTypeObject.AdjustManager();
      this.fSearchAsTypeObject.fManager.OnKeyDown(e);
    }

    internal iGMatchRule DoRequestSearchAsTypeMatchRule(int colIndex, iGMatchRule matchRule)
    {
      iGRequestSearchAsTypeMatchRuleEventArgs e = new iGRequestSearchAsTypeMatchRuleEventArgs(colIndex - 1, matchRule);
      this.OnRequestSearchAsTypeMatchRule(e);
      return e.MatchRule;
    }

    internal bool DoSearchAsTypeCustomCompare(int rowIndex, int colIndex, string searchText)
    {
      iGSearchAsTypeCustomCompareEventArgs e = new iGSearchAsTypeCustomCompareEventArgs(rowIndex, colIndex - 1, searchText);
      this.OnSearchAsTypeCustomCompare(e);
      return e.Match;
    }

    internal void DoSearchAsTypeRowSetChanged()
    {
      this.OnSearchAsTypeRowSetChanged(EventArgs.Empty);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestSearchAsTypeMatchRule" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestSearchAsTypeMatchRuleEventArgs" /> that contains the event data.</param>
    protected virtual void OnRequestSearchAsTypeMatchRule(iGRequestSearchAsTypeMatchRuleEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestSearchAsTypeMatchRule == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestSearchAsTypeMatchRule((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.SearchAsTypeCustomCompare" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGSearchAsTypeCustomCompareEventArgs" /> that contains the event data.</param>
    protected virtual void OnSearchAsTypeCustomCompare(iGSearchAsTypeCustomCompareEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.SearchAsTypeCustomCompare == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.SearchAsTypeCustomCompare((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.SearchAsTypeRowSetChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnSearchAsTypeRowSetChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.SearchAsTypeRowSetChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.SearchAsTypeRowSetChanged((object) this, e);
    }

    /// <summary>Gets or sets a value indicating whether the grid should process the Tab key.</summary>
    /// <value>True if the Tab key causes cell navigation; otherwise, False. The default is True.</value>
    [DefaultValue(true)]
    [Category("Behavior")]
    [Description("Determines whether the grid should process the Tab key.")]
    public bool ProcessTab
    {
      get
      {
        return this.fProcessTab;
      }
      set
      {
        this.fProcessTab = value;
      }
    }

    /// <summary>Gets or sets a value indicating whether iGrid should process the ENTER key and start editing of the current cell.</summary>
    /// <value>True if iGrid processes the ENTER key; otherwise, False.</value>
    [DefaultValue(true)]
    [Category("Behavior")]
    [Description("Determines whether the grid should process the Enter key and start editing when it is pressed.")]
    public bool ProcessEnter
    {
      get
      {
        return this.fProcessEnter;
      }
      set
      {
        this.fProcessEnter = value;
      }
    }

    /// <summary>Gets the object which exposes all the properties related to the search-as-type functionality.</summary>
    /// <value>An instance of the <see cref="T:TenTec.Windows.iGridLib.iGSearchAsType" /> object.</value>
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("Determines the search as type behavior of the grid.")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Category("Behavior")]
    public iGSearchAsType SearchAsType
    {
      get
      {
        this.AdjustSearchAsTypeObject();
        return this.fSearchAsTypeObject;
      }
    }

    /// <summary>Occurs when searching as typing is being started.</summary>
    [Category("Search-as-Type")]
    [Description("Occurs before iGrid starts searching as typing and allows you to dynamically specify the match rule for a column.")]
    public event iGRequestSearchAsTypeMatchRuleEventHandler RequestSearchAsTypeMatchRule;

    /// <summary>Occurs when iGrid needs to determine whether a cell matches the search criteria while searching as typing.</summary>
    [Category("Search-as-Type")]
    [Description("Occurs when searching as typing by a custom criterion and allows you to specify whether a cell matches the search criterion.")]
    public event iGSearchAsTypeCustomCompareEventHandler SearchAsTypeCustomCompare;

    /// <summary>Occurs after the set of visible rows has changed when searching as typing.</summary>
    [Category("Search-as-Type")]
    [Description("Occurs when the set of visible rows has changed when searching as typing.")]
    public event EventHandler SearchAsTypeRowSetChanged;

    private bool ShouldSerializeSearchAsType()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.fSearchAsTypeObject);
    }

    private void ResetSearchAsType()
    {
      iGInternalInfrastructure.iGSerializeManager.Reset((object) this.fSearchAsTypeObject);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.MouseEventArgs" /> that contains the event data.</param>
    protected override void OnMouseMove(MouseEventArgs e)
    {
      this.ProcessMouseMove(e.X, e.Y, e.Button);
      base.OnMouseMove(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.MouseEventArgs" /> that contains the event data.</param>
    protected override void OnMouseDown(MouseEventArgs e)
    {
      this.ProcessMouseDown(e.X, e.Y, e.Button);
      base.OnMouseDown(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.MouseEventArgs" /> that contains the event data.</param>
    protected override void OnMouseUp(MouseEventArgs e)
    {
      this.ProcessMouseUp(e.X, e.Y, e.Button);
      base.OnMouseUp(e);
    }

    /// <summary>Raises the <see cref="E:System.Windows.Forms.Control.DoubleClick" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnDoubleClick(EventArgs e)
    {
      this.ProcessDoubleClick();
      base.OnDoubleClick(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnMouseLeave(EventArgs e)
    {
      if (!this.IsAutoScroll() || this.fMouseData.State != iGControlState.Normal)
        this.EmptyMouse();
      this.ResetChangeSelectionOnMouseUp();
      base.OnMouseLeave(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnLeave(EventArgs e)
    {
      this.EmptyMouse();
      this.CancelSearchAsType();
      this.ResetChangeSelectionOnMouseUp();
      base.OnLeave(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.Windows.Forms.MouseEventArgs" /> that contains the event data.</param>
    protected override void OnMouseWheel(MouseEventArgs e)
    {
      if (this.StopAnyMouseAction(false))
        this.ProcessMouseMove(e.X, e.Y, Control.MouseButtons);
      if (this.CanScrollHorz() | this.CanScrollVert() && this.CommitAnyEdit())
      {
        if (Control.ModifierKeys == Keys.Control)
        {
          if (this.CanScrollHorz())
            this.HScrollBarWheel(e.Delta);
          else if (this.CanScrollVert())
            this.VScrollBarWheel(e.Delta);
        }
        else if (this.CanScrollVert())
          this.VScrollBarWheel(e.Delta);
        else if (this.CanScrollHorz())
          this.HScrollBarWheel(e.Delta);
      }
      base.OnMouseWheel(e);
    }

    internal void ProcessMouseMove(int x, int y, MouseButtons button)
    {
      if (this.fDisposed)
        return;
      this.fLockFirstMouseDown = false;
      if (this.IsAutoScroll())
        this.AutoScrollMouseMove(x, y);
      else if (this.IsMouseCapturedByGrid())
      {
        if (this.fMouseData.Area == iGMouseArea.PressedSelection)
          this.ProcessSelectionMouseMovePressed(x, y);
        else if (this.fMouseData.Area == iGMouseArea.Header)
          this.ProcessHeaderMouseMovePressed(x, y, button);
        else if (this.fMouseData.Area == iGMouseArea.Footer)
          this.ProcessFooterMouseMovePressed(x, y, button);
        else if (this.fMouseData.Area == iGMouseArea.RowResize)
          this.ProcessRowResizeAreaMouseMovePressed(x, y);
        else if (this.fMouseData.Area == iGMouseArea.RowHdr)
        {
          this.ProcessRowHdrMouseMovePressed(x, y, button);
        }
        else
        {
          if (this.fMouseData.Area != iGMouseArea.Cells)
            return;
          this.ProcessCellsMouseMovePressed(x, y, button);
        }
      }
      else if (this.IsPointOverHeader(x, y))
        this.ProcessHeaderMouseMove(x, y, button);
      else if (this.IsPointOverFooter(x, y))
      {
        this.ProcessFooterMouseMove(x, y, button);
      }
      else
      {
        iGrid.RowToResizeInfo rowToResizeInfo;
        if (this.GetRowToResize(x, y, out rowToResizeInfo))
          this.ProcessRowResizeAreaMouseMove(x, y, button, rowToResizeInfo);
        else if (this.IsPointOverRowHeader(x, y))
          this.ProcessRowHdrMouseMove(x, y, button);
        else if (this.IsPointOverCellsArea(x, y))
          this.ProcessCellsMouseMove(x, y, button);
        else
          this.EmptyMouse();
      }
    }

    internal void ProcessMouseDown(int x, int y, MouseButtons button)
    {
      if (this.fDisposed)
        return;
      if (!this.fDoNotFocusOnMouseDown && !this.Focused)
        this.Focus();
      if (!this.IsSearchAsTypeFilteringActive())
        this.CancelSearchAsType();
      if (this.IsGridInTextEdit() || this.fMouseDownLocked || this.fLockFirstMouseDown)
      {
        this.fLockFirstMouseDown = false;
      }
      else
      {
        int num = this.IsAutoScroll() ? 1 : 0;
        if (this.StopAnyMouseAction(false))
          this.ProcessMouseMove(x, y, Control.MouseButtons);
        else if (this.fMouseData.IsEmpty)
          this.ProcessMouseMove(x, y, Control.MouseButtons);
        if (num != 0)
          return;
        if (button == MouseButtons.Middle)
          this.StartAutoScrollOnMouseDown(x, y, button);
        else if (!this.fMouseData.IsEmpty)
        {
          if (this.fMouseData.Area == iGMouseArea.Header)
            this.ProcessHeaderMouseDown(x, y, button);
          else if (this.fMouseData.Area == iGMouseArea.Footer)
            this.ProcessFooterMouseDown(x, y, button);
          else if (this.fMouseData.Area == iGMouseArea.RowResize)
            this.ProcessRowResizeAreaMouseDown(x, y, button);
          else if (this.fMouseData.Area == iGMouseArea.RowHdr)
          {
            this.ProcessRowHdrMouseDown(x, y, button);
          }
          else
          {
            if (this.fMouseData.Area != iGMouseArea.Cells)
              return;
            this.ProcessCellsMouseDown(x, y, button);
          }
        }
        else
          this.ProcessEmptyAreaMouseDown(x, y, button);
      }
    }

    internal void ProcessMouseUp(int x, int y, MouseButtons button)
    {
      if (this.fDisposed)
        return;
      this.fLockFirstMouseDown = false;
      if (this.IsAutoScroll())
      {
        if (button == MouseButtons.Middle)
          this.AutoScrollMiddleButtonUp(x, y);
        else
          this.StopAutoScroll();
      }
      else if (this.IsMousePressedSelection())
      {
        this.StopMousePressedSelection(true);
        this.ProcessMouseMove();
      }
      else if (!this.fMouseData.IsEmpty)
      {
        if (this.fMouseData.Area == iGMouseArea.Header)
          this.ProcessHeaderMouseUp(x, y, button);
        else if (this.fMouseData.Area == iGMouseArea.Footer)
          this.ProcessFooterMouseUp(x, y, button);
        else if (this.fMouseData.Area == iGMouseArea.RowResize)
          this.ProcessRowResizeAreaMouseUp(x, y, button);
        else if (this.fMouseData.Area == iGMouseArea.RowHdr)
          this.ProcessRowHdrMouseUp(x, y, button);
        else if (this.fMouseData.Area == iGMouseArea.Cells)
          this.ProcessCellsMouseUp(x, y, button);
      }
      else
        this.ProcessEmptyAreaMouseUp(x, y, button);
      this.ResetChangeSelectionOnMouseUp();
    }

    internal void ProcessDoubleClick()
    {
      if (this.fDisposed || this.IsGridInTextEdit() || (this.fMouseDownLocked || this.fMouseData.IsEmpty))
        return;
      if (this.fMouseData.Area == iGMouseArea.Header)
        this.ProcessHeaderDoubleClick();
      else if (this.fMouseData.Area == iGMouseArea.Footer)
        this.ProcessFooterDoubleClick();
      else if (this.fMouseData.Area == iGMouseArea.RowResize)
        this.ProcessRowResizeAreaDoubleClick();
      else if (this.fMouseData.Area == iGMouseArea.RowHdr)
      {
        this.ProcessRowHdrDoubleClick();
      }
      else
      {
        if (this.fMouseData.Area != iGMouseArea.Cells)
          return;
        this.ProcessCellsDoubleClick();
      }
    }

    private void ProcessMouseMove()
    {
      if (this.fDisposed || !this.IsHandleCreated)
        return;
      Point client = this.PointToClient(Control.MousePosition);
      if (client.X < 0 || client.Y < 0 || (client.X >= this.Width || client.Y >= this.Height) || (this.IsPointOverVScrollBar(client.X, client.Y) || this.IsPointOverHScrollBar(client.X, client.Y)))
        return;
      this.ProcessMouseMove(client.X, client.Y, Control.MouseButtons);
    }

    /// <summary>Determines whether iGrid captures the mouse input.</summary>
    /// <returns>A Boolean value that indicates whether iGrid captures the mouse input.</returns>
    public bool IsMouseCaptured()
    {
      if (!this.IsMouseCapturedByGrid() && !this.IsMouseCapturedByVScrollBar())
        return this.IsMouseCapturedByHScrollBar();
      return true;
    }

    internal bool IsMouseCapturedByGrid()
    {
      if (!this.fMouseData.IsEmpty)
        return this.fMouseData.State == iGControlState.Pressed;
      return false;
    }

    internal bool IsMouseCapturedByVScrollBar()
    {
      return this.fVScrollBar.fSomePressed;
    }

    internal bool IsMouseCapturedByHScrollBar()
    {
      return this.fHScrollBar.fSomePressed;
    }

    internal void EmptyMouse()
    {
      this.StopAnyMouseAction(false);
      if (this.fMouseData.IsEmpty)
        return;
      this.RaiseMouseLeaveEvent();
      this.fMouseData = iGMouseEventsData.Empty;
    }

    private void InvalidateMouseDataCellOnHotChangedIfRequired()
    {
      if (this.fMouseData.IsEmpty || !this.fRedraw)
        return;
      bool flag = false;
      switch (this.fMouseData.Area)
      {
        case iGMouseArea.Cells:
          flag = this.IsMouseOverCellWithControl();
          break;
        case iGMouseArea.Header:
          flag = !this.fMouseData.IsHeaderExtraCell && this.fHeaderHotTracking;
          break;
        case iGMouseArea.RowHdr:
          flag = this.fRowHeader.HotTracking;
          break;
        case iGMouseArea.RowResize:
          flag = this.fRowHeader.HotTracking;
          break;
      }
      if (!flag)
        return;
      this.Invalidate(this.fMouseData.Bounds);
    }

    private void InvalidateMouseDataCellOnPressChangedIfRequired()
    {
      if (this.fMouseData.IsEmpty || !this.fRedraw)
        return;
      bool flag = false;
      switch (this.fMouseData.Area)
      {
        case iGMouseArea.Cells:
          flag = this.IsMouseOverCellWithControl();
          break;
        case iGMouseArea.Header:
          flag = !this.fMouseData.IsHeaderExtraCell;
          break;
      }
      if (!flag)
        return;
      this.Invalidate(this.fMouseData.Bounds);
    }

    private bool IsMouseOverCellWithControl()
    {
      int colIndex = this.fColIdxFromOrd[this.fMouseData.ColOrder];
      iGCellStyle style = this.GetCellDataInternal(this.fMouseData.RowIndex, colIndex).Style;
      iGCellStyle cellStyle1 = this.GetRowDataInternal(this.fMouseData.RowIndex).CellStyle;
      iGCellStyle cellStyle2 = this.GetColDataInternal(colIndex).CellStyle;
      iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType((iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      iGCellDrawTypeFlags stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags((iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2);
      IiGDropDownControl cellDropDownControl = this.GetUniCellDropDownControl(iGGridSection.Cells, this.fMouseData.RowIndex, colIndex, (iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2, false);
      bool flag = this.fReadOnly || this.GetPropFromStyles_ReadOnly(style, cellStyle1, cellStyle2);
      if (fromStylesDrawType == iGCellDrawType.Check)
        return true;
      if (!this.ShouldDrawComboButton(fromStylesDrawType, stylesDrawTypeFlags, cellDropDownControl) && (stylesDrawTypeFlags & iGCellDrawTypeFlags.HasEllipsisButton) == iGCellDrawTypeFlags.None || flag)
        return false;
      if (this.fShowControlsInAllCells)
        return true;
      if (!this.fCurCell.IsEmpty && this.fCurCell.RowIndex == this.fMouseData.RowIndex)
        return this.fCurCell.ColIndex == colIndex;
      return false;
    }

    private void MouseOnScroll()
    {
      if (this.IsAutoScroll())
        return;
      if (this.IsMousePressedSelection())
        this.MousePressedSelectionOnScroll();
      else if (this.IsColMoving())
      {
        this.MouseColMoveOnScroll();
      }
      else
      {
        if (this.fMouseData.IsEmpty)
          return;
        if (this.fMouseData.Area == iGMouseArea.Header)
        {
          if (!this.fMouseData.IsHeaderExtraCell && !this.fMouseData.IsHeaderRowHdr)
            this.fMouseData.Bounds.Location = this.GetColHdrBounds(this.fMouseData.RowIndex, this.fMouseData.ColOrder).Location;
        }
        else if (this.fMouseData.Area == iGMouseArea.RowHdr)
          this.fMouseData.Bounds.Location = this.GetRowHdrBounds(this.fMouseData.RowIndex).Location;
        else if (this.fMouseData.Area == iGMouseArea.Cells)
          this.fMouseData.Bounds.Location = this.GetCellBounds(this.fMouseData.RowIndex, this.fMouseData.ColOrder, false).Location;
        if ((this.fMouseData.Area != iGMouseArea.Header ? 0 : (!this.fImmediateColResizing ? 1 : 0)) != 0)
          return;
        this.ProcessMouseMove();
      }
    }

    private void SetCursor(Cursor cursor)
    {
      if (this.fCursor == cursor)
        return;
      this.fCursor = cursor;
      Cursor.Current = this.Cursor;
    }

    private bool IsMouseDataAreaRelatedToCellRows()
    {
      if (!this.fMouseData.IsEmpty && this.fMouseData.Area != iGMouseArea.Header)
        return this.fMouseData.Area != iGMouseArea.Footer;
      return false;
    }

    private void AdjustMouseDataBeforeRowAdded(int rowBefore, int rowCount)
    {
      this.StopAnyMouseAction(false, false);
      if (this.IsMouseDataAreaRelatedToCellRows() && this.fMouseData.RowIndex >= rowBefore)
        this.fMouseData.RowIndex += rowCount;
      this.RefreshMouseDataWithTimer();
    }

    private void AdjustMouseDataBeforeRowRemoved(int rowIndex, int rowCount)
    {
      this.StopAnyMouseAction(false, false);
      if (this.IsMouseDataAreaRelatedToCellRows() && this.fMouseData.RowIndex >= rowIndex)
      {
        if (this.fMouseData.RowIndex < rowIndex + rowCount)
          this.EmptyMouse();
        else
          this.fMouseData.RowIndex -= rowCount;
      }
      this.RefreshMouseDataWithTimer();
    }

    private void RefreshMouseDataWithTimer()
    {
      if (this.fRefreshMouseDataTimer == null)
      {
        this.fRefreshMouseDataTimer = new Timer();
        this.fRefreshMouseDataTimer.Interval = 1;
        this.fRefreshMouseDataTimer.Tick += new EventHandler(this.fRefreshMouseDataTimer_Tick);
      }
      if (this.fRefreshMouseDataTimer.Enabled)
        return;
      this.fRefreshMouseDataTimer.Enabled = true;
    }

    private void fRefreshMouseDataTimer_Tick(object sender, EventArgs e)
    {
      if (!this.fRefreshMouseDataTimer.Enabled)
        return;
      this.fRefreshMouseDataTimer.Enabled = false;
      this.ProcessMouseMove();
    }

    private bool StopAnyMouseAction(bool apply)
    {
      return this.StopAnyMouseAction(apply, true);
    }

    private bool StopAnyMouseAction(bool apply, bool checkHeaderAction)
    {
      if (this.fMouseData.IsEmpty)
        return false;
      if (checkHeaderAction && this.fMouseData.Area == iGMouseArea.Header)
        return this.StopHeaderAction(apply);
      if (this.IsAutoScroll())
      {
        this.StopAutoScroll();
        return true;
      }
      if (this.fIsRowResizing)
        return this.StopResizingRow(apply);
      if (!this.IsMousePressedSelection())
        return false;
      this.StopMousePressedSelection(apply);
      return true;
    }

    private void HScrollBarWheel(int delta)
    {
      this.SetHScrollBarValue(this.fHScrollBar.Value - this.fHScrollBar.SmallChange * (delta * SystemInformation.MouseWheelScrollLines / 120), false);
    }

    private void VScrollBarWheel(int delta)
    {
      this.SetVScrollBarValue(this.fVScrollBar.Value - this.fVScrollBar.SmallChange * (delta * SystemInformation.MouseWheelScrollLines / 120), false);
    }

    private bool StartMousePressedSelection(int x, int y, int startRowIndex, int startColOrder, Rectangle startBounds, int endRowIndex, int endColOrder, Rectangle endBounds, MouseButtons button)
    {
      if (this.GetRowDataInternal(startRowIndex).Type != iGRowType.Normal)
        return false;
      if (this.fRowMode)
      {
        startColOrder = 0;
        startBounds.X = 0;
        startBounds.Width = this.Width;
        endColOrder = 0;
        endBounds.X = 0;
        endBounds.Width = this.Width;
      }
      if (!this.DoSelectionStartChange(startRowIndex, startColOrder, endRowIndex, endColOrder) || !this.RaiseMouseLeaveEventForPreviousMouseArea(iGMouseArea.PressedSelection))
        return false;
      iGSelectCellsData gselectCellsData = new iGSelectCellsData(endRowIndex, endColOrder, this.ClipFrozenArea(endBounds, endRowIndex, endColOrder), this.ClipFrozenArea(this.GetCellsAreaBoundsNoRowHdr(), startRowIndex, startColOrder), 0, 0, this.fHScrollBar.Value, this.fVScrollBar.Value);
      this.fMouseData = new iGMouseEventsData(startRowIndex, 1, startColOrder, 1, iGMouseArea.PressedSelection, iGControlState.Pressed, this.ClipFrozenArea(startBounds, startRowIndex, startColOrder), new Point(x, y), (object) gselectCellsData, false, iGElemControl.None, button);
      if (this.fMergedCellCountAll == 0)
        this.MousePressed_InvalidateSelection();
      else
        this.Invalidate();
      return true;
    }

    private bool IsMousePressedSelection()
    {
      if (!this.fMouseData.IsEmpty)
        return this.fMouseData.Area == iGMouseArea.PressedSelection;
      return false;
    }

    private void ProcessSelectionMouseMovePressed(int x, int y)
    {
      int rowIndex;
      int colOrder;
      Rectangle bounds;
      this.GetCellAtPointForMousePressedSelection(x, y, this.fMouseData.RowIndex, this.fMouseData.ColOrder, out rowIndex, out colOrder, out bounds);
      Rectangle newEndSelectionBounds = this.ClipFrozenArea(bounds, rowIndex, colOrder);
      this.fMouseData.MousePos = new Point(x, y);
      iGSelectCellsData tag = (iGSelectCellsData) this.fMouseData.Tag;
      if (!tag.CellsAreaBounds.Contains(this.fMouseData.MousePos))
      {
        if (this.GetAutoScrollMoveDirection(x, y, tag.CellsAreaBounds, this.GetAutoScrollDirections(), out tag.AutoScrollDX, out tag.AutoScrollDY) != iGAutoScrollMoveDirection.None && this.fAutoScrollTimer == null)
          this.StartPressedSelectionAutoScroll();
      }
      else
      {
        tag.AutoScrollDX = 0;
        tag.AutoScrollDY = 0;
      }
      if (tag.EndRowIndex != rowIndex || tag.EndColOrder != colOrder)
      {
        tag.EndRowIndex = rowIndex;
        tag.EndColOrder = colOrder;
        if (this.fMergedCellCountAll == 0)
          this.MousePressed_InvalidateSelectionDelta(tag.EndBounds, newEndSelectionBounds);
        else
          this.Invalidate();
        this.DoSelectionChanging();
        if (this.fMouseData.IsEmpty)
          return;
      }
      tag.EndBounds = newEndSelectionBounds;
    }

    private void StopMousePressedSelection(bool apply)
    {
      this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
      iGSelectCellsData tag = (iGSelectCellsData) this.fMouseData.Tag;
      apply &= this.DoSelectionEndChange();
      if (this.fMouseData.IsEmpty)
        return;
      if (apply)
      {
        if (this.SelectionMode == iGSelectionMode.MultiExtended && (Control.ModifierKeys & Keys.Control) != Keys.Control)
          this.DeselectAll(true, false, false);
        this.SelectRange(new iGCellNavigator(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder]), new iGCellNavigator(tag.EndRowIndex, this.fColIdxFromOrd[tag.EndColOrder]), true);
        this.DoSelectionChanged();
        if (this.fMouseData.IsEmpty)
          return;
      }
      if (this.fMergedCellCountAll == 0)
        this.MousePressed_InvalidateSelection();
      else
        this.Invalidate();
      this.fMouseData = iGMouseEventsData.Empty;
    }

    private void GetStartOrEndVisibleScrollableRow(int y, out int rowIndex, out int rowY, out int rowHeight)
    {
      int startRow;
      int startY;
      int startHeight;
      this.GetStartEndVisibleScrollableRow(out startRow, out startY, out startHeight, out rowIndex, out rowY, out rowHeight);
      if (y >= rowY)
        return;
      rowIndex = startRow;
      rowY = startY;
      rowHeight = startHeight;
    }

    private void GetStartOrEndVisibleScrollableCol(int x, out int colOrder, out int colX, out int colWidth)
    {
      int startColOrder;
      int startX;
      int startWidth;
      this.GetStartEndVisibleScrollableCol(out startColOrder, out startX, out startWidth, out colOrder, out colX, out colWidth);
      if ((x >= colX || this.RightToLeft != RightToLeft.No) && (x <= colX || this.RightToLeft != RightToLeft.Yes))
        return;
      colOrder = startColOrder;
      colX = startX;
      colWidth = startWidth;
    }

    private void GetFirstVisibleRowIncludingFrozen(int borderSize, int headerSize, out int rowIndex, out int rowY, out int rowHeight)
    {
      rowIndex = 0;
      rowY = 0;
      rowHeight = 0;
      for (int rowIndex1 = 0; rowIndex1 < this.fRowCount; ++rowIndex1)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
        {
          rowIndex = rowIndex1;
          rowHeight = rowDataInternal.Height;
          rowY = borderSize + headerSize;
          break;
        }
      }
    }

    private void GetFirstVisibleColIncludingFrozen(bool rightToLeft, int borderSize, int rowHdrWidth, out int colOrder, out int colX, out int colWidth)
    {
      colOrder = 0;
      colX = 0;
      colWidth = 0;
      for (int index = 0; index < this.fColCount; ++index)
      {
        int colIndex = this.fColIdxFromOrd[index];
        iGColData fColData = this.fColDatas[colIndex];
        if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
        {
          colOrder = index;
          colWidth = fColData.Width + this.GetGroupLevelsExtraWidth();
          if (rightToLeft)
          {
            colX = this.Width - borderSize - rowHdrWidth - colWidth;
            break;
          }
          colX = borderSize + rowHdrWidth;
          break;
        }
      }
    }

    private bool GetCellAtPointForMousePressedSelection(int x, int y, int startSelRowIndex, int startSelColOrder, out int rowIndex, out int colOrder, out Rectangle bounds)
    {
      bool flag1 = true;
      int borderSize = this.GetBorderSize();
      int headerAreaHeight = this.GetHeaderAreaHeight();
      bool flag2 = y < borderSize + headerAreaHeight + this.fFrozenRowsHeight;
      int rowY;
      int rowHeight;
      if (startSelRowIndex < this.fFrozenRowCount)
      {
        if (!this.GetRowFromY(y, out rowIndex, out rowY, out rowHeight))
        {
          if (flag2)
            this.GetFirstVisibleRowIncludingFrozen(borderSize, headerAreaHeight, out rowIndex, out rowY, out rowHeight);
          else
            this.GetStartOrEndVisibleScrollableRow(y, out rowIndex, out rowY, out rowHeight);
          flag1 = false;
        }
      }
      else if (((this.fFrozenRowCount <= 0 ? 0 : (startSelRowIndex >= this.fFrozenRowCount ? 1 : 0)) & (flag2 ? 1 : 0)) != 0)
      {
        if (this.fVScrollBar.Value == 0)
        {
          if (!this.GetRowFromY(y, out rowIndex, out rowY, out rowHeight))
          {
            this.GetFirstVisibleRowIncludingFrozen(borderSize, headerAreaHeight, out rowIndex, out rowY, out rowHeight);
            flag1 = false;
          }
        }
        else
        {
          this.GetStartOrEndVisibleScrollableRow(y, out rowIndex, out rowY, out rowHeight);
          flag1 = false;
        }
      }
      else if (!this.GetRowFromY(y, out rowIndex, out rowY, out rowHeight))
      {
        this.GetStartOrEndVisibleScrollableRow(y, out rowIndex, out rowY, out rowHeight);
        flag1 = false;
      }
      int rowHdrWidth = this.fRowHeader.EffectiveWidth();
      int colX;
      int colWidth;
      if (this.fRowMode)
      {
        colOrder = 0;
        colX = 0;
        colWidth = this.Width;
      }
      else
      {
        bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
        bool flag3 = !rightToLeft && x < borderSize + rowHdrWidth + this.fFrozenColsWidth || rightToLeft && x >= this.Width - borderSize - rowHdrWidth - this.fFrozenColsWidth;
        if (startSelColOrder < this.fFrozenColCount)
        {
          if (!this.GetColFromXInternal(x, 0, true, out colOrder, out colX, out colWidth))
          {
            if (flag3)
              this.GetFirstVisibleColIncludingFrozen(rightToLeft, borderSize, rowHdrWidth, out colOrder, out colX, out colWidth);
            else
              this.GetStartOrEndVisibleScrollableCol(x, out colOrder, out colX, out colWidth);
            flag1 = false;
          }
        }
        else if (this.fFrozenColCount > 1 & flag3)
        {
          if (this.fHScrollBar.Value == 0)
          {
            if (!this.GetColFromXInternal(x, 0, true, out colOrder, out colX, out colWidth))
            {
              this.GetFirstVisibleColIncludingFrozen(rightToLeft, borderSize, rowHdrWidth, out colOrder, out colX, out colWidth);
              flag1 = false;
            }
          }
          else
          {
            this.GetStartOrEndVisibleScrollableCol(x, out colOrder, out colX, out colWidth);
            flag1 = false;
          }
        }
        else if (!this.GetColFromXInternal(x, 0, true, out colOrder, out colX, out colWidth))
        {
          this.GetStartOrEndVisibleScrollableCol(x, out colOrder, out colX, out colWidth);
          flag1 = false;
        }
      }
      bounds = new Rectangle(colX, rowY, colWidth, rowHeight);
      return flag1;
    }

    private Rectangle MousePressedSelection_AdjustBoundsForRowTextCell(Rectangle bounds)
    {
      iGColDisposition colDisposition = this.GetColDisposition(this.fMouseData.ColOrder);
      Rectangle rectangle = bounds;
      if (colDisposition == iGColDisposition.RowText)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(this.fMouseData.RowIndex);
        rectangle.Height = rowDataInternal.Height;
        rectangle.Y -= rowDataInternal.NormalCellHeight;
      }
      else if (colDisposition == iGColDisposition.AboveRowText)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(this.fMouseData.RowIndex);
        rectangle.Height = rowDataInternal.Height;
      }
      return rectangle;
    }

    private Rectangle MousePressed_GetStartBounds()
    {
      if (this.fRowMode)
        return this.fMouseData.Bounds;
      Rectangle bounds = this.fMouseData.Bounds;
      iGRowData rowDataInternal = this.GetRowDataInternal(this.fMouseData.RowIndex);
      bool flag = !this.IsTreeColSpecified() ? this.IsFirstVisibleCol(this.fMouseData.ColOrder) : this.IsTreeCol(this.GetColIndex(this.fMouseData.ColOrder));
      if (((rowDataInternal.Level <= 0 || this.fMouseData.RowIndex < this.fFrozenRowCount ? 0 : (this.fFrozenRowCount > 0 ? 1 : 0)) & (flag ? 1 : 0)) != 0)
      {
        if (this.RightToLeft == RightToLeft.Yes)
        {
          bounds.Width += this.fLevelIndent * rowDataInternal.Level;
        }
        else
        {
          bounds.X -= this.GetGroupLevelsExtraWidth();
          bounds.Width += this.fLevelIndent * rowDataInternal.Level;
        }
      }
      return bounds;
    }

    private void MousePressed_InvalidateSelection()
    {
      this.Invalidate(Rectangle.Union(this.MousePressed_GetStartBounds(), ((iGSelectCellsData) this.fMouseData.Tag).EndBounds));
    }

    private void MousePressed_InvalidateSelectionDelta(Rectangle oldEndSelectionBounds, Rectangle newEndSelectionBounds)
    {
      Rectangle startBounds = this.MousePressed_GetStartBounds();
      Rectangle b1 = oldEndSelectionBounds;
      Rectangle rect1 = Rectangle.Union(startBounds, b1);
      Rectangle b2 = newEndSelectionBounds;
      Rectangle rect2 = Rectangle.Union(startBounds, b2);
      Rectangle rc = this.RectanglesDifference(rect1, rect2);
      if (rc.IsEmpty)
        return;
      this.Invalidate(rc);
    }

    private Rectangle ClipFrozenArea(Rectangle cellBounds, int rowIndex, int colOrder)
    {
      return this.ClipFrozenArea(cellBounds, rowIndex >= this.fFrozenRowCount, colOrder >= this.fFrozenColCount && !this.fRowMode);
    }

    private bool CoordinatesDifference(int nearCoord1, int nearCoord2, int farCoord1, int farCoord2, out int coord, out int size)
    {
      int num1 = nearCoord1 - nearCoord2;
      if (num1 != 0)
      {
        if (num1 > 0)
        {
          coord = nearCoord2;
          size = num1;
        }
        else
        {
          coord = nearCoord1;
          size = -num1;
        }
        int num2 = farCoord1 - farCoord2;
        if (num2 != 0)
          size = num2 <= 0 ? farCoord2 - coord : farCoord1 - coord;
      }
      else
      {
        int num2 = farCoord1 - farCoord2;
        if (num2 != 0)
        {
          if (num2 > 0)
          {
            coord = farCoord2;
            size = num2;
          }
          else
          {
            coord = farCoord1;
            size = -num2;
          }
        }
        else
        {
          coord = 0;
          size = 0;
          return false;
        }
      }
      return true;
    }

    private Rectangle RectanglesDifference(Rectangle rect1, Rectangle rect2)
    {
      int coord1;
      int size1;
      bool flag;
      if (!this.CoordinatesDifference(rect1.X, rect2.X, rect1.Right, rect2.Right, out coord1, out size1))
      {
        coord1 = rect1.X;
        size1 = rect1.Width;
        flag = false;
      }
      else
        flag = true;
      int coord2;
      int size2;
      if (!this.CoordinatesDifference(rect1.Y, rect2.Y, rect1.Bottom, rect2.Bottom, out coord2, out size2))
      {
        if (!flag)
          return Rectangle.Empty;
        coord2 = rect1.Y;
        size2 = rect1.Height;
      }
      else if (flag)
        return Rectangle.Union(rect1, rect2);
      return new Rectangle(coord1, coord2, size1, size2);
    }

    private void StartPressedSelectionAutoScroll()
    {
      this.StartAutoScrollTimer(new EventHandler(this.AutoScrollTimerSelection_Tick));
    }

    private void AutoScrollTimerSelection_Tick(object sender, EventArgs e)
    {
      if (!this.IsMousePressedSelection())
      {
        this.StopAutoScrollTimer();
      }
      else
      {
        iGSelectCellsData tag = (iGSelectCellsData) this.fMouseData.Tag;
        this.AutoScrollScrollBars(tag.AutoScrollDX, tag.AutoScrollDY);
      }
    }

    private void MousePressedSelectionOnScroll()
    {
      iGSelectCellsData tag = (iGSelectCellsData) this.fMouseData.Tag;
      Rectangle bounds = this.fMouseData.Bounds;
      if (this.RightToLeft == RightToLeft.Yes)
        bounds.Offset(this.fMouseData.ColOrder < this.fFrozenColCount || this.fRowMode ? 0 : this.fHScrollBar.Value - tag.OldHScrollValue, this.fMouseData.RowIndex >= this.fFrozenRowCount ? tag.OldVScrollValue - this.fVScrollBar.Value : 0);
      else
        bounds.Offset(this.fMouseData.ColOrder < this.fFrozenColCount || this.fRowMode ? 0 : tag.OldHScrollValue - this.fHScrollBar.Value, this.fMouseData.RowIndex >= this.fFrozenRowCount ? tag.OldVScrollValue - this.fVScrollBar.Value : 0);
      this.fMouseData.Bounds = bounds;
      tag.OldHScrollValue = this.fHScrollBar.Value;
      tag.OldVScrollValue = this.fVScrollBar.Value;
      this.ProcessSelectionMouseMovePressed(this.fMouseData.MousePos.X, this.fMouseData.MousePos.Y);
    }

    private bool DoSelectionStartChange(int startRowIndex, int startColOrder, int endRowIndex, int endColOrder)
    {
      iGMouseEventsData fMouseData = this.fMouseData;
      iGSelectionStartEndChangeEventArgs e = new iGSelectionStartEndChangeEventArgs(startRowIndex, this.fColIdxFromOrd[startColOrder] - 1, endRowIndex, this.fColIdxFromOrd[endColOrder] - 1);
      this.OnSelectionStartChange(e);
      return e.DoDefault;
    }

    private void DoSelectionChanging()
    {
      iGSelectCellsData tag = this.fMouseData.Tag as iGSelectCellsData;
      this.OnSelectionChanging(new iGSelectionChangingEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, tag.EndRowIndex, this.fColIdxFromOrd[tag.EndColOrder] - 1));
    }

    private bool DoSelectionEndChange()
    {
      iGSelectCellsData tag = this.fMouseData.Tag as iGSelectCellsData;
      iGSelectionStartEndChangeEventArgs e = new iGSelectionStartEndChangeEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, tag.EndRowIndex, this.fColIdxFromOrd[tag.EndColOrder] - 1);
      this.OnSelectionEndChange(e);
      return e.DoDefault;
    }

    private void DoCellMouseLeaveWrapper()
    {
      this.DoCellMouseLeave();
      this.GridToolTipClear();
    }

    private void DoCellMouseLeave()
    {
      this.OnCellMouseLeave(new iGCellMouseEnterLeaveEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, this.fMouseData.Bounds));
      this.InvalidateMouseDataCellOnHotChangedIfRequired();
    }

    private void DoCellMouseEnter()
    {
      this.OnCellMouseEnter(new iGCellMouseEnterLeaveEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, this.fMouseData.Bounds));
      this.InvalidateMouseDataCellOnHotChangedIfRequired();
    }

    private void DoCellMouseMove(MouseButtons button)
    {
      this.OnCellMouseMove(new iGCellMouseMoveEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, button, this.fMouseData.Bounds, this.fMouseData.MousePos, this.fMouseData.ElemControl));
    }

    private bool DoCellMouseDown(MouseButtons buttons, Keys modifierKeys)
    {
      iGCellMouseDownEventArgs e = new iGCellMouseDownEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, buttons, this.fMouseData.Bounds, this.fMouseData.MousePos, modifierKeys, this.fMouseData.ElemControl);
      this.OnCellMouseDown(e);
      return e.DoDefault;
    }

    private bool DoCellMouseUp(MouseButtons button, Keys modifierKeys)
    {
      iGCellMouseUpEventArgs e = new iGCellMouseUpEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, button, this.fMouseData.Bounds, this.fMouseData.MousePos, modifierKeys, this.fMouseData.ElemControl);
      this.OnCellMouseUp(e);
      return e.DoDefault;
    }

    private bool DoCellClick(Keys modifierKeys, iGElemControl elemControl)
    {
      iGCellClickEventArgs e = new iGCellClickEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, this.fMouseData.Bounds, modifierKeys, elemControl);
      this.OnCellClick(e);
      return e.DoDefault;
    }

    private bool DoCellDoubleClick()
    {
      iGCellDoubleClickEventArgs e = new iGCellDoubleClickEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, this.fMouseData.Bounds, this.fMouseData.ElemControl);
      this.OnCellDoubleClick(e);
      return e.DoDefault;
    }

    private void DoCellEllipsisButtonClick()
    {
      this.OnCellEllipsisButtonClick(new iGEllipsisButtonClickEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1));
    }

    private void DoStartDragCell(Keys modifierKeys)
    {
      this.OnStartDragCell(new iGStartDragCellEventArgs(this.fMouseData.RowIndex, this.fColIdxFromOrd[this.fMouseData.ColOrder] - 1, this.fMouseData.Button, this.fMouseData.MousePos, modifierKeys));
    }

    /// <summary>Determines whether the specified point is over the area used to display cells.</summary>
    /// <param name="x">The x-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="y">The y-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <returns>A Boolean value that indicates whether the specified point is over the cells area.</returns>
    public bool IsPointOverCellsArea(int x, int y)
    {
      return this.GetCellsAreaBoundsNoRowHdr().Contains(x, y);
    }

    private void ProcessCellsMouseMove(int x, int y, MouseButtons button)
    {
      if (!this.RaiseMouseLeaveEventForPreviousMouseArea(iGMouseArea.Cells))
        return;
      int rowIndex;
      int colOrder;
      Rectangle bounds;
      if (this.GetCellFromPointInternal(x, y, false, out rowIndex, out colOrder, out bounds))
      {
        int colIndex = this.GetColIndex(colOrder);
        int x1 = bounds.X;
        int y1 = bounds.Y;
        int width = bounds.Width;
        int height = bounds.Height;
        bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
        this.ExcludeGridLinesFromCellBounds(rowIndex, colOrder, ref x1, ref y1, ref width, ref height, rightToLeft);
        iGElemControl controlUnderMouse = this.GetElemControlUnderMouse(rowIndex, colIndex, x, y, x1, y1, width, height, rightToLeft, false);
        iGMouseEventsData gmouseEventsData = new iGMouseEventsData(rowIndex, 1, colOrder, 1, iGMouseArea.Cells, this.IsAnyDropDownActive() ? iGControlState.Normal : iGControlState.Hot, bounds, new Point(x, y), (object) null, false, controlUnderMouse, button);
        if (this.fMouseData.IsEmpty || this.fMouseData.Area != iGMouseArea.Cells || (this.fMouseData.RowIndex != rowIndex || this.fMouseData.ColOrder != colOrder))
        {
          if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Cells)
          {
            this.DoCellMouseLeaveWrapper();
            if (this.fMouseData.IsEmpty)
              return;
          }
          this.fMouseData = gmouseEventsData;
          this.DoCellMouseEnter();
          if (this.fMouseData.IsEmpty)
            return;
          this.GridToolTipInitFromMouseData();
          if (controlUnderMouse != iGElemControl.None)
          {
            this.GridToolTipAdjustForElemControl(rowIndex, colIndex, false, controlUnderMouse);
            this.Invalidate(bounds);
          }
        }
        else
        {
          if (controlUnderMouse != this.fMouseData.ElemControl)
          {
            if (controlUnderMouse != iGElemControl.None)
              this.GridToolTipAdjustForElemControl(rowIndex, colIndex, false, controlUnderMouse);
            else if (this.fToolTipTextForCellControlDiffers)
              this.GridToolTipSetTo(this.fToolTipTextForCell);
            this.Invalidate(bounds);
          }
          this.fMouseData = gmouseEventsData;
        }
        this.DoCellMouseMove(button);
        int num = this.fMouseData.IsEmpty ? 1 : 0;
      }
      else
      {
        if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Cells)
        {
          this.DoCellMouseLeaveWrapper();
          if (this.fMouseData.IsEmpty)
            return;
        }
        this.fMouseData = iGMouseEventsData.Empty;
      }
    }

    private void ProcessCellsMouseDown(int x, int y, MouseButtons button)
    {
      this.fMouseData.MousePos = new Point(x, y);
      this.fMouseData.MouseDownMousePos = this.fMouseData.MousePos;
      this.fMouseData.MouseDownOnTheCurCell = this.fCurCell.RowIndex == this.fMouseData.RowIndex && this.fCurCell.ColIndex == this.fColIdxFromOrd[this.fMouseData.ColOrder];
      this.fMouseData.State = iGControlState.Pressed;
      this.fMouseData.Button = button;
      this.fStartDragCellWasRaised = false;
      this.InvalidateMouseDataCellOnPressChangedIfRequired();
      Keys modifierKeys = Control.ModifierKeys;
      if (!this.DoCellMouseDown(button, modifierKeys) || this.fMouseData.IsEmpty || button != MouseButtons.Left)
        return;
      iGRowData rowDataInternal = this.GetRowDataInternal(this.fMouseData.RowIndex);
      bool flag = false;
      if (rowDataInternal.TreeButton == iGTreeButtonState.Visible)
        flag = this.IsPointOverTreeButton(x, y, this.fMouseData.RowIndex, this.fMouseData.ColOrder, rowDataInternal.Type, rowDataInternal.Level, this.fMouseData.Bounds.X, this.fMouseData.Bounds.Y, this.fMouseData.Bounds.Width, this.fMouseData.Bounds.Height);
      if (flag)
      {
        int rowIndex = this.fMouseData.RowIndex;
        if (!this.DoBeforeRowStateChanged(this.fMouseData.RowIndex, rowDataInternal.Expanded) || rowIndex >= this.fRowCount)
          return;
        this.ExpandCollapseRow(rowIndex, rowDataInternal, !rowDataInternal.Expanded);
        this.DoAfterRowStateChanged(rowIndex, !rowDataInternal.Expanded);
      }
      else
      {
        if (!this.ChangeSelectionAndCurCellOnMouseDownInCell(modifierKeys) || this.fMouseData.IsEmpty || this.fMouseData.ElemControl == iGElemControl.EllipsisButton)
          return;
        this.StartEditCellOnMouseDown(Control.ModifierKeys, rowDataInternal.Type == iGRowType.Normal);
        int num = this.fMouseData.IsEmpty ? 1 : 0;
      }
    }

    private void ProcessCellsMouseUp(int x, int y, MouseButtons button)
    {
      if (button == MouseButtons.Left && this.StopAnyMouseAction(true))
        return;
      Keys modifierKeys = Control.ModifierKeys;
      int colIndex = this.GetColIndex(this.fMouseData.ColOrder);
      bool flag1 = this.DoCellMouseUp(button, modifierKeys);
      if (this.fMouseData.IsEmpty)
        return;
      bool flag2 = true;
      if (!this.GetItemSelectedInternal(this.fMouseData.RowIndex, colIndex))
        flag2 = false;
      else if (this.fRowMode)
      {
        if (this.fSelectedRows.Count != 1)
          flag2 = false;
      }
      else if (this.fSelectedCells.Count != 1)
        flag2 = false;
      if (flag1)
        this.ChangeSelectionOnCellMouseUp();
      if (this.fMouseData.IsEmpty)
        return;
      if (this.fMouseData.State == iGControlState.Pressed && button == MouseButtons.Left && (this.fMouseData.Button == MouseButtons.Left && this.fMouseData.Bounds.Contains(x, y)))
      {
        iGElemControl elemControl = this.GetElemControlUnderMouse(this.fMouseData.RowIndex, this.GetColIndex(this.fMouseData.ColOrder), x, y, this.fMouseData.Bounds.X, this.fMouseData.Bounds.Y, this.fMouseData.Bounds.Width, this.fMouseData.Bounds.Height, this.RightToLeft == RightToLeft.Yes, false);
        if (elemControl != this.fMouseData.ElemControl)
          elemControl = iGElemControl.None;
        if (this.DoCellClick(modifierKeys, elemControl))
        {
          if (this.fMouseData.IsEmpty)
            return;
          iGCellStyle style = this.GetCellDataInternal(this.fMouseData.RowIndex, colIndex).Style;
          iGCellStyle cellStyle1 = this.GetRowDataInternal(this.fMouseData.RowIndex).CellStyle;
          iGCellStyle cellStyle2 = this.GetColDataInternal(colIndex).CellStyle;
          bool stylesSingleClickEdit = this.GetPropFromStyles_SingleClickEdit(style, cellStyle1, cellStyle2);
          bool flag3 = this.IsCellReadOnlyOrDisabled(style, cellStyle1, cellStyle2);
          if (elemControl == iGElemControl.EllipsisButton)
          {
            if (!flag3 && (stylesSingleClickEdit || this.fMouseData.MouseDownOnTheCurCell || this.fShowControlsInAllCells))
              this.DoCellEllipsisButtonClick();
          }
          else
          {
            bool flag4 = (((this.fMouseData.ElemControl == iGElemControl.None || this.fMouseData.ElemControl == iGElemControl.CheckBox) & this.GetPropFromStyles_DrawType((iGStyleBase) style, (iGStyleBase) cellStyle1, (iGStyleBase) cellStyle2) == iGCellDrawType.Check & !flag3 ? 1 : 0) & (stylesSingleClickEdit ? 1 : (this.fMouseData.MouseDownOnTheCurCell ? 1 : 0))) != 0;
            if (this.fCurCell.IsEmpty || this.fCurCell.RowIndex != this.fMouseData.RowIndex || this.fCurCell.ColIndex != colIndex)
              flag4 = false;
            if (this.fSelectionMode == iGSelectionMode.MultiSimple)
              flag4 = false;
            if (this.fSelectionMode == iGSelectionMode.MultiExtended)
            {
              if (modifierKeys != Keys.None)
                flag4 = false;
              if (!flag2)
                flag4 = false;
            }
            if (flag4)
              this.RequestEditCellInternal(this.fMouseData.RowIndex, colIndex, char.MinValue, this.fMouseData.ElemControl == iGElemControl.ComboButton, this.GetRowDataInternal(this.fMouseData.RowIndex).Type == iGRowType.Normal);
          }
        }
        if (this.fMouseData.IsEmpty)
          return;
      }
      this.fMouseData.State = iGControlState.Normal;
      this.fMouseData.Button = MouseButtons.None;
      this.InvalidateMouseDataCellOnPressChangedIfRequired();
      this.ProcessMouseMove();
    }

    private void ProcessCellsMouseMovePressed(int x, int y, MouseButtons button)
    {
      int rowIndex;
      int colOrder;
      Rectangle bounds;
      if (((this.fMouseData.Button != MouseButtons.Left ? 0 : (this.fPressedMouseMoveMode == iGPressedMouseMoveMode.Selection ? 1 : 0)) & (this.fSelectionMode == iGSelectionMode.MultiExtended ? (true ? 1 : 0) : (this.fSelectionMode == iGSelectionMode.MultiSimple ? 1 : 0)) & (!this.fRowMode ? (this.CanSelectCell(this.fMouseData.RowIndex, this.fMouseData.ColOrder, false) ? 1 : 0) : (this.CanSelectRow(this.fMouseData.RowIndex, false) ? 1 : 0))) != 0 && (!this.GetCellAtPointForMousePressedSelection(x, y, this.fMouseData.RowIndex, this.fMouseData.ColOrder, out rowIndex, out colOrder, out bounds) || rowIndex != this.fMouseData.RowIndex || !this.fRowMode && colOrder != this.fMouseData.ColOrder) && this.StartMousePressedSelection(x, y, this.fMouseData.RowIndex, this.fMouseData.ColOrder, this.MousePressedSelection_AdjustBoundsForRowTextCell(this.fMouseData.Bounds), rowIndex, colOrder, bounds, button) || this.fMouseData.IsEmpty)
        return;
      if (!this.fStartDragCellWasRaised && (Math.Abs(this.fMouseData.MouseDownMousePos.X - x) >= this.fStartDragCellDelta || Math.Abs(this.fMouseData.MouseDownMousePos.Y - y) >= this.fStartDragCellDelta))
      {
        this.fStartDragCellWasRaised = true;
        this.DoStartDragCell(Control.ModifierKeys);
      }
      if (this.fMouseData.IsEmpty)
        return;
      this.fMouseData.MousePos = new Point(x, y);
      this.DoCellMouseMove(button);
    }

    private void ProcessCellsDoubleClick()
    {
      if (!this.DoCellDoubleClick() || this.fMouseData.IsEmpty)
        return;
      iGRowData rowDataInternal = this.GetRowDataInternal(this.fMouseData.RowIndex);
      if (rowDataInternal.TreeButton != iGTreeButtonState.Visible || this.IsPointOverTreeButton(this.fMouseData.MousePos.X, this.fMouseData.MousePos.Y, this.fMouseData.RowIndex, this.fMouseData.ColOrder, rowDataInternal.Type, rowDataInternal.Level, this.fMouseData.Bounds.X, this.fMouseData.Bounds.Y, this.fMouseData.Bounds.Width, this.fMouseData.Bounds.Height) || (!this.DoBeforeRowStateChanged(this.fMouseData.RowIndex, rowDataInternal.Expanded) || this.fMouseData.IsEmpty))
        return;
      int rowIndex = this.fMouseData.RowIndex;
      this.ExpandCollapseRow(rowIndex, rowDataInternal, !rowDataInternal.Expanded);
      this.DoAfterRowStateChanged(rowIndex, !rowDataInternal.Expanded);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.SelectionStartChange" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGSelectionStartEndChangeEventArgs" /> that contains the event data.</param>
    protected virtual void OnSelectionStartChange(iGSelectionStartEndChangeEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.SelectionStartChange == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.SelectionStartChange((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.SelectionChanging" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGSelectionChangingEventArgs" /> that contains the event data.</param>
    protected virtual void OnSelectionChanging(iGSelectionChangingEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.SelectionChanging == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.SelectionChanging((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.SelectionEndChange" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGSelectionStartEndChangeEventArgs" /> that contains the event data.</param>
    protected virtual void OnSelectionEndChange(iGSelectionStartEndChangeEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.SelectionEndChange == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.SelectionEndChange((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellDoubleClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellDoubleClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellDoubleClick(iGCellDoubleClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellDoubleClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellDoubleClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellMouseDown" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellMouseDownEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellMouseDown(iGCellMouseDownEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellMouseDown == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellMouseDown((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellMouseUp" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellMouseUpEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellMouseUp(iGCellMouseUpEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellMouseUp == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellMouseUp((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellMouseEnter" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellMouseEnter(iGCellMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellMouseEnter == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellMouseEnter((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellMouseLeave" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellMouseLeave(iGCellMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellMouseLeave == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellMouseLeave((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellMouseMove" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellMouseMoveEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellMouseMove(iGCellMouseMoveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellMouseMove == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellMouseMove((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellClick(iGCellClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellEllipsisButtonClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGEllipsisButtonClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellEllipsisButtonClick(iGEllipsisButtonClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellEllipsisButtonClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellEllipsisButtonClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.StartDragCell" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGStartDragCellEventArgs" /> that contains the event data.</param>
    protected virtual void OnStartDragCell(iGStartDragCellEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.StartDragCell == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.StartDragCell((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrMouseEnter" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrMouseEnter(iGColHdrMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrMouseEnter == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrMouseEnter((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrMouseLeave" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrMouseLeave(iGColHdrMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrMouseLeave == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrMouseLeave((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrMouseMove" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrMouseMoveEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrMouseMove(iGColHdrMouseMoveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrMouseMove == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrMouseMove((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrClick(iGColHdrClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrDoubleClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrDoubleClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrDoubleClick(iGColHdrDoubleClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrDoubleClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrDoubleClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColDividerDoubleClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColDividerDoubleClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnColDividerDoubleClick(iGColDividerDoubleClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColDividerDoubleClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColDividerDoubleClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrMouseDown" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrMouseDownEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrMouseDown(iGColHdrMouseDownEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrMouseDown == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrMouseDown((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrMouseUp" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrMouseUpEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrMouseUp(iGColHdrMouseUpEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrMouseUp == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrMouseUp((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColWidthStartChange" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColWidthEventArgs" /> that contains the event data.</param>
    protected virtual void OnColWidthStartChange(iGColWidthEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColWidthStartChange == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColWidthStartChange((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColWidthChanging" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColWidthEventArgs" /> that contains the event data.</param>
    protected virtual void OnColWidthChanging(iGColWidthEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColWidthChanging == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColWidthChanging((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColWidthEndChange" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColWidthEventArgs" /> that contains the event data.</param>
    protected virtual void OnColWidthEndChange(iGColWidthEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColWidthEndChange == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColWidthEndChange((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrEndDrag" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrEndDragEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrEndDrag(iGColHdrEndDragEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrEndDrag == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrEndDrag((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrStartDrag" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrStartDragEventArgs" /> that contains the event data.</param>
    protected void OnColHdrStartDrag(iGColHdrStartDragEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrStartDrag == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrStartDrag((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColHdrDragging" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColHdrEndDragEventArgs" /> that contains the event data.</param>
    protected virtual void OnColHdrDragging(iGColHdrEndDragEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColHdrDragging == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColHdrDragging((object) this, e);
    }

    private void DoColHdrMouseLeaveWrapper()
    {
      if (!this.fColHdrDropDownActive)
        this.fColHdrDrawnHot = iGColHdrNavigator.Empty;
      this.DoColHdrMouseLeave();
      this.GridToolTipClear();
    }

    private void DoColHdrMouseLeave()
    {
      this.OnColHdrMouseLeave(new iGColHdrMouseEnterLeaveEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfColHdrFromMouseData() - 1, this.GetColHdrKindFromMouseData(), this.fMouseData.Bounds));
      this.SetCursor((Cursor) null);
      this.InvalidateMouseDataCellOnHotChangedIfRequired();
    }

    private void DoColHdrMouseEnter()
    {
      this.OnColHdrMouseEnter(new iGColHdrMouseEnterLeaveEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfColHdrFromMouseData() - 1, this.GetColHdrKindFromMouseData(), this.fMouseData.Bounds));
      this.InvalidateMouseDataCellOnHotChangedIfRequired();
    }

    private void DoColHdrMouseMove(MouseButtons button)
    {
      this.OnColHdrMouseMove(new iGColHdrMouseMoveEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfColHdrFromMouseData() - 1, this.GetColHdrKindFromMouseData(), button, this.fMouseData.Bounds, this.fMouseData.MousePos, Control.ModifierKeys, this.fMouseData.ElemControl));
    }

    private void DoColWidthStartChange(int width)
    {
      this.OnColWidthStartChange(new iGColWidthEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfMergedColHdrs(this.fMouseData.RowIndex, this.fMouseData.ColOrder) - 1, width));
    }

    private void DoColWidthEndChange(int width)
    {
      this.OnColWidthEndChange(new iGColWidthEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfMergedColHdrs(this.fMouseData.RowIndex, this.fMouseData.ColOrder) - 1, width));
    }

    private void DoColWidthChanging(int newWidth)
    {
      this.OnColWidthChanging(new iGColWidthEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfMergedColHdrs(this.fMouseData.RowIndex, this.fMouseData.ColOrder) - 1, newWidth));
    }

    private bool DoColHdrMouseDown(MouseButtons button)
    {
      iGColHdrMouseDownEventArgs e = new iGColHdrMouseDownEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfColHdrFromMouseData() - 1, this.GetColHdrKindFromMouseData(), button, this.fMouseData.Bounds, this.fMouseData.MousePos, Control.ModifierKeys, this.fMouseData.ElemControl);
      this.OnColHdrMouseDown(e);
      return e.DoDefault;
    }

    private void DoColHdrMouseUp(Keys modifierKeys, MouseButtons button)
    {
      this.OnColHdrMouseUp(new iGColHdrMouseUpEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfColHdrFromMouseData() - 1, this.GetColHdrKindFromMouseData(), button, this.fMouseData.Bounds, this.fMouseData.MousePos, modifierKeys, this.fMouseData.ElemControl));
    }

    private bool DoColHdrDragging(int newOrder, bool toGroupBox)
    {
      iGColHdrEndDragEventArgs e = new iGColHdrEndDragEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfMergedColHdrs(this.fMouseData.RowIndex, this.fMouseData.ColOrder) - 1, toGroupBox ? newOrder : newOrder - 1, toGroupBox);
      this.OnColHdrDragging(e);
      return e.DoDefault;
    }

    private bool DoColHdrStartDrag()
    {
      iGColHdrStartDragEventArgs e = new iGColHdrStartDragEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfMergedColHdrs(this.fMouseData.RowIndex, this.fMouseData.ColOrder) - 1);
      this.OnColHdrStartDrag(e);
      return e.DoDefault;
    }

    private bool DoColHdrEndDrag(int newOrder, bool toGroupBox)
    {
      iGColHdrEndDragEventArgs e = new iGColHdrEndDragEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfMergedColHdrs(this.fMouseData.RowIndex, this.fMouseData.ColOrder) - 1, toGroupBox ? newOrder : newOrder - 1, toGroupBox);
      this.OnColHdrEndDrag(e);
      return e.DoDefault;
    }

    private bool DoColDividerDoubleClick(int rowIndex, int colOrder)
    {
      iGColDividerDoubleClickEventArgs e = new iGColDividerDoubleClickEventArgs(rowIndex, this.fColIdxFromOrd[colOrder] - 1);
      this.OnColDividerDoubleClick(e);
      return e.DoDefault;
    }

    private void DoColHdrDoubleClick()
    {
      this.OnColHdrDoubleClick(new iGColHdrDoubleClickEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfColHdrFromMouseData() - 1, this.GetColHdrKindFromMouseData(), this.fMouseData.Bounds));
    }

    private bool DoColHdrClick(Keys mofifierKeys)
    {
      iGColHdrClickEventArgs e = new iGColHdrClickEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfColHdrFromMouseData() - 1, this.GetColHdrKindFromMouseData(), this.fMouseData.Bounds, mofifierKeys);
      this.OnColHdrClick(e);
      return e.DoDefault;
    }

    private void ProcessHeaderMouseMoveColResize(int x, int y)
    {
      if (!this.fIsColResizing)
      {
        this.BeginColResize();
        this.fIsColResizing = true;
      }
      bool flag = this.RightToLeft == RightToLeft.Yes;
      iGColResizeData tag = (iGColResizeData) this.fMouseData.Tag;
      int delta1 = x - this.fMouseData.MousePos.X;
      if (tag.DeltaScrollPos > 0 && (x - tag.OldX > 0 && !flag || x - tag.OldX < 0 & flag))
      {
        int num1 = x - tag.OldX;
        this.fMouseData.MousePos.X += num1;
        int num2 = Math.Abs(num1);
        tag.DeltaScrollPos -= num2;
      }
      else
      {
        if (flag)
          delta1 = -delta1;
        int delta2 = this.AdjustDelta(delta1, tag);
        int num1;
        int newWidth;
        if (this.fImmediateColResizing)
        {
          int num2 = this.fHScrollBar.Value;
          num1 = this.SetColsWidths(this.fMouseData.ColOrder, tag.OldWidths, tag.VisibleAllowedCount, delta2);
          if (this.fAutoResizeCols)
            this.DoAutoResizeCols(0, this.fMouseData.ColOrder + this.fMouseData.ColCount, false, false, false);
          this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnResizeCol, false);
          this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnResizeCol, false);
          if (num1 != 0)
            this.RefreshGridAndScrollBarsIfRedraw();
          newWidth = this.GetWidthFromWidths(this.fMouseData.ColOrder, this.fMouseData.ColCount);
          int num3 = this.fHScrollBar.Value;
          int num4 = num2 - num3;
          if (num4 > 0 && this.fMouseData.ColOrder >= this.fFrozenColCount)
            tag.DeltaScrollPos += num4;
        }
        else
        {
          this.DrawVResizeLine(tag.LastRight);
          tag.LastRight = !flag ? this.fMouseData.Bounds.Right + delta2 - 1 : this.fMouseData.Bounds.Left - delta2;
          this.DrawVResizeLine(tag.LastRight);
          num1 = this.fMouseData.Bounds.Width - delta2;
          newWidth = this.fMouseData.Bounds.Width + num1;
        }
        if (num1 != 0)
        {
          this.DoColWidthChanging(newWidth);
          if (this.fMouseData.IsEmpty)
            return;
        }
      }
      tag.OldX = x;
      this.fMouseData.Tag = (object) tag;
    }

    private void BeginColResize()
    {
      int visibleAllowResizeCount;
      int[] oldWidths;
      this.GetDataForSetColsWidths(this.fMouseData.ColOrder, this.fMouseData.ColCount, out visibleAllowResizeCount, out oldWidths);
      this.DoColWidthStartChange(this.GetWidthFromWidths(this.fMouseData.ColOrder, this.fMouseData.ColCount));
      if (this.fMouseData.IsEmpty)
        return;
      bool flag = this.RightToLeft == RightToLeft.Yes;
      int num = !flag ? this.fMouseData.Bounds.Right - 1 : this.fMouseData.Bounds.Left;
      int x;
      int colsWidth;
      if (this.IsFirstVisibleCol(this.fMouseData.ColOrder))
      {
        int levelsExtraWidth = this.GetGroupLevelsExtraWidth();
        x = this.fMouseData.Bounds.X;
        colsWidth = this.fMouseData.Bounds.Width - levelsExtraWidth;
        if (!flag)
          x += levelsExtraWidth;
      }
      else
      {
        x = this.fMouseData.Bounds.X;
        colsWidth = this.fMouseData.Bounds.Width;
      }
      int max;
      int min;
      this.GetColsMinMaxWidth(this.fMouseData.ColOrder, this.fMouseData.ColCount, x, x + colsWidth, true, out max, out min);
      this.fMouseData.Tag = (object) new iGColResizeData(oldWidths, 0, this.fMouseData.MousePos.X, num, visibleAllowResizeCount, min, max, x, colsWidth);
      if (this.fImmediateColResizing)
        return;
      this.DrawVResizeLine(num);
    }

    private int GetDataForSetColsWidths(int colOrder, int colCount, out int visibleAllowResizeCount, out int[] oldWidths)
    {
      int visibleAllowDecreaseCount;
      return this.GetDataForSetColsWidths(colOrder, colCount, 0, 0, out visibleAllowResizeCount, out visibleAllowDecreaseCount, out oldWidths);
    }

    private int GetDataForSetColsWidths(int colOrder, int colCount, int prohibitDecreaseColOrder, int prohibitDecreaseColCount, out int visibleAllowResizeCount, out int visibleAllowDecreaseCount, out int[] oldWidths)
    {
      oldWidths = new int[colCount];
      int index = 0;
      visibleAllowResizeCount = 0;
      visibleAllowDecreaseCount = 0;
      int num = 0;
      while (index < colCount)
      {
        int colIndex = this.fColIdxFromOrd[colOrder];
        iGColData fColData = this.fColDatas[colIndex];
        if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
        {
          oldWidths[index] = fColData.Width;
          num += fColData.Width;
          if (fColData.AllowSizing)
          {
            visibleAllowResizeCount = visibleAllowResizeCount + 1;
            if (colOrder < prohibitDecreaseColOrder || colOrder >= prohibitDecreaseColOrder + prohibitDecreaseColCount)
              visibleAllowDecreaseCount = visibleAllowDecreaseCount + 1;
          }
        }
        ++index;
        ++colOrder;
      }
      return num;
    }

    private void GetSimpleRowTextColMinMaxWidth(ref int max, ref int min)
    {
      this.GetSimpleNormalColsMinMaxWidth(this.fRowTextStartColNear, this.GetRowTextEndColOrder() - this.fRowTextStartColNear + 1, true, ref max, ref min);
    }

    private void GetSimpleNormalColMinMaxWidth(int colOrder, bool checkVisible, ref int max, ref int min)
    {
      int colIndex = this.fColIdxFromOrd[colOrder];
      iGColData fColData = this.fColDatas[colIndex];
      if (checkVisible && !this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
        return;
      int num1 = fColData.AllowSizing ? (fColData.MinWidth >= 0 ? fColData.MinWidth : 0) : fColData.Width;
      min = min + num1;
      if (max >= int.MaxValue)
        return;
      int num2 = fColData.AllowSizing ? (fColData.MaxWidth >= 0 ? fColData.MaxWidth : int.MaxValue - max) : fColData.Width;
      max = max + num2;
    }

    private void GetSimpleNormalColsMinMaxWidth(int colOrder, int colCount, bool checkVisible, ref int max, ref int min)
    {
      for (int index = colOrder + colCount - 1; colOrder <= index; ++colOrder)
        this.GetSimpleNormalColMinMaxWidth(colOrder, checkVisible, ref max, ref min);
    }

    private void GetColsMinMaxWidth(int colOrder, int colCount, int colLeft, int colRight, bool checkVisible, out int max, out int min)
    {
      max = 0;
      min = 0;
      switch (this.GetColDisposition(colOrder))
      {
        case iGColDisposition.Auxiliary:
          return;
        case iGColDisposition.RowText:
          this.GetSimpleRowTextColMinMaxWidth(ref max, ref min);
          colOrder = this.fRowTextStartColNear;
          colCount = this.GetRowTextEndColOrder() - this.fRowTextStartColNear + 1;
          break;
        default:
          this.GetSimpleNormalColsMinMaxWidth(colOrder, colCount, checkVisible, ref max, ref min);
          break;
      }
      if (this.fAutoResizeCols)
      {
        int num1 = 0;
        int num2 = 0;
        for (int index = colOrder + colCount; index < this.fColCount; ++index)
        {
          int colIndex = this.fColIdxFromOrd[index];
          iGColData fColData = this.fColDatas[colIndex];
          if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
          {
            if (fColData.AllowSizing)
            {
              if (fColData.MinWidth > 0)
                num1 += fColData.MinWidth;
              if (fColData.MaxWidth > 0 && num2 < int.MaxValue)
                num2 += fColData.MaxWidth;
              else
                num2 = int.MaxValue;
            }
            else
            {
              num1 += fColData.Width;
              if (num2 < int.MaxValue)
                num2 += fColData.Width;
            }
          }
        }
        int num3 = this.RightToLeft != RightToLeft.Yes ? this.Width - this.GetBorderSize() - this.GetVScrollBarWidth() - colLeft : colRight - this.GetBorderSize() - this.GetVScrollBarWidth();
        int num4 = num3 - num2;
        int num5 = num3 - num1;
        if (num5 < 0)
          num5 = 0;
        if (num4 < 0)
          num4 = 0;
        if (num4 > min)
          min = num4;
        if (num5 < max)
          max = num5;
      }
      if (min <= max)
        return;
      max = min;
    }

    private int SetColsWidths(int colOrder, int[] oldWidths, int visibleAllowResizeCount, int delta)
    {
      return this.SetColsWidths(colOrder, oldWidths, 0, 0, visibleAllowResizeCount, visibleAllowResizeCount, delta);
    }

    private int SetColsWidths(int colOrder, int[] oldWidths, int prohibitDecreaseColOrder, int prohibitDecreaseColCount, int visibleAllowResizeCount, int visibleAllowDecreaseCount, int delta)
    {
      int num1 = delta >= 0 ? visibleAllowResizeCount : visibleAllowDecreaseCount;
      if (num1 == 0)
        return 0;
      int num2 = (int) Math.Floor((double) delta / (double) num1);
      int num3 = delta <= 0 ? -num2 * num1 + delta : delta % num1;
      int num4 = 0;
      bool flag1 = true;
      while ((uint) num3 > 0U | flag1)
      {
        int num5 = num1;
        int index1 = colOrder;
        for (int index2 = 0; index2 < num1 && index1 < this.fColCount; ++index1)
        {
          int colIndex = this.fColIdxFromOrd[index1];
          iGColData fColData = this.fColDatas[colIndex];
          bool flag2 = fColData.AllowSizing;
          if (delta < 0)
            flag2 = ((flag2 ? 1 : 0) & (index1 < prohibitDecreaseColOrder ? 1 : (index1 >= prohibitDecreaseColOrder + prohibitDecreaseColCount ? 1 : 0))) != 0;
          if (flag2 && this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
          {
            int width = fColData.Width;
            int num6 = !flag1 ? width + num3 : oldWidths[index1 - colOrder] + num2 + num3;
            int num7 = fColData.MinWidth;
            int maxWidth = fColData.MaxWidth;
            if (num7 < 0)
              num7 = 0;
            if (num6 <= num7)
            {
              num3 = num6 - num7;
              num6 = num7;
            }
            else if (maxWidth > 0 && num6 >= maxWidth)
            {
              num3 = num6 - maxWidth;
              num6 = maxWidth;
            }
            else
            {
              num3 = 0;
              --num5;
            }
            num4 += num6 - width;
            this.fColDatas[colIndex].Width = num6;
            ++index2;
          }
        }
        flag1 = false;
        if (num5 == num1)
          break;
      }
      if (num4 != 0)
        this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea + num4;
      return num4;
    }

    private int GetWidthFromWidths(int colOrder, int colCount)
    {
      int num = 0;
      for (int index = colOrder + colCount - 1; index >= colOrder; --index)
      {
        int colIndex = this.fColIdxFromOrd[index];
        iGColData fColData = this.fColDatas[colIndex];
        if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
          num += fColData.Width;
      }
      return num;
    }

    private void DoStopHeaderActionColResize(bool apply)
    {
      int rightToLeft = (int) this.RightToLeft;
      this.fMouseData.State = iGControlState.Normal;
      this.fMouseData.Button = MouseButtons.None;
      if (!this.fImmediateColResizing)
      {
        iGColResizeData tag = (iGColResizeData) this.fMouseData.Tag;
        this.DrawVResizeLine(tag.LastRight);
        if (apply)
        {
          int delta1 = tag.OldX - this.fMouseData.MousePos.X;
          if (this.RightToLeft == RightToLeft.Yes)
            delta1 = -delta1;
          int delta2 = this.AdjustDelta(delta1, tag);
          if (this.SetColsWidths(this.fMouseData.ColOrder, tag.OldWidths, tag.VisibleAllowedCount, delta2) != 0)
          {
            if (this.fAutoResizeCols)
              this.DoAutoResizeCols(0, this.fMouseData.ColOrder + this.fMouseData.ColCount, false, false, false);
            this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnResizeCol, false);
            this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnResizeCol, false);
            this.RefreshGridAndScrollBarsIfRedraw();
          }
        }
      }
      this.fMouseData.Bounds = this.GetColHdrBounds(this.fMouseData.RowIndex, this.fMouseData.ColOrder);
      this.fColHdrDrawnHot.Bounds = this.fMouseData.Bounds;
      iGColResizeData tag1 = (iGColResizeData) this.fMouseData.Tag;
      this.DoColWidthEndChange(this.GetWidthFromWidths(this.fMouseData.ColOrder, this.fMouseData.ColCount));
      this.fIsColResizing = false;
      this.NullOldColWidths();
    }

    private int AdjustDelta(int delta, iGColResizeData resizeData)
    {
      if (resizeData.ColsWidth + delta < resizeData.MinWidth)
        return resizeData.MinWidth - resizeData.ColsWidth;
      if (resizeData.MaxWidth >= 0 && resizeData.ColsWidth + delta > resizeData.MaxWidth)
        return resizeData.MaxWidth - resizeData.ColsWidth;
      return delta;
    }

    private bool CanResizeAtLeastOneCol(int colOrder, int colCount)
    {
      bool flag = false;
      int num = 0;
      for (int index = colOrder + colCount - 1; index >= colOrder; --index)
      {
        int colIndex = this.fColIdxFromOrd[index];
        iGColData fColData = this.fColDatas[colIndex];
        if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
        {
          if (fColData.AllowSizing)
            flag = true;
          num += fColData.Width;
        }
      }
      if (this.fAutoResizeCols & flag)
      {
        flag = false;
        int colOrder1 = colOrder;
        if (this.RightToLeft == RightToLeft.Yes)
          colOrder1 += colCount - 1;
        bool isFirstVisibleCol;
        int x = this.ColToX(colOrder1, false, out isFirstVisibleCol);
        int max;
        int min;
        this.GetColsMinMaxWidth(colOrder, colCount, x, x + num, true, out max, out min);
        if (min < max)
          flag = true;
      }
      return flag;
    }

    private void ProcessHeaderMouseMoveColMove(int x, int y)
    {
      if (!this.StartColMove(x, y))
        return;
      int moveColHdrDrawX;
      int moveColHdrDrawY;
      this.DrawMoveColumnHeader(x, y, out moveColHdrDrawX, out moveColHdrDrawY);
      iGColMoveData tag = this.fMouseData.Tag as iGColMoveData;
      Rectangle areaBoundsNoRowHdr = this.GetCellsAreaBoundsNoRowHdr();
      Rectangle groupBoxBounds = this.GetGroupBoxBounds(this.RightToLeft == RightToLeft.Yes);
      bool flag = this.fGroupBoxVisible && moveColHdrDrawY + tag.MoveColHdrBitmap.Height < groupBoxBounds.Bottom;
      if (!areaBoundsNoRowHdr.Contains(this.fMouseData.MousePos) && !flag)
      {
        int dy;
        if ((this.GetAutoScrollMoveDirection(x, y, areaBoundsNoRowHdr, this.GetAutoScrollDirections(), out tag.AutoScrollDX, out dy) & (iGAutoScrollMoveDirection.Left | iGAutoScrollMoveDirection.Right)) == iGAutoScrollMoveDirection.None || this.fAutoScrollTimer != null)
          return;
        this.StartColMoveAutoScroll();
      }
      else
        tag.AutoScrollDX = 0;
    }

    private void StartColMoveAutoScroll()
    {
      this.StartAutoScrollTimer(new EventHandler(this.AutoScrollTimerColMove_Tick));
    }

    private void AutoScrollTimerColMove_Tick(object sender, EventArgs e)
    {
      if (!this.IsColMoving())
        this.StopAutoScrollTimer();
      else
        this.AutoScrollScrollBars((this.fMouseData.Tag as iGColMoveData).AutoScrollDX, 0);
    }

    private void MouseColMoveOnScroll()
    {
      Bitmap headerBitmap;
      Bitmap moveColHdrBitmap;
      iGIndent colHdrIndent;
      this.GetColMoveDataHeaderBitmaps(out headerBitmap, out moveColHdrBitmap, out colHdrIndent);
      iGColMoveData tag = (iGColMoveData) this.fMouseData.Tag;
      Bitmap bitmap1 = moveColHdrBitmap;
      tag.MoveColHdrBitmap = bitmap1;
      Bitmap bitmap2 = headerBitmap;
      tag.HeaderBitmap = bitmap2;
      iGIndent iGindent = colHdrIndent;
      tag.ColHdrIndent = iGindent;
    }

    private void DrawMoveColumnHeader(int x, int y, out int moveColHdrDrawX, out int moveColHdrDrawY)
    {
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      iGColMoveData tag = (iGColMoveData) this.fMouseData.Tag;
      using (Graphics graphics1 = this.CreateGraphics())
      {
        using (Bitmap bitmap = new Bitmap(tag.HeaderBitmap.Width, tag.HeaderBitmap.Height, graphics1))
        {
          using (Graphics graphics2 = Graphics.FromImage((Image) bitmap))
          {
            int borderSize = this.GetBorderSize();
            graphics1.SetClip(new Rectangle(borderSize, borderSize, this.Width - 2 * borderSize, this.Height - 2 * borderSize));
            graphics2.DrawImageUnscaled((Image) tag.HeaderBitmap, 0, 0);
            moveColHdrDrawX = this.fMouseData.Bounds.X + x - this.fMouseData.MousePos.X + tag.ColHdrIndent.fLeft;
            this.GetVScrollBarWidth();
            if (this.fGroupBoxVisible && tag.CanBeGrouped)
            {
              moveColHdrDrawY = this.fMouseData.Bounds.Y + y - this.fMouseData.MousePos.Y + tag.ColHdrIndent.fTop;
              int headerAreaHeight = this.GetHeaderAreaHeight();
              int num = moveColHdrDrawY + tag.MoveColHdrBitmap.Height - headerAreaHeight - borderSize;
              if (num > 0)
                moveColHdrDrawY = moveColHdrDrawY - num;
              if (moveColHdrDrawY < borderSize)
                moveColHdrDrawY = borderSize;
            }
            else
              moveColHdrDrawY = this.fMouseData.Bounds.Y + tag.ColHdrIndent.fTop;
            graphics2.DrawImage((Image) tag.MoveColHdrBitmap, new Rectangle(moveColHdrDrawX, moveColHdrDrawY, tag.MoveColHdrBitmap.Width, tag.MoveColHdrBitmap.Height), 0, 0, tag.MoveColHdrBitmap.Width, tag.MoveColHdrBitmap.Height, GraphicsUnit.Pixel, this.GetImageAttributes(0.6f));
            bool flag1 = false;
            if (this.fGroupBoxVisible && y < this.GetGroupBoxBounds(rightToLeft).Bottom)
            {
              int boundX;
              int groupIndexToInsert = this.GetGroupIndexToInsert(graphics1, x, rightToLeft, out boundX);
              int index = this.fColIdxFromOrd[this.fMouseData.ColOrder];
              if (tag.CanBeGrouped && (this.fMouseData.ColCount > 1 || (this.fLastGroupObject == null || this.fLastGroupObject.fParams[index].SortType == iGSortType.None || this.fLastGroupObject.fParams[index].SortIndex != groupIndexToInsert - 1 && this.fLastGroupObject.fParams[index].SortIndex != groupIndexToInsert)))
              {
                int y1 = this.fLastGroupObject == null || this.fLastGroupObject.Count == 0 || groupIndexToInsert != this.fLastGroupObject.Count ? this.GetGroupBoxColHdrY(groupIndexToInsert, borderSize) + this.GetGroupColHdrHeight() : this.GetGroupBoxColHdrY(groupIndexToInsert - 1, borderSize) + this.GetGroupColHdrHeight();
                if (this.fLastGroupObject != null && this.fLastGroupObject.fParams[index].SortType != iGSortType.None && groupIndexToInsert > this.fLastGroupObject.fParams[index].SortIndex)
                  --groupIndexToInsert;
                bool flag2;
                if (tag.MoveToGroupBox && tag.MoveToOrderOrGroupIndex == groupIndexToInsert)
                {
                  flag2 = tag.CanPlaceTo;
                }
                else
                {
                  flag2 = this.DoColHdrDragging(groupIndexToInsert, true);
                  if (this.fMouseData.IsEmpty)
                    return;
                }
                if (flag2)
                {
                  if (iGrid.fArrowUpIcon == null)
                    iGrid.fArrowUpIcon = new Icon(iGrid.GetResourceStream("ArrowUp.ico"));
                  graphics2.DrawIconUnstretched(iGrid.fArrowUpIcon, new Rectangle(boundX - iGrid.fArrowUpIcon.Width / 2, y1, 0, 0));
                }
                tag.MoveToOrderOrGroupIndex = groupIndexToInsert;
                tag.MoveToGroupBox = true;
                tag.CanPlaceTo = flag2;
              }
              else
              {
                tag.CanPlaceTo = false;
                tag.MoveToOrderOrGroupIndex = -1;
              }
            }
            else
            {
              int num = 0;
              bool flag2;
              int colOrder;
              int colX;
              int colWidth;
              if (this.fVisibleColCount == 0)
              {
                flag2 = true;
                colOrder = tag.RealColOrder;
                colX = !rightToLeft ? borderSize + this.fRowHeader.EffectiveWidth() : this.Width - borderSize - this.fRowHeader.EffectiveWidth();
                colWidth = 0;
              }
              else
              {
                bool isLastVisibleCol;
                if (this.GetColFromXInternal(x, 0, true, out colOrder, out colX, out colWidth, 1073741823, rightToLeft, out isLastVisibleCol))
                {
                  flag2 = true;
                  if (rightToLeft)
                  {
                    if (x < colX + colWidth / 2)
                    {
                      if (colOrder == this.fColCount - 1)
                      {
                        num = 1;
                      }
                      else
                      {
                        do
                        {
                          ++colOrder;
                          int colIndex = this.fColIdxFromOrd[colOrder];
                          iGColData fColData = this.fColDatas[colIndex];
                          if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
                          {
                            colWidth = fColData.Width;
                            colX -= colWidth;
                            break;
                          }
                          colWidth = 0;
                        }
                        while (colOrder < tag.RealColOrder);
                      }
                    }
                    else
                    {
                      while (colOrder > tag.RealColOrder + tag.RealColCount)
                      {
                        int colIndex = this.fColIdxFromOrd[colOrder - 1];
                        iGColData fColData = this.fColDatas[colIndex];
                        if (!this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
                        {
                          --colOrder;
                          colX += colWidth;
                          colWidth = 0;
                        }
                        else
                          break;
                      }
                    }
                  }
                  else if (x > colX + colWidth / 2)
                  {
                    if (colOrder == this.fColCount - 1)
                    {
                      num = 1;
                    }
                    else
                    {
                      do
                      {
                        ++colOrder;
                        colX += colWidth;
                        int colIndex = this.fColIdxFromOrd[colOrder];
                        iGColData fColData = this.fColDatas[colIndex];
                        if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
                        {
                          colWidth = fColData.Width;
                          break;
                        }
                        colWidth = 0;
                      }
                      while (colOrder < tag.RealColOrder);
                    }
                  }
                  else
                  {
                    while (colOrder > tag.RealColOrder + tag.RealColCount)
                    {
                      int colIndex = this.fColIdxFromOrd[colOrder - 1];
                      iGColData fColData = this.fColDatas[colIndex];
                      if (!this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
                      {
                        --colOrder;
                        colWidth = 0;
                      }
                      else
                        break;
                    }
                  }
                  if (colOrder > tag.RealColOrder + tag.RealColCount && num == 0)
                  {
                    while (true)
                    {
                      int index = this.fColIdxFromOrd[colOrder];
                      iGColData fColData = this.fColDatas[index];
                      if (!this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, index) && !this.CanSeparateCols(this.fColIdxFromOrd[colOrder - 1], index, tag.Rows))
                      {
                        if (colOrder != this.fColCount - 1)
                          ++colOrder;
                        else
                          break;
                      }
                      else
                        goto label_56;
                    }
                    num = 1;
                  }
                  else if (colOrder < tag.RealColOrder)
                  {
                    for (; colOrder > 1; --colOrder)
                    {
                      int index = this.fColIdxFromOrd[colOrder - 1];
                      iGColData fColData = this.fColDatas[index];
                      if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, index) || this.CanSeparateCols(index, this.fColIdxFromOrd[colOrder], tag.Rows))
                        break;
                    }
                  }
                }
                else
                  flag2 = false;
              }
label_56:
              if (flag2)
              {
                bool flag3 = this.fMouseData.IsGroupBox || (colOrder < tag.RealColOrder || colOrder + num > tag.RealColOrder + tag.RealColCount) && this.AreThereVisibleColBetween(tag.RealColOrder, tag.RealColCount, colOrder + num);
                if (colOrder >= tag.RealColOrder + tag.RealColCount)
                  colOrder += num - tag.RealColCount;
                if (flag3 && tag.StartOrder <= colOrder && tag.EndOrder >= colOrder)
                {
                  if (!tag.MoveToGroupBox && tag.MoveToOrderOrGroupIndex == colOrder)
                  {
                    flag1 = tag.CanPlaceTo;
                  }
                  else
                  {
                    string reasonCantPlace;
                    flag1 = this.CanPlaceColsTo(tag.RealColOrder, colOrder, tag.RealColCount, tag.Rows, out reasonCantPlace);
                    if (flag1)
                    {
                      flag1 = this.DoColHdrDragging(colOrder, false);
                      if (this.fMouseData.IsEmpty)
                        return;
                    }
                  }
                  if (flag1)
                  {
                    if (iGrid.fArrowsIcon == null)
                      iGrid.fArrowsIcon = new Icon(iGrid.GetResourceStream("Arrows.ico"));
                    int x1 = (!rightToLeft ? colX + num * colWidth : colX + ((1 - num) * colWidth + 1)) - 8;
                    int y1 = !this.fMouseData.IsGroupBox ? this.fMouseData.Bounds.Y + this.fMouseData.Bounds.Height / 2 - 4 : tag.HeaderBitmap.Height - this.fHeaderRows[0].Height / 2 - 4;
                    graphics2.DrawIconUnstretched(iGrid.fArrowsIcon, new Rectangle(x1, y1, 0, 0));
                  }
                }
                tag.CanPlaceTo = flag1;
                tag.MoveToOrderOrGroupIndex = colOrder;
                tag.MoveToGroupBox = false;
              }
              else
              {
                tag.CanPlaceTo = false;
                tag.MoveToOrderOrGroupIndex = -1;
              }
            }
            graphics1.DrawImageUnscaled((Image) bitmap, 0, 0);
          }
        }
      }
    }

    private bool StartColMove(int x, int y)
    {
      if (this.fMouseData.Tag == null)
      {
        int dstStartOrder1;
        int dstEndOrder1;
        bool[] rowsMap1;
        string reasonCantMove1;
        if (!this.fMouseData.MouseDownOnAColHdr || Math.Abs(x - this.fMouseData.MouseDownMousePos.X) < 5 && (!this.fGroupBoxVisible || Math.Abs(y - this.fMouseData.MouseDownMousePos.Y) < 5) || (!this.CanMoveCols(this.fMouseData.ColOrder, this.fMouseData.ColCount, out dstStartOrder1, out dstEndOrder1, out rowsMap1, out reasonCantMove1) || !this.DoColHdrStartDrag() || this.fMouseData.IsEmpty))
          return false;
        int boundColOrder;
        int boundColCount;
        this.GetMergedColHdrLeftAndRightOrder(this.fMouseData.ColOrder, out boundColOrder, out boundColCount);
        if (boundColCount > 1)
        {
          int visibleColCount = this.GetVisibleColCount(boundColOrder, boundColCount);
          int dstStartOrder2;
          int dstEndOrder2;
          bool[] rowsMap2;
          string reasonCantMove2;
          if ((this.fMouseData.IsGroupBox && visibleColCount == 0 || !this.fMouseData.IsGroupBox && visibleColCount == 1) && this.CanMoveCols(boundColOrder, boundColCount, out dstStartOrder2, out dstEndOrder2, out rowsMap2, out reasonCantMove2))
          {
            this.fMouseData.Tag = (object) this.GetColMoveData(dstStartOrder2, dstEndOrder2, rowsMap2, boundColOrder, boundColCount);
            return true;
          }
        }
        this.fMouseData.Tag = (object) this.GetColMoveData(dstStartOrder1, dstEndOrder1, rowsMap1, this.fMouseData.ColOrder, this.fMouseData.ColCount);
      }
      return true;
    }

    private bool AreThereVisibleColBetween(int colOrder1, int colCount1, int colOrder2)
    {
      int index;
      int num;
      if (colOrder2 > colOrder1)
      {
        index = colOrder1 + colCount1;
        num = colOrder2 - 1;
      }
      else
      {
        index = colOrder2;
        num = colOrder1 - 1;
      }
      for (; index <= num; ++index)
      {
        if (this.IsColVisible(this.fColIdxFromOrd[index]))
          return true;
      }
      return false;
    }

    private bool IsColMoving()
    {
      if (!this.fMouseData.IsEmpty && this.fMouseData.State == iGControlState.Pressed && (this.fMouseData.Button == MouseButtons.Left && this.fMouseData.Area == iGMouseArea.Header))
        return this.fMouseData.Tag is iGColMoveData;
      return false;
    }

    private void DoStopHeaderActionColMove(bool apply)
    {
      this.fMouseData.State = iGControlState.Normal;
      this.fMouseData.Button = MouseButtons.None;
      iGColMoveData tag = (iGColMoveData) this.fMouseData.Tag;
      if (apply && tag.CanPlaceTo)
      {
        bool isGroupBox = this.fMouseData.IsGroupBox;
        int colOrder = this.fMouseData.ColOrder;
        int colCount = this.fMouseData.ColCount;
        if (this.DoColHdrEndDrag(tag.MoveToOrderOrGroupIndex, tag.MoveToGroupBox))
        {
          if (tag.MoveToGroupBox)
          {
            if (this.CheckUnmergeCellsSortGroup(iGUnmergeCellsRequiredReason.Grouping, this.fColIdxFromOrd[colOrder] - 1))
            {
              if (isGroupBox)
              {
                this.SetGroupObjPropsFromLastGroupObj();
                this.GroupObject.MoveGroupCol(this.fColIdxFromOrd[colOrder], tag.MoveToOrderOrGroupIndex);
              }
              else
              {
                int num = 0;
                int srcColIndex = 0;
                for (int index = colOrder; index < colOrder + colCount; ++index)
                {
                  int colIndex = this.fColIdxFromOrd[colOrder];
                  if (this.IsColVisible(colIndex))
                  {
                    if (num == 0)
                      srcColIndex = colIndex;
                    ++num;
                  }
                }
                this.SetGroupObjPropsFromLastGroupObj();
                if (num == 1 && this.fLastGroupObject != null && this.fLastGroupObject.fParams[srcColIndex].SortType != iGSortType.None)
                  this.GroupObject.MoveGroupCol(srcColIndex, tag.MoveToOrderOrGroupIndex);
                else
                  this.GroupObject.InsertVisibleCols(tag.MoveToOrderOrGroupIndex, colOrder, colCount);
              }
              this.Group();
            }
          }
          else if (isGroupBox)
          {
            if (this.CheckUnmergeCellsSortGroup(iGUnmergeCellsRequiredReason.Grouping, this.fColIdxFromOrd[colOrder] - 1))
            {
              this.SetGroupObjPropsFromLastGroupObj();
              this.GroupObject.SetSortOrder(this.GroupObject.fParams[this.fColIdxFromOrd[colOrder]].SortIndex, iGSortOrder.None);
              this.MoveColsInternal(tag.RealColOrder, tag.MoveToOrderOrGroupIndex, tag.RealColCount);
              this.Group();
            }
          }
          else
            this.MoveColsInternal(tag.RealColOrder, tag.MoveToOrderOrGroupIndex, tag.RealColCount);
        }
      }
      tag.MoveColHdrBitmap.Dispose();
      tag.HeaderBitmap.Dispose();
      this.Invalidate();
    }

    private void GetColMoveDataHeaderBitmaps(out Bitmap headerBitmap, out Bitmap moveColHdrBitmap, out iGIndent colHdrIndent)
    {
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int borderSize = this.GetBorderSize();
      using (Graphics graphics1 = this.CreateGraphics())
      {
        int headerAreaHeight = this.GetHeaderAreaHeight();
        headerBitmap = new Bitmap(this.Width, headerAreaHeight + borderSize, graphics1);
        Graphics graphics2;
        using (graphics2 = Graphics.FromImage((Image) headerBitmap))
        {
          graphics2.Clear(this.BackColor);
          Rectangle clipRect = new Rectangle(0, 0, headerBitmap.Width, headerBitmap.Height);
          this.OnPaintBackground(new PaintEventArgs(graphics2, clipRect));
          this.DrawHeader(graphics2, borderSize, borderSize, headerBitmap.Width - 2 * borderSize, headerBitmap.Height, new Rectangle(0, 0, headerBitmap.Width, headerBitmap.Height));
          this.DrawScrollBars(graphics2);
        }
        colHdrIndent = new iGIndent(-1, -1, -1, -1);
        int headerVgridLinesWidth = this.GetHeaderVGridLinesWidth(this.fMouseData.ColOrder + this.fMouseData.ColCount - 1);
        colHdrIndent.fRight += headerVgridLinesWidth;
        int num1 = this.fMouseData.Bounds.Width - headerVgridLinesWidth;
        int num2 = this.fMouseData.Bounds.Height - this.GetHeaderHGridLinesWidth(this.fMouseData.RowIndex);
        if (rightToLeft)
          colHdrIndent = iGAligner.RtlTranslateIndent(colHdrIndent);
        if (this.fHeaderDrawSystem && (!this.fMouseData.IsGroupBox || !this.IsForceNotPaintControlForGrouBox(this.fHeaderControlPaintStyle.ControlPaint)))
        {
          iGIndent headerIndent = this.fHeaderControlPaintStyle.ControlPaint.GetHeaderIndent(rightToLeft);
          num1 -= headerIndent.fRight + headerIndent.fLeft;
          num2 -= headerIndent.fTop + headerIndent.fBottom;
          colHdrIndent.fLeft += headerIndent.fLeft;
          colHdrIndent.fRight += headerIndent.fRight;
          colHdrIndent.fTop += headerIndent.fTop;
          colHdrIndent.fBottom += headerIndent.fBottom;
        }
        int colIndex = this.fColIdxFromOrd[this.fMouseData.ColOrder];
        iGColHdrData colHdrData = this.GetColHdrData(this.fMouseData.RowIndex, colIndex);
        moveColHdrBitmap = new Bitmap(num1 + 2, num2 + 2, graphics1);
        Graphics g;
        using (g = Graphics.FromImage((Image) moveColHdrBitmap))
        {
          g.Clear(System.Drawing.Color.Transparent);
          System.Drawing.Color headerBackColor = this.GetHeaderBackColor();
          using (Brush brush = (Brush) new SolidBrush(headerBackColor))
            g.FillRectangle(brush, 0, 0, num1 + 2, num2 + 2);
          using (Pen pen = new Pen(iGColorManager.GetColorControlDarkDark(headerBackColor)))
            g.DrawRectangle(pen, 0, 0, num1 + 1, num2 + 1);
          int fromStylesDrawType = (int) this.GetPropFromStyles_DrawType((iGStyleBase) colHdrData.Style, (iGStyleBase) null, (iGStyleBase) this.fColDatas[colIndex].ColHdrStyle);
          iGControlState iGcontrolState = !this.fHeaderHotTracking ? iGControlState.Normal : iGControlState.Hot;
          System.Drawing.Color backColor;
          System.Drawing.Color foreColor;
          Font font;
          this.GetUniCellFormattingNoSelected(iGGridSection.Header, this.fMouseData.RowIndex, colIndex, (iGStyleBase) colHdrData.Style, (iGStyleBase) null, (iGStyleBase) this.fColDatas[colIndex].ColHdrStyle, iGcontrolState, false, false, false, false, out backColor, out foreColor, out font);
          int contentsX = 1;
          int num3 = 1;
          this.DrawUniCellContents(iGGridSection.Header, g, (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint, this.fMouseData.RowIndex, colIndex, contentsX, num3, num1, num2, true, int.MinValue, num3, num1, num2, colHdrData.Value, (object) null, colHdrData.ImageIndex, (iGStyleBase) colHdrData.Style, (iGStyleBase) null, (iGStyleBase) this.fColDatas[colIndex].ColHdrStyle, false, false, false, false, false, iGcontrolState, iGcontrolState, true, false, this.GetDrawAsFocusedState(), iGRowType.Normal, iGTreeButtonState.Absent, false, Size.Empty, 0, iGTreeBranchState.None, (Pen) null, true, true, false, backColor, foreColor, font, iGSortOrder.None, -1, false, false, false);
        }
      }
    }

    private iGColMoveData GetColMoveData(int startIndex, int endIndex, bool[] rows, int realColOrder, int realColCount)
    {
      Bitmap headerBitmap;
      Bitmap moveColHdrBitmap;
      iGIndent colHdrIndent;
      this.GetColMoveDataHeaderBitmaps(out headerBitmap, out moveColHdrBitmap, out colHdrIndent);
      bool canBeGrouped = !this.ColRangeContainsNonGroupableCols(this.fMouseData.ColOrder, this.fMouseData.ColCount) && !this.fStaySorted;
      return new iGColMoveData(headerBitmap, moveColHdrBitmap, colHdrIndent, startIndex, endIndex, rows, canBeGrouped, realColOrder, realColCount, 0);
    }

    private void GetMergedColHdrLeftAndRightOrder(int colOrder, out int boundColOrder, out int boundColCount)
    {
      boundColOrder = colOrder;
      while (boundColOrder > 1 && !this.CanSeparateCols(this.fColIdxFromOrd[boundColOrder], this.fColIdxFromOrd[boundColOrder - 1], (bool[]) null))
        boundColOrder = boundColOrder - 1;
      int index = colOrder;
      while (index < this.fColCount - 1 && !this.CanSeparateCols(this.fColIdxFromOrd[index], this.fColIdxFromOrd[index + 1], (bool[]) null))
        ++index;
      boundColCount = index - boundColOrder + 1;
    }

    private int GetVisibleColCount(int colOrder, int colCount)
    {
      int num = 0;
      for (int index = colOrder + colCount - 1; index >= colOrder; --index)
      {
        if (this.IsColVisible(this.fColIdxFromOrd[index]))
          ++num;
      }
      return num;
    }

    private void RaiseMouseLeaveEvent()
    {
      switch (this.fMouseData.Area)
      {
        case iGMouseArea.Cells:
          this.DoCellMouseLeaveWrapper();
          break;
        case iGMouseArea.Header:
          this.DoColHdrMouseLeaveWrapper();
          break;
        case iGMouseArea.RowHdr:
          this.DoRowHdrMouseLeave();
          break;
        case iGMouseArea.RowResize:
          this.DoRowResizeAreaMouseLeave();
          break;
        case iGMouseArea.Footer:
          this.DoFooterCellMouseLeaveWrapper();
          break;
      }
    }

    private bool RaiseMouseLeaveEventForPreviousMouseArea(iGMouseArea currentMouseArea)
    {
      if (!this.fMouseData.IsEmpty)
      {
        if (currentMouseArea != this.fMouseData.Area)
          this.RaiseMouseLeaveEvent();
        if (this.fMouseData.IsEmpty)
          return false;
      }
      return true;
    }

    private void ProcessFooterMouseMovePressed(int x, int y, MouseButtons button)
    {
      this.fMouseData.MousePos = new Point(x, y);
      this.DoFooterCellMouseMove(button);
    }

    private void ProcessFooterMouseMove(int x, int y, MouseButtons button)
    {
      if (!this.RaiseMouseLeaveEventForPreviousMouseArea(iGMouseArea.Footer))
        return;
      int rowIndex;
      int rowCount;
      int colOrder;
      int colCount;
      Rectangle bounds;
      if (this.GetFooterCellFromPointInternal(x, y, out rowIndex, out rowCount, out colOrder, out colCount, out bounds))
      {
        iGMouseEventsData gmouseEventsData = new iGMouseEventsData(rowIndex, rowCount, colOrder, colCount, iGMouseArea.Footer, iGControlState.Normal, bounds, new Point(x, y), (object) null, false, iGElemControl.None, button);
        if (this.fMouseData.IsEmpty || this.fMouseData.Area != iGMouseArea.Footer || (this.fMouseData.RowIndex != rowIndex || this.fMouseData.ColOrder != colOrder))
        {
          if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Footer)
          {
            this.DoFooterCellMouseLeaveWrapper();
            if (this.fMouseData.IsEmpty)
              return;
          }
          this.fMouseData = gmouseEventsData;
          this.DoFooterCellMouseEnter();
          if (this.fMouseData.IsEmpty)
            return;
          this.GridToolTipInitFromMouseData();
        }
        else
          this.fMouseData = gmouseEventsData;
      }
      else
      {
        Rectangle footerRowHdrBounds = this.GetFooterRowHdrBounds();
        if (footerRowHdrBounds.Contains(x, y))
        {
          if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Footer && !this.fMouseData.IsFooterRowHdr)
          {
            this.DoFooterCellMouseLeaveWrapper();
            if (this.fMouseData.IsEmpty)
              return;
          }
          iGMouseEventsData footerRowHdrData = iGMouseEventsData.CreateFooterRowHdrData(this.fFooterRowCount, footerRowHdrBounds, new Point(x, y));
          if (this.fMouseData.IsEmpty || !this.fMouseData.IsFooterRowHdr)
          {
            this.fMouseData = footerRowHdrData;
            this.DoFooterCellMouseEnter();
            if (this.fMouseData.IsEmpty)
              return;
            this.GridToolTipInitFromMouseData();
          }
          this.fMouseData = footerRowHdrData;
        }
        else
        {
          if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Footer && !this.fMouseData.IsFooterExtraCell)
          {
            this.DoFooterCellMouseLeaveWrapper();
            if (this.fMouseData.IsEmpty)
              return;
          }
          iGMouseEventsData footerExtraCellData = iGMouseEventsData.CreateFooterExtraCellData(this.fFooterRowCount, this.GetFooterExtraCellBounds(), new Point(x, y));
          if (this.fMouseData.IsEmpty || !this.fMouseData.IsFooterExtraCell)
          {
            this.fMouseData = footerExtraCellData;
            this.DoFooterCellMouseEnter();
            if (this.fMouseData.IsEmpty)
              return;
            this.GridToolTipInitFromMouseData();
          }
          this.fMouseData = footerExtraCellData;
        }
      }
      this.DoFooterCellMouseMove(button);
    }

    private void ProcessFooterMouseDown(int x, int y, MouseButtons button)
    {
      this.fMouseData.MousePos = new Point(x, y);
      this.fMouseData.MouseDownMousePos = this.fMouseData.MousePos;
      this.fMouseData.State = iGControlState.Pressed;
      this.fMouseData.Button = button;
      this.DoFooterCellMouseDown();
    }

    private void ProcessFooterMouseUp(int x, int y, MouseButtons button)
    {
      this.DoFooterCellMouseUp();
      if (this.fMouseData.IsEmpty)
        return;
      if (this.fMouseData.State == iGControlState.Pressed && button == MouseButtons.Left && (this.fMouseData.Button == MouseButtons.Left && this.fMouseData.Bounds.Contains(x, y)))
      {
        this.DoFooterCellClick(Control.ModifierKeys);
        if (this.fMouseData.IsEmpty)
          return;
      }
      this.fMouseData.State = iGControlState.Normal;
      this.fMouseData.Button = button;
    }

    private void ProcessFooterDoubleClick()
    {
      this.DoFooterCellDoubleClick();
    }

    private void ProcessHeaderMouseMove(int x, int y, MouseButtons button)
    {
      int rowIndex = -1;
      int colOrder = -1;
      int x1 = 0;
      int y1 = 0;
      int width1 = 0;
      int height1 = 0;
      int resizeOffset = 8;
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      bool isLastVisibleCol = false;
      bool isGroupBox = false;
      if (!this.RaiseMouseLeaveEventForPreviousMouseArea(iGMouseArea.Header))
        return;
      bool flag1 = this.GetGroupBoxBounds(rightToLeft).Contains(x, y);
      bool flag2;
      if (flag1)
      {
        flag2 = false;
        using (Graphics graphics = this.CreateGraphics())
        {
          int colIndex;
          isGroupBox = this.GetGroupBoxColHdrFromPointInternal(graphics, x, y, rightToLeft, out colIndex, out x1, out y1, out width1, out height1);
          if (isGroupBox)
          {
            rowIndex = 0;
            colOrder = this.GetColOrder(colIndex);
          }
        }
      }
      else
      {
        isGroupBox = false;
        flag2 = this.GetColHdrFromPointNoMerge(x, y, out rowIndex, out colOrder, out x1, out y1, out width1, out height1, resizeOffset, rightToLeft, out isLastVisibleCol);
      }
      if (flag2 | isGroupBox)
      {
        int colCount = 1;
        int rowCount = 1;
        bool flag3 = false;
        if (flag2)
        {
          this.Span__GetMergedCellBoundsHorz(iGGridSection.Header, rowIndex, ref colOrder, ref colCount, ref x1, ref width1, rightToLeft);
          int num1 = colOrder;
          int num2 = colCount;
          int num3 = x1;
          int num4 = width1;
          this.ColHdrMouseMoveCheckFrozenColsAndColWidth(rightToLeft, x, ref resizeOffset, ref colOrder, ref x1, ref width1, ref isLastVisibleCol);
          if (this.ColHdrMouseMoveCheckAndAdjustForResizing(rightToLeft, resizeOffset, x, rowIndex, ref colOrder, ref colCount, ref x1, ref width1, isLastVisibleCol))
          {
            if (button == MouseButtons.None)
              flag3 = this.CanResizeAtLeastOneCol(colOrder, colCount) && !this.IsCellDropDownActive();
            if (!flag3)
            {
              colOrder = num1;
              colCount = num2;
              x1 = num3;
              width1 = num4;
            }
          }
          this.Span__GetMergedCellBoundsVert(iGGridSection.Header, ref rowIndex, ref rowCount, colOrder, ref y1, ref height1);
        }
        int colIndex = this.GetColIndex(colOrder);
        iGIndent headerIndent = (this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.Header) != iGControlPaintFunctions.Header ? (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint : this.fCustomControlPaint).GetHeaderIndent(rightToLeft);
        int x2 = x1 + headerIndent.fLeft;
        int width2 = width1 - (headerIndent.fRight + headerIndent.fLeft);
        int y2 = y1 + headerIndent.fTop;
        int height2 = height1 - (headerIndent.fTop + headerIndent.fBottom);
        iGElemControl controlUnderMouse = this.GetElemControlUnderMouse(rowIndex, colIndex, x, y, x2, y2, width2, height2, rightToLeft, true);
        if (controlUnderMouse != iGElemControl.None || this.IsAnyDropDownActive())
          flag3 = false;
        Rectangle rectangle = new Rectangle(x1, y1, width1, height1);
        iGMouseEventsData gmouseEventsData = new iGMouseEventsData(rowIndex, rowCount, colOrder, colCount, iGMouseArea.Header, iGControlState.Hot, rectangle, new Point(x, y), (object) null, isGroupBox, controlUnderMouse, button);
        if (this.fMouseData.IsEmpty || isGroupBox != this.fMouseData.IsGroupBox || (this.fMouseData.Area != iGMouseArea.Header || rowIndex != this.fMouseData.RowIndex) || colOrder != this.fMouseData.ColOrder)
        {
          if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Header)
          {
            this.DoColHdrMouseLeaveWrapper();
            if (this.fMouseData.IsEmpty)
              return;
          }
          this.fMouseData = gmouseEventsData;
          if (this.IsCellDropDownActive())
            this.fColHdrDrawnHot = iGColHdrNavigator.Empty;
          else if (!this.fColHdrDropDownActive)
            this.fColHdrDrawnHot = new iGColHdrNavigator(rowIndex, colIndex, rectangle);
          this.DoColHdrMouseEnter();
          if (this.fMouseData.IsEmpty)
            return;
          this.GridToolTipInitFromMouseData();
          if (controlUnderMouse != iGElemControl.None)
          {
            this.GridToolTipAdjustForElemControl(rowIndex, colIndex, true, controlUnderMouse);
            this.Invalidate(rectangle);
          }
        }
        else
        {
          if (controlUnderMouse != this.fMouseData.ElemControl)
          {
            if (controlUnderMouse != iGElemControl.None)
              this.GridToolTipAdjustForElemControl(rowIndex, colIndex, true, controlUnderMouse);
            else if (this.fToolTipTextForCellControlDiffers)
              this.GridToolTipSetTo(this.fToolTipTextForCell);
            this.Invalidate(rectangle);
          }
          this.fMouseData = gmouseEventsData;
        }
        if (flag3)
          this.SetCursor(iGrid.fCursorColResize);
        else
          this.SetCursor((Cursor) null);
        this.DoColHdrMouseMove(button);
        int num = this.fMouseData.IsEmpty ? 1 : 0;
      }
      else
      {
        Rectangle headerExtraCellBounds = this.GetHeaderExtraCellBounds(rightToLeft);
        if (headerExtraCellBounds.Contains(x, y))
        {
          if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Header && !this.fMouseData.IsHeaderExtraCell)
          {
            this.DoColHdrMouseLeaveWrapper();
            if (this.fMouseData.IsEmpty)
              return;
          }
          bool flag3 = true;
          if (this.fMouseData.IsEmpty || !this.fMouseData.IsHeaderExtraCell)
          {
            this.fMouseData = iGMouseEventsData.CreateHeaderExtraCellData(this.fHeaderRowCount, iGControlState.Hot, headerExtraCellBounds, new Point(x, y));
            flag3 = false;
            this.DoColHdrMouseEnter();
            if (this.fMouseData.IsEmpty)
              return;
            this.GridToolTipInitFromMouseData();
          }
          if (this.fMouseData.State != iGControlState.Hot)
            this.InvalidateMouseDataCellOnHotChangedIfRequired();
          if (flag3)
            this.fMouseData = iGMouseEventsData.CreateHeaderExtraCellData(this.fHeaderRowCount, iGControlState.Hot, headerExtraCellBounds, new Point(x, y));
          this.DoColHdrMouseMove(button);
          int num = this.fMouseData.IsEmpty ? 1 : 0;
        }
        else
        {
          int rowHeaderAreaLeft = this.GetRowHeaderAreaLeft(rightToLeft);
          int width2 = this.fRowHeader.EffectiveWidth();
          if (!flag1 && x >= rowHeaderAreaLeft && x < rowHeaderAreaLeft + width2)
          {
            Rectangle bounds = new Rectangle(rowHeaderAreaLeft, this.GetColumnHeaderAreaTopEdge(), width2, this.HeaderVisibleRowsTotalHeight);
            if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Header && !this.fMouseData.IsHeaderRowHdr)
            {
              this.DoColHdrMouseLeaveWrapper();
              if (this.fMouseData.IsEmpty)
                return;
            }
            iGMouseEventsData headerRowHdrData = iGMouseEventsData.CreateHeaderRowHdrData(this.fHeaderRowCount, this.IsAnyDropDownActive() ? iGControlState.Normal : iGControlState.Hot, bounds, new Point(x, y));
            if (this.fMouseData.IsEmpty || !this.fMouseData.IsHeaderRowHdr)
            {
              this.fMouseData = headerRowHdrData;
              this.DoColHdrMouseEnter();
              if (this.fMouseData.IsEmpty)
                return;
              this.GridToolTipInitFromMouseData();
            }
            this.fMouseData = headerRowHdrData;
            this.DoColHdrMouseMove(button);
            int num = this.fMouseData.IsEmpty ? 1 : 0;
          }
          else
          {
            if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.Header)
              this.DoColHdrMouseLeaveWrapper();
            this.fMouseData = iGMouseEventsData.Empty;
          }
        }
      }
    }

    private void ProcessHeaderMouseDown(int x, int y, MouseButtons button)
    {
      this.fClosingColHdrDropDown = false;
      this.fMouseData.MousePos = new Point(x, y);
      this.fMouseData.MouseDownMousePos = this.fMouseData.MousePos;
      this.fCurColHeaderAllowPress = this.DoColHdrMouseDown(button);
      if (this.fMouseData.IsEmpty)
        return;
      this.fMouseData.State = iGControlState.Pressed;
      this.fMouseData.Button = button;
      if (button != MouseButtons.Left || this.Cursor == iGrid.fCursorColResize || !this.fCurColHeaderAllowPress)
        return;
      this.fMouseData.MouseDownOnAColHdr = true;
      switch (this.fMouseData.ElemControl)
      {
        case iGElemControl.None:
          this.InvalidateMouseDataCellOnPressChangedIfRequired();
          break;
        case iGElemControl.ComboButton:
          if (this.fColHdrDrawnHot.IsEmpty)
            break;
          this.RequestEditColHdrInternal();
          break;
      }
    }

    private void ProcessHeaderMouseMovePressed(int x, int y, MouseButtons button)
    {
      if (this.fMouseData.Button == MouseButtons.Left)
      {
        if (this.Cursor == iGrid.fCursorColResize)
          this.ProcessHeaderMouseMoveColResize(x, y);
        else if (!this.fMouseData.IsHeaderExtraCell && !this.fMouseData.IsHeaderRowHdr && (!this.IsAnyDropDownActive() && !this.fClosingColHdrDropDown))
          this.ProcessHeaderMouseMoveColMove(x, y);
        else
          this.DoColHdrMouseMove(button);
      }
      else
        this.DoColHdrMouseMove(button);
    }

    private void ProcessHeaderMouseUp(int x, int y, MouseButtons button)
    {
      if (button == MouseButtons.Left && this.StopHeaderAction(true))
        return;
      Keys modifierKeys = Control.ModifierKeys;
      this.DoColHdrMouseUp(modifierKeys, button);
      if (this.fMouseData.IsEmpty)
        return;
      if (this.fMouseData.State == iGControlState.Pressed && button == MouseButtons.Left && (this.fMouseData.Bounds.Contains(x, y) && this.Cursor != iGrid.fCursorColResize) && (this.fHeaderAllowPress && this.fCurColHeaderAllowPress && !this.IsAnyDropDownActive()))
      {
        bool isGroupBox = this.fMouseData.IsGroupBox;
        bool flag1 = !this.fMouseData.IsHeaderRowHdr && !this.fMouseData.IsHeaderExtraCell && this.fMouseData.ElemControl == iGElemControl.None;
        int colOrder1 = this.fMouseData.ColOrder;
        int colCount = this.fMouseData.ColCount;
        if (this.DoColHdrClick(modifierKeys))
        {
          if (flag1 | isGroupBox && this.CheckUnmergeCellsSortGroup(iGUnmergeCellsRequiredReason.Sorting, this.fColIdxFromOrd[colOrder1] - 1))
          {
            if (isGroupBox)
              this.DoDefaultGroupInternal(this.fColIdxFromOrd[colOrder1]);
            else if (flag1)
            {
              this.AdjustSortObject();
              bool flag2 = false;
              iGSortOrder iGsortOrder = iGSortOrder.None;
              bool flag3 = false;
              for (int colOrder2 = colOrder1; colOrder2 < colOrder1 + colCount; ++colOrder2)
              {
                int colIndex = this.GetColIndex(colOrder2);
                iGColData colData = this.GetColData(colIndex);
                if (this.fLastGroupObject != null && this.fLastGroupObject.fParams[colIndex].SortType != iGSortType.None)
                {
                  if (!flag3)
                    iGsortOrder = this.fLastGroupObject.fParams[colIndex].SortOrder;
                  else if (iGsortOrder != this.fLastGroupObject.fParams[colIndex].SortOrder)
                    iGsortOrder = iGSortOrder.None;
                  flag3 = true;
                  flag2 = true;
                }
                else if (colData.SortType != iGSortType.None)
                {
                  if (!flag3)
                    iGsortOrder = this.fSortObject.fParams[colIndex].SortOrder;
                  else if (this.fSortObject.fParams[colIndex].SortOrder != iGsortOrder)
                    iGsortOrder = iGSortOrder.None;
                  flag3 = true;
                }
              }
              iGSortOrder sortOrder1 = this.GetColDataInternal(this.GetColIndex(colOrder1)).SortOrder;
              iGSortOrder sortOrder2 = iGsortOrder != iGSortOrder.Ascending ? (iGsortOrder == iGSortOrder.Descending || sortOrder1 == iGSortOrder.None ? iGSortOrder.Ascending : sortOrder1) : iGSortOrder.Descending;
              if (flag2)
              {
                this.SetGroupObjPropsFromLastGroupObj();
                for (int colOrder2 = colOrder1; colOrder2 < colOrder1 + colCount; ++colOrder2)
                {
                  int colIndex = this.GetColIndex(colOrder2);
                  if (this.fLastGroupObject != null && this.fLastGroupObject.fParams[colIndex].SortType != iGSortType.None)
                    this.fGroupObject.fParams[colIndex].SortOrder = sortOrder2;
                }
              }
              this.DoDefaultSortInternal(colOrder1, colCount, modifierKeys, sortOrder2, !flag2);
              if (flag2)
                this.Group();
            }
          }
          this.GridToolTipInitFromMouseData();
        }
        else if (this.fMouseData.IsEmpty)
          return;
      }
      this.fMouseData.State = iGControlState.Hot;
      this.fMouseData.Button = button;
      this.UpdateColHdrDrawnHot();
      if (button != MouseButtons.Left)
        return;
      this.InvalidateMouseDataCellOnPressChangedIfRequired();
    }

    private void ProcessHeaderDoubleClick()
    {
      if (this.Cursor == iGrid.fCursorColResize)
      {
        iGMouseEventsData fMouseData = this.fMouseData;
        for (int index = 0; index < fMouseData.ColCount; ++index)
        {
          int colIndex = this.fColIdxFromOrd[fMouseData.ColOrder + index];
          if (this.fColDatas[colIndex].AllowSizing && this.DoColDividerDoubleClick(fMouseData.RowIndex, fMouseData.ColOrder + index))
          {
            this.DoColWidthStartChange(this.fColDatas[colIndex].Width);
            this.AutoWidthCol(colIndex, false, 0, this.fRowCount, true);
            this.DoColWidthEndChange(this.fColDatas[colIndex].Width);
          }
        }
        this.EmptyMouse();
      }
      else
        this.DoColHdrDoubleClick();
    }

    private iGColHdrKind GetColHdrKindFromMouseData()
    {
      if (this.fMouseData.IsHeaderExtraCell)
        return iGColHdrKind.Extra;
      if (this.fMouseData.IsHeaderRowHdr)
        return iGColHdrKind.RowHdr;
      return this.fMouseData.ColOrder == 0 ? iGColHdrKind.RowText : iGColHdrKind.Normal;
    }

    private int GetColIndexOfColHdr(bool isExtraCell, bool isRowHdr, int rowIndex, int colOrder)
    {
      if (isExtraCell | isRowHdr)
        return 0;
      return this.GetColIndexOfMergedColHdrs(rowIndex, colOrder);
    }

    private int GetColIndexOfColHdrFromMouseData()
    {
      return this.GetColIndexOfColHdr(this.fMouseData.IsHeaderExtraCell, this.fMouseData.IsHeaderRowHdr, this.fMouseData.RowIndex, this.fMouseData.ColOrder);
    }

    private iGFooterCellKind GetFooterCellKindFromMouseData()
    {
      if (this.fMouseData.IsFooterExtraCell)
        return iGFooterCellKind.Extra;
      return this.fMouseData.IsFooterRowHdr ? iGFooterCellKind.RowHdr : iGFooterCellKind.Normal;
    }

    private int GetColIndexOfFooterCell(bool isExtraBand, bool isRowHdrBand, int rowIndex, int colOrder)
    {
      if (isExtraBand | isRowHdrBand)
        return 0;
      return this.GetColIndexOfMergedFooterCells(rowIndex, colOrder);
    }

    private int GetColIndexOfFooterCellFromMouseData()
    {
      return this.GetColIndexOfFooterCell(this.fMouseData.IsFooterExtraCell, this.fMouseData.IsFooterRowHdr, this.fMouseData.RowIndex, this.fMouseData.ColOrder);
    }

    /// <summary>Determines whether the specified point is over the iGrid header.</summary>
    /// <param name="x">The x-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="y">The y-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <returns>A Boolean value that indicates whether the specified point is over the iGrid header.</returns>
    public bool IsPointOverHeader(int x, int y)
    {
      return this.GetHeaderAreaBounds().Contains(x, y);
    }

    /// <summary>Determines whether the specified point is over the iGrid footer.</summary>
    /// <param name="x">The x-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="y">The y-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <returns>A Boolean value that indicates whether the specified point is over the iGrid footer.</returns>
    public bool IsPointOverFooter(int x, int y)
    {
      return this.GetFooterAreaBounds().Contains(x, y);
    }

    private void ColHdrMouseMoveCheckFrozenColsAndColWidth(bool rightToLeft, int mouseX, ref int resizeOffset, ref int colOrder, ref int x, ref int width, ref bool isLastVisibleCol)
    {
      int borderSize = this.GetBorderSize();
      int num1 = this.fRowHeader.EffectiveWidth();
      int num2 = !rightToLeft ? this.fFrozenColsWidth + borderSize + num1 : this.Width - this.fFrozenColsWidth - borderSize - num1;
      int num3 = width;
      bool flag = false;
      if (this.fFrozenVisibleColCount > 0 && colOrder >= this.fFrozenColCount)
      {
        if (rightToLeft)
        {
          if (x + width > num2)
          {
            flag = true;
            num3 = num2 - x;
          }
        }
        else if (x < num2)
        {
          flag = true;
          num3 -= num2 - x;
        }
      }
      if (num3 < 28)
      {
        resizeOffset = (num3 - 12) / 2;
        if (resizeOffset < 0)
          resizeOffset = 0;
      }
      if (!flag || !(!rightToLeft ? mouseX < num2 + resizeOffset : mouseX >= num2 - resizeOffset))
        return;
      int fFrozenColCount = this.fFrozenColCount;
      while (fFrozenColCount <= colOrder && !this.IsColVisible(this.fColIdxFromOrd[fFrozenColCount]))
        ++fFrozenColCount;
      colOrder = fFrozenColCount;
      x = num2;
      width = 0;
      isLastVisibleCol = false;
    }

    private bool ColHdrMouseMoveCheckAndAdjustForResizing(bool rightToLeft, int resizeOffset, int mouseX, int rowIndex, ref int colOrder, ref int colCount, ref int x, ref int width, bool isLastVisibleCol)
    {
      bool flag = !rightToLeft ? isLastVisibleCol && mouseX >= x + width : isLastVisibleCol && mouseX < x;
      if (this.IsPointOverNearResizeArea(mouseX, x, width, resizeOffset, rightToLeft) && !flag)
      {
        for (int colOrder1 = colOrder - 1; colOrder1 >= 0; --colOrder1)
        {
          int colIndex = this.fColIdxFromOrd[colOrder1];
          iGColData fColData = this.fColDatas[colIndex];
          if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
          {
            colOrder = colOrder1;
            int width1 = fColData.Width;
            if (this.IsFirstVisibleCol(colOrder1))
              width1 += this.GetGroupLevelsExtraWidth();
            x = !rightToLeft ? x - width1 : x + width;
            width = width1;
            colCount = 1;
            this.Span__GetMergedCellBoundsHorz(iGGridSection.Header, rowIndex, ref colOrder, ref colCount, ref x, ref width, rightToLeft);
            return true;
          }
        }
        return false;
      }
      return (!isLastVisibleCol || !this.fAutoResizeCols) && this.IsPointOverFarResizeArea(mouseX, x, width, resizeOffset, rightToLeft);
    }

    private int GetFirstVisibleColOrder()
    {
      for (int colDrawOrder = 0; colDrawOrder < this.fColCount; ++colDrawOrder)
      {
        int colOrder = this.DrawColOrderToColOrder(colDrawOrder);
        if (this.IsColVisible(this.fColIdxFromOrd[colOrder]))
          return colOrder;
      }
      return -1;
    }

    private bool IsFirstVisibleCol(int colOrder)
    {
      return this.GetFirstVisibleColOrder() == colOrder;
    }

    private bool IsPointOverNearResizeArea(int pointX, int x, int width, int resizeOffset, bool rightToLeft)
    {
      if (rightToLeft)
        return pointX >= x + width - resizeOffset;
      return pointX < x + resizeOffset;
    }

    private bool IsPointOverFarResizeArea(int pointX, int x, int width, int resizeOffset, bool rightToLeft)
    {
      if (rightToLeft)
        return pointX < x + resizeOffset;
      return pointX >= x + width - resizeOffset;
    }

    private bool StopHeaderAction(bool apply)
    {
      if (this.fIsColResizing)
      {
        this.DoStopHeaderActionColResize(apply);
        if (!this.fMouseData.IsEmpty)
          this.GridToolTipInitFromMouseData();
        return true;
      }
      if (!this.IsColMoving())
        return false;
      this.DoStopHeaderActionColMove(apply);
      return true;
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.FooterCellMouseMove" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGFooterCellMouseMoveEventArgs" /> that contains the event data.</param>
    protected virtual void OnFooterCellMouseMove(iGFooterCellMouseMoveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.FooterCellMouseMove == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.FooterCellMouseMove((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.FooterCellMouseDown" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGFooterCellMouseDownEventArgs" /> that contains the event data.</param>
    protected virtual void OnFooterCellMouseDown(iGFooterCellMouseDownEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.FooterCellMouseDown == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.FooterCellMouseDown((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.FooterCellMouseUp" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGFooterCellMouseUpEventArgs" /> that contains the event data.</param>
    protected virtual void OnFooterCellMouseUp(iGFooterCellMouseUpEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.FooterCellMouseUp == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.FooterCellMouseUp((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.FooterCellMouseEnter" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGFooterCellMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnFooterCellMouseEnter(iGFooterCellMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.FooterCellMouseEnter == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.FooterCellMouseEnter((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.FooterCellMouseLeave" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGFooterCellMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnFooterCellMouseLeave(iGFooterCellMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.FooterCellMouseLeave == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.FooterCellMouseLeave((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.FooterCellClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGFooterCellClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnFooterCellClick(iGFooterCellClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.FooterCellClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.FooterCellClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.FooterCellDoubleClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGFooterCellDoubleClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnFooterCellDoubleClick(iGFooterCellDoubleClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.FooterCellDoubleClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.FooterCellDoubleClick((object) this, e);
    }

    private void DoFooterCellMouseMove(MouseButtons button)
    {
      this.OnFooterCellMouseMove(new iGFooterCellMouseMoveEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfFooterCellFromMouseData() - 1, this.GetFooterCellKindFromMouseData(), button, this.fMouseData.Bounds, this.fMouseData.MousePos, Control.ModifierKeys));
    }

    private void DoFooterCellMouseDown()
    {
      this.OnFooterCellMouseDown(new iGFooterCellMouseDownEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfFooterCellFromMouseData() - 1, this.GetFooterCellKindFromMouseData(), this.fMouseData.Button, this.fMouseData.Bounds, this.fMouseData.MousePos, Control.ModifierKeys));
    }

    private void DoFooterCellMouseUp()
    {
      this.OnFooterCellMouseUp(new iGFooterCellMouseUpEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfFooterCellFromMouseData() - 1, this.GetFooterCellKindFromMouseData(), this.fMouseData.Button, this.fMouseData.Bounds, this.fMouseData.MousePos, Control.ModifierKeys));
    }

    private void DoFooterCellMouseLeaveWrapper()
    {
      this.DoFooterCellMouseLeave();
      this.GridToolTipClear();
    }

    private void DoFooterCellMouseLeave()
    {
      this.OnFooterCellMouseLeave(new iGFooterCellMouseEnterLeaveEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfFooterCellFromMouseData() - 1, this.GetFooterCellKindFromMouseData(), this.fMouseData.Bounds));
    }

    private void DoFooterCellMouseEnter()
    {
      this.OnFooterCellMouseEnter(new iGFooterCellMouseEnterLeaveEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfFooterCellFromMouseData() - 1, this.GetFooterCellKindFromMouseData(), this.fMouseData.Bounds));
    }

    private void DoFooterCellClick(Keys modifierKeys)
    {
      this.OnFooterCellClick(new iGFooterCellClickEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfFooterCellFromMouseData() - 1, this.GetFooterCellKindFromMouseData(), this.fMouseData.Bounds, modifierKeys));
    }

    private void DoFooterCellDoubleClick()
    {
      this.OnFooterCellDoubleClick(new iGFooterCellDoubleClickEventArgs(this.fMouseData.RowIndex, this.GetColIndexOfFooterCellFromMouseData() - 1, this.GetFooterCellKindFromMouseData(), this.fMouseData.Bounds));
    }

    private void AutoScrollMiddleButtonUp(int x, int y)
    {
      if (this.fCursor == (Cursor) null)
      {
        this.StartAutoScrollOnMiddleButtonUp(x, y);
      }
      else
      {
        this.StopAutoScroll();
        this.ProcessMouseMove(x, y, Control.MouseButtons);
      }
    }

    private void StartAutoScrollOnMiddleButtonUp(int x, int y)
    {
      this.fAutoScrollSetCaptureTimer = new Timer();
      this.fAutoScrollSetCaptureTimer.Interval = 1;
      this.fAutoScrollSetCaptureTimer.Tick += new EventHandler(this.fTimerAutoScrollSetCapture_Tick);
      this.fAutoScrollSetCaptureTimer.Start();
      this.fMouseData.State = iGControlState.Normal;
      this.fMouseData.Button = MouseButtons.None;
      this.StartAutoScrollAct(x, y);
    }

    private void StartAutoScrollOnMouseDown(int x, int y, MouseButtons button)
    {
      iGAutoScrollDirections scrollDirections = this.GetAutoScrollDirections();
      if (scrollDirections == iGAutoScrollDirections.None)
        return;
      this.fMouseData = new iGMouseEventsData(0, 0, 0, 0, iGMouseArea.None, iGControlState.Pressed, Rectangle.Empty, new Point(x, y), (object) new iGAutoScrollData(scrollDirections, 0, 0), false, iGElemControl.None, button);
    }

    private iGAutoScrollDirections GetAutoScrollDirections()
    {
      iGAutoScrollDirections scrollDirections = iGAutoScrollDirections.None;
      if (this.CanScrollVert())
        scrollDirections |= iGAutoScrollDirections.Vertical;
      if (this.CanScrollHorz())
        scrollDirections |= iGAutoScrollDirections.Horizontal;
      return scrollDirections;
    }

    private void AutoScroll_OnScrollBarMouseDown(object sender, MouseEventArgs e)
    {
      this.EmptyMouse();
      if (this.Focused || this.fDoNotFocusOnMouseDown)
        return;
      this.Focus();
    }

    private void AutoScroll_OnScrollBarMouseMove(object sender, MouseEventArgs e)
    {
      if (!this.IsAutoScroll())
        return;
      Point p = new Point(e.X, e.Y);
      Point client = this.PointToClient(((Control) sender).PointToScreen(p));
      this.ProcessMouseMove(client.X, client.Y, Control.MouseButtons);
    }

    private void AutoScrollMouseMove(int x, int y)
    {
      if (this.fCursor == (Cursor) null)
      {
        if (Math.Abs(x - this.fMouseData.MousePos.X) < 2 && Math.Abs(y - this.fMouseData.MousePos.Y) < 2)
          return;
        this.StartAutoScrollAct(x, y);
      }
      this.SetAutoScrollCursor(x, y);
    }

    private void StartAutoScrollAct(int x, int y)
    {
      using (Graphics graphics = this.CreateGraphics())
        this.DrawAutoScrollBitmap(graphics);
      this.SetAutoScrollCursor(x, y);
      this.StartAutoScrollTimer(new EventHandler(this.AutoScrollTimerMiddleButton_Tick));
    }

    private void StopAutoScrollTimer()
    {
      if (this.fAutoScrollTimer == null)
        return;
      this.fAutoScrollTimer.Stop();
      this.fAutoScrollTimer.Dispose();
      this.fAutoScrollTimer = (Timer) null;
    }

    private void StartAutoScrollTimer(EventHandler tick)
    {
      this.fAutoScrollTimer = new Timer();
      this.fAutoScrollTimer.Tick += tick;
      this.fAutoScrollTimer.Interval = 50;
      this.fAutoScrollTimer.Start();
    }

    private void AutoScrollTimerMiddleButton_Tick(object sender, EventArgs e)
    {
      if (!this.IsAutoScroll())
      {
        this.StopAutoScrollTimer();
      }
      else
      {
        Point client = this.PointToClient(Control.MousePosition);
        if (!this.ClientRectangle.Contains(client) && (this.fMouseData.State != iGControlState.Pressed || this.fMouseData.Button != MouseButtons.Middle) && !this.fIsAutoScrollCapture)
          return;
        if (this.fIsAutoScrollCapture)
        {
          int num = (int) this.AdjustAutoScrollData(client.X, client.Y);
        }
        iGAutoScrollData tag = (iGAutoScrollData) this.fMouseData.Tag;
        this.AutoScrollScrollBars(tag.DX, tag.DY);
      }
    }

    private void AutoScrollScrollBars(int dx, int dy)
    {
      this.SetHScrollBarValue(this.fHScrollBar.Value + 3 * (Math.Abs(dx / 20) + 1) * Math.Sign(dx), true);
      this.SetVScrollBarValue(this.fVScrollBar.Value + 3 * (Math.Abs(dy / 20) + 1) * Math.Sign(dy), true);
    }

    private void DrawAutoScrollBitmap(Graphics g)
    {
      Bitmap scrollCenterBitmap = iGrid.GetAutoScrollCenterBitmap(((iGAutoScrollData) this.fMouseData.Tag).Direction);
      g.DrawImage((Image) scrollCenterBitmap, new Rectangle(this.fMouseData.MousePos.X - scrollCenterBitmap.Width / 2, this.fMouseData.MousePos.Y - scrollCenterBitmap.Height / 2, scrollCenterBitmap.Width, scrollCenterBitmap.Height), 0, 0, scrollCenterBitmap.Width, scrollCenterBitmap.Height, GraphicsUnit.Pixel, this.GetImageAttributes(0.2f));
    }

    private void StopAutoScroll()
    {
      Size size = iGrid.GetAutoScrollCenterBitmap(((iGAutoScrollData) this.fMouseData.Tag).Direction).Size;
      this.Invalidate(new Rectangle(this.fMouseData.MousePos.X - size.Width / 2, this.fMouseData.MousePos.Y - size.Height / 2, size.Width, size.Height));
      this.fMouseData = iGMouseEventsData.Empty;
      this.SetCursor((Cursor) null);
      this.fIsAutoScrollCapture = false;
    }

    private iGAutoScrollMoveDirection AdjustAutoScrollData(int x, int y)
    {
      iGAutoScrollData tag = (iGAutoScrollData) this.fMouseData.Tag;
      Size size = iGrid.GetAutoScrollCenterBitmap(tag.Direction).Size;
      Point mousePos = this.fMouseData.MousePos;
      mousePos.Offset(-size.Width / 2, -size.Height / 2);
      int scrollMoveDirection = (int) this.GetAutoScrollMoveDirection(x, y, new Rectangle(mousePos, size), tag.Direction, out tag.DX, out tag.DY);
      this.fMouseData.Tag = (object) tag;
      return (iGAutoScrollMoveDirection) scrollMoveDirection;
    }

    private void SetAutoScrollCursor(int x, int y)
    {
      iGAutoScrollMoveDirection scrollMoveDirection = this.AdjustAutoScrollData(x, y);
      iGAutoScrollData tag = (iGAutoScrollData) this.fMouseData.Tag;
      if (scrollMoveDirection == iGAutoScrollMoveDirection.None)
      {
        if ((tag.Direction & iGAutoScrollDirections.Horizontal) != iGAutoScrollDirections.None)
        {
          if ((tag.Direction & iGAutoScrollDirections.Vertical) != iGAutoScrollDirections.None)
            this.SetCursor(Cursors.NoMove2D);
          else
            this.SetCursor(Cursors.NoMoveHoriz);
        }
        else
          this.SetCursor(Cursors.NoMoveVert);
      }
      else if ((scrollMoveDirection & iGAutoScrollMoveDirection.Left) != iGAutoScrollMoveDirection.None)
      {
        if ((scrollMoveDirection & iGAutoScrollMoveDirection.Up) != iGAutoScrollMoveDirection.None)
          this.SetCursor(Cursors.PanNW);
        else if ((scrollMoveDirection & iGAutoScrollMoveDirection.Down) != iGAutoScrollMoveDirection.None)
          this.SetCursor(Cursors.PanSW);
        else
          this.SetCursor(Cursors.PanWest);
      }
      else if ((scrollMoveDirection & iGAutoScrollMoveDirection.Right) != iGAutoScrollMoveDirection.None)
      {
        if ((scrollMoveDirection & iGAutoScrollMoveDirection.Up) != iGAutoScrollMoveDirection.None)
          this.SetCursor(Cursors.PanNE);
        else if ((scrollMoveDirection & iGAutoScrollMoveDirection.Down) != iGAutoScrollMoveDirection.None)
          this.SetCursor(Cursors.PanSE);
        else
          this.SetCursor(Cursors.PanEast);
      }
      else if ((scrollMoveDirection & iGAutoScrollMoveDirection.Up) != iGAutoScrollMoveDirection.None)
        this.SetCursor(Cursors.PanNorth);
      else
        this.SetCursor(Cursors.PanSouth);
    }

    private iGAutoScrollMoveDirection GetAutoScrollMoveDirection(int x, int y, Rectangle center, iGAutoScrollDirections directions, out int dx, out int dy)
    {
      iGAutoScrollMoveDirection scrollMoveDirection = iGAutoScrollMoveDirection.None;
      dx = 0;
      dy = 0;
      if ((directions & iGAutoScrollDirections.Horizontal) != iGAutoScrollDirections.None)
      {
        if (x < center.X)
        {
          scrollMoveDirection |= iGAutoScrollMoveDirection.Left;
          dx = x - center.X;
        }
        else if (x > center.Right)
        {
          scrollMoveDirection |= iGAutoScrollMoveDirection.Right;
          dx = x - center.Right;
        }
      }
      if ((directions & iGAutoScrollDirections.Vertical) != iGAutoScrollDirections.None)
      {
        if (y < center.Y)
        {
          scrollMoveDirection |= iGAutoScrollMoveDirection.Up;
          dy = y - center.Y;
        }
        else if (y > center.Bottom)
        {
          scrollMoveDirection |= iGAutoScrollMoveDirection.Down;
          dy = y - center.Bottom;
        }
      }
      if (this.RightToLeft == RightToLeft.Yes)
        dx = -dx;
      return scrollMoveDirection;
    }

    private static Bitmap GetAutoScrollCenterBitmap(iGAutoScrollDirections directions)
    {
      if ((directions & iGAutoScrollDirections.Horizontal) != iGAutoScrollDirections.None)
      {
        if ((directions & iGAutoScrollDirections.Vertical) != iGAutoScrollDirections.None)
        {
          if (iGrid.fAutoScrollCenterBitmap == null)
          {
            iGrid.fAutoScrollCenterBitmap = new Bitmap(iGrid.GetResourceStream("AutoScrollCenter.bmp"));
            iGrid.fAutoScrollCenterBitmap.MakeTransparent(System.Drawing.Color.White);
          }
          return iGrid.fAutoScrollCenterBitmap;
        }
        if (iGrid.fAutoScrollCenterBitmapHorz == null)
        {
          iGrid.fAutoScrollCenterBitmapHorz = new Bitmap(iGrid.GetResourceStream("AutoScrollCenterHorz.bmp"));
          iGrid.fAutoScrollCenterBitmapHorz.MakeTransparent(System.Drawing.Color.White);
        }
        return iGrid.fAutoScrollCenterBitmapHorz;
      }
      if (iGrid.fAutoScrollCenterBitmapVert == null)
      {
        iGrid.fAutoScrollCenterBitmapVert = new Bitmap(iGrid.GetResourceStream("AutoScrollCenterVert.bmp"));
        iGrid.fAutoScrollCenterBitmapVert.MakeTransparent(System.Drawing.Color.White);
      }
      return iGrid.fAutoScrollCenterBitmapVert;
    }

    private bool IsAutoScroll()
    {
      return this.fMouseData.Tag is iGAutoScrollData;
    }

    private void fTimerAutoScrollSetCapture_Tick(object sender, EventArgs e)
    {
      if (!this.fAutoScrollSetCaptureTimer.Enabled)
        return;
      this.fAutoScrollSetCaptureTimer.Stop();
      this.fAutoScrollSetCaptureTimer.Dispose();
      this.Capture = true;
      this.fIsAutoScrollCapture = this.Capture;
    }

    private void AutoScrollOnCaptureChanged(ref Message m)
    {
      if (!this.fIsAutoScrollCapture || !this.StopAnyMouseAction(false))
        return;
      this.ProcessMouseMove();
    }

    /// <summary>Determines whether the specified point is over iGrid's row header column.</summary>
    /// <param name="x">The x-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="y">The y-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <returns>A Boolean value that indicates whether the specified point is over iGrid's row header column.</returns>
    public bool IsPointOverRowHeader(int x, int y)
    {
      return this.GetRowHeaderAreaBounds().Contains(x, y);
    }

    /// <summary>Determines whether the specified point is over a row's level indent.</summary>
    /// <param name="x">The x-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="y">The y-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="rowIndex">The index of the row that contains the specified point if the point is inside its level indent area.</param>
    /// <returns>A Boolean value that indicates whether the specified point is over the level indent area that belongs a row.</returns>
    public bool IsPointOverRowLevelArea(int x, int y, out int rowIndex)
    {
      rowIndex = -1;
      if (this.RightToLeft == RightToLeft.Yes)
        x = this.Width - x - 1;
      int borderSize = this.GetBorderSize();
      int num = this.fRowHeader.EffectiveWidth();
      int rowIndex1;
      int rowY;
      int rowHeight;
      if (x <= borderSize + num || !this.GetRowFromY(y, out rowIndex1, out rowY, out rowHeight))
        return false;
      iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
      if (x >= rowDataInternal.Level * this.fLevelIndent + borderSize + num)
        return false;
      rowIndex = rowIndex1;
      return true;
    }

    private void ProcessRowHdrMouseMove(int x, int y, MouseButtons button)
    {
      if (!this.RaiseMouseLeaveEventForPreviousMouseArea(iGMouseArea.RowHdr))
        return;
      int rowIndex;
      int rowY;
      int rowHeight;
      if (this.GetRowFromY(y, out rowIndex, out rowY, out rowHeight))
      {
        iGMouseEventsData gmouseEventsData = new iGMouseEventsData(rowIndex, 1, -1, 0, iGMouseArea.RowHdr, this.IsAnyDropDownActive() ? iGControlState.Normal : iGControlState.Hot, new Rectangle(this.GetRowHeaderAreaLeft(), rowY, this.fRowHeader.EffectiveWidth(), rowHeight), new Point(x, y), (object) null, false, iGElemControl.None, button);
        if (this.fMouseData.IsEmpty || this.fMouseData.Area != iGMouseArea.RowHdr || this.fMouseData.RowIndex != rowIndex)
        {
          if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.RowHdr)
          {
            this.DoRowHdrMouseLeave();
            if (this.fMouseData.IsEmpty)
              return;
          }
          this.fMouseData = gmouseEventsData;
          this.DoRowHdrMouseEnter();
          if (this.fMouseData.IsEmpty)
            return;
        }
        else
          this.fMouseData = gmouseEventsData;
        this.DoRowHdrMouseMove(button);
        int num = this.fMouseData.IsEmpty ? 1 : 0;
      }
      else
      {
        if (this.fMouseData.IsEmpty)
          return;
        if (this.fMouseData.Area == iGMouseArea.RowHdr)
          this.DoRowHdrMouseLeave();
        this.fMouseData = iGMouseEventsData.Empty;
      }
    }

    private void ProcessRowHdrMouseDown(int x, int y, MouseButtons button)
    {
      this.fMouseData.MousePos = new Point(x, y);
      this.fMouseData.MouseDownMousePos = this.fMouseData.MousePos;
      this.fMouseData.State = iGControlState.Pressed;
      this.fMouseData.Button = button;
      this.InvalidateMouseDataCellOnPressChangedIfRequired();
      Keys modifierKeys = Control.ModifierKeys;
      if (this.fMouseData.IsEmpty || !this.DoRowHdrMouseDown(button, modifierKeys))
        return;
      this.ChangeSelectionAndCurCellOnMouseDownInRowHeader(modifierKeys);
    }

    private void ProcessRowHdrMouseMovePressed(int x, int y, MouseButtons button)
    {
      this.fMouseData.MousePos = new Point(x, y);
      int rowIndex;
      int colOrder;
      Rectangle bounds;
      if (this.fRowMode && (((this.fMouseData.Button != MouseButtons.Left ? 0 : (this.fPressedMouseMoveMode == iGPressedMouseMoveMode.Selection ? 1 : 0)) & (this.fSelectionMode == iGSelectionMode.MultiExtended ? (true ? 1 : 0) : (this.fSelectionMode == iGSelectionMode.MultiSimple ? 1 : 0)) & (this.CanSelectRow(this.fMouseData.RowIndex, false) ? 1 : 0)) != 0 && (!this.GetCellAtPointForMousePressedSelection(x, y, this.fMouseData.RowIndex, 0, out rowIndex, out colOrder, out bounds) || rowIndex != this.fMouseData.RowIndex)))
      {
        Rectangle startBounds = new Rectangle(0, this.fMouseData.Bounds.Y, this.Width, this.fMouseData.Bounds.Height);
        if (this.StartMousePressedSelection(x, y, this.fMouseData.RowIndex, 0, startBounds, rowIndex, colOrder, bounds, button))
          return;
      }
      if (this.fMouseData.IsEmpty)
        return;
      this.DoRowHdrMouseMove(button);
    }

    private void ProcessRowHdrMouseUp(int x, int y, MouseButtons button)
    {
      if (button == MouseButtons.Left && this.StopAnyMouseAction(true))
      {
        this.ProcessMouseMove(x, y, Control.MouseButtons);
      }
      else
      {
        Keys modifierKeys = Control.ModifierKeys;
        bool flag = this.DoRowHdrMouseUp(button, modifierKeys);
        if (this.fMouseData.IsEmpty)
          return;
        if (flag)
          this.ChangeSelectionOnRowHdrMouseUp();
        if (this.fMouseData.IsEmpty)
          return;
        if (this.fMouseData.State == iGControlState.Pressed && button == MouseButtons.Left && this.fMouseData.Button == MouseButtons.Left && this.GetRowHdrBounds(this.fMouseData.RowIndex).Contains(x, y))
        {
          this.DoRowHdrClick(modifierKeys);
          if (this.fMouseData.IsEmpty)
            return;
        }
        this.fMouseData.State = iGControlState.Normal;
        this.fMouseData.Button = MouseButtons.None;
        this.InvalidateMouseDataCellOnPressChangedIfRequired();
        this.ProcessMouseMove();
      }
    }

    private void ProcessRowHdrDoubleClick()
    {
      this.DoRowHdrDoubleClick();
      int num = this.fMouseData.IsEmpty ? 1 : 0;
    }

    private void DoRowHdrMouseLeave()
    {
      this.OnRowHdrMouseLeave(new iGRowHdrMouseEnterLeaveEventArgs(this.fMouseData.RowIndex, this.fMouseData.Bounds));
      this.InvalidateMouseDataCellOnHotChangedIfRequired();
    }

    private void DoRowHdrMouseEnter()
    {
      this.OnRowHdrMouseEnter(new iGRowHdrMouseEnterLeaveEventArgs(this.fMouseData.RowIndex, this.fMouseData.Bounds));
      this.InvalidateMouseDataCellOnHotChangedIfRequired();
    }

    private void DoRowHdrMouseMove(MouseButtons button)
    {
      this.OnRowHdrMouseMove(new iGRowHdrMouseMoveEventArgs(this.fMouseData.RowIndex, button, this.fMouseData.Bounds, this.fMouseData.MousePos));
    }

    private bool DoRowHdrMouseDown(MouseButtons buttons, Keys modifierKeys)
    {
      iGRowHdrMouseDownEventArgs e = new iGRowHdrMouseDownEventArgs(this.fMouseData.RowIndex, buttons, this.fMouseData.Bounds, this.fMouseData.MousePos, modifierKeys);
      this.OnRowHdrMouseDown(e);
      return e.DoDefault;
    }

    private bool DoRowHdrMouseUp(MouseButtons button, Keys modifierKeys)
    {
      iGRowHdrMouseUpEventArgs e = new iGRowHdrMouseUpEventArgs(this.fMouseData.RowIndex, button, this.fMouseData.Bounds, this.fMouseData.MousePos, modifierKeys);
      this.OnRowHdrMouseUp(e);
      return e.DoDefault;
    }

    private void DoRowHdrClick(Keys modifierKeys)
    {
      this.OnRowHdrClick(new iGRowHdrClickEventArgs(this.fMouseData.RowIndex, this.fMouseData.Bounds, modifierKeys));
    }

    private void DoRowHdrDoubleClick()
    {
      this.OnRowHdrDoubleClick(new iGRowHdrDoubleClickEventArgs(this.fMouseData.RowIndex, this.fMouseData.Bounds));
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHdrDoubleClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHdrDoubleClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHdrDoubleClick(iGRowHdrDoubleClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHdrDoubleClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHdrDoubleClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHdrMouseDown" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHdrMouseDownEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHdrMouseDown(iGRowHdrMouseDownEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHdrMouseDown == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHdrMouseDown((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHdrMouseUp" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHdrMouseUpEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHdrMouseUp(iGRowHdrMouseUpEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHdrMouseUp == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHdrMouseUp((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHdrMouseEnter" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHdrMouseEnterLeaveEventArgs" />  that contains the event data.</param>
    protected virtual void OnRowHdrMouseEnter(iGRowHdrMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHdrMouseEnter == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHdrMouseEnter((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHdrMouseLeave" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHdrMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHdrMouseLeave(iGRowHdrMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHdrMouseLeave == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHdrMouseLeave((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHdrMouseMove" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHdrMouseMoveEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHdrMouseMove(iGRowHdrMouseMoveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHdrMouseMove == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHdrMouseMove((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHdrClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHdrClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHdrClick(iGRowHdrClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHdrClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHdrClick((object) this, e);
    }

    private void ProcessRowResizeAreaMouseMove(int x, int y, MouseButtons button, iGrid.RowToResizeInfo rowToResizeInfo)
    {
      if (!this.RaiseMouseLeaveEventForPreviousMouseArea(iGMouseArea.RowResize))
        return;
      bool isOverRowHdr = this.GetRowHeaderAreaBounds().Contains(x, y);
      if (this.fMouseData.IsEmpty || this.fMouseData.Area != iGMouseArea.RowResize || this.fMouseData.RowIndex != rowToResizeInfo.Index)
      {
        if (!this.fMouseData.IsEmpty && this.fMouseData.Area == iGMouseArea.RowResize)
          this.DoRowResizeAreaMouseLeave();
        this.fMouseData = new iGMouseEventsData(rowToResizeInfo.Index, 1, -1, 0, iGMouseArea.RowResize, this.IsAnyDropDownActive() ? iGControlState.Normal : iGControlState.Hot, new Rectangle(this.GetRowHeaderAreaLeft(), rowToResizeInfo.Y, this.fRowHeader.EffectiveWidth(), rowToResizeInfo.Height), new Point(x, y), (object) new iGResizeRowData(0, 0, 0, rowToResizeInfo.MinHeight, rowToResizeInfo.MaxHeight, isOverRowHdr), false, iGElemControl.None, button);
        this.DoRowResizeMouseEnter();
      }
      else
      {
        iGResizeRowData tag = (iGResizeRowData) this.fMouseData.Tag;
        if (tag.IsOverRowHdr != isOverRowHdr)
        {
          tag.IsOverRowHdr = isOverRowHdr;
          this.fMouseData.Tag = (object) tag;
          this.InvalidateMouseDataCellOnHotChangedIfRequired();
        }
        this.fMouseData.MousePos = new Point(x, y);
      }
      if (this.IsAnyDropDownActive())
        return;
      this.SetCursor(iGrid.fCursorRowResize);
    }

    private bool GetRowToResize(int x, int y, out iGrid.RowToResizeInfo rowToResizeInfo)
    {
      rowToResizeInfo = new iGrid.RowToResizeInfo();
      rowToResizeInfo.Index = -1;
      rowToResizeInfo.Y = -1;
      rowToResizeInfo.Height = -1;
      rowToResizeInfo.MinHeight = -1;
      rowToResizeInfo.MaxHeight = -1;
      if (this.fRowResizeMode == iGRowResizeMode.NotAllowed)
        return false;
      if (this.fRowResizeMode == iGRowResizeMode.RowHdr)
      {
        if (!this.GetRowHeaderAreaBounds().Contains(x, y))
          return false;
      }
      else if (this.fRowResizeMode == iGRowResizeMode.RowHdrAndFrozenCols)
      {
        if (!this.GetRowHeaderAreaBounds().Contains(x, y) && !this.GetFrozenColsAreaBounds().Contains(x, y))
          return false;
      }
      else if (this.fRowResizeMode == iGRowResizeMode.RowHdrAndAllCols && !this.GetRowHeaderAreaBounds().Contains(x, y))
      {
        int num = this.GetCellsAreaLeft_NoRightToLeft();
        int groupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea;
        if (this.RightToLeft == RightToLeft.Yes)
          num = this.Width - num - groupObjectLevelArea;
        if (x < num || x >= num + groupObjectLevelArea)
          return false;
      }
      if (!this.GetCellsAndRowHeaderAreaBounds(true).Contains(x, y))
        return false;
      int num1 = 6;
      int num2 = 12;
      if (!this.GetRowFromY(y, out rowToResizeInfo.Index, out rowToResizeInfo.Y, out rowToResizeInfo.Height))
      {
        if (this.fLastVisibleRowIndex < 0)
          return false;
        int y1 = this.RowToY(this.fLastVisibleRowIndex);
        int height = this.GetRowDataInternal(this.fLastVisibleRowIndex).Height;
        if (y >= y1 + height + num1 / 2)
          return false;
        rowToResizeInfo.Index = this.fLastVisibleRowIndex;
        rowToResizeInfo.Y = y1;
        rowToResizeInfo.Height = height;
      }
      else
      {
        int num3 = num1;
        if (rowToResizeInfo.Height < num2)
        {
          num3 -= num2 - rowToResizeInfo.Height;
          if (num3 < 0)
            num3 = 0;
        }
        if (!this.IsRowFirstVisible(rowToResizeInfo.Index) && y >= rowToResizeInfo.Y - num3 / 2 && y < rowToResizeInfo.Y + num3 / 2)
        {
          rowToResizeInfo.Index = this.GetPrevVisibleRow(rowToResizeInfo.Index);
          rowToResizeInfo.Height = this.GetRowDataInternal(rowToResizeInfo.Index).Height;
          rowToResizeInfo.Y -= rowToResizeInfo.Height;
        }
        else if (y < rowToResizeInfo.Y + rowToResizeInfo.Height - num3 / 2 || y >= rowToResizeInfo.Y + rowToResizeInfo.Height + num3 / 2)
        {
          rowToResizeInfo.Index = -1;
          rowToResizeInfo.Y = -1;
          rowToResizeInfo.Height = -1;
          return false;
        }
      }
      return this.DoRequestRowResize(rowToResizeInfo.Index, out rowToResizeInfo.MinHeight, out rowToResizeInfo.MaxHeight);
    }

    private int GetPrevVisibleRow(int rowIndex)
    {
      this.CheckRowIndex(rowIndex);
      for (--rowIndex; rowIndex >= 0; --rowIndex)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          return rowIndex;
      }
      return -1;
    }

    private void ProcessRowResizeAreaMouseDown(int x, int y, MouseButtons button)
    {
      if (button != MouseButtons.Left)
        return;
      this.fMouseData.State = iGControlState.Pressed;
      this.fMouseData.Button = button;
      this.fMouseData.MousePos = new Point(x, y);
      this.fMouseData.MouseDownMousePos = this.fMouseData.MousePos;
      iGResizeRowData tag = (iGResizeRowData) this.fMouseData.Tag;
      tag.BaseRowHeight = tag.NewRowHeight = this.GetRowDataInternal(this.fMouseData.RowIndex).Height;
      tag.BaseVScrollBarValue = this.fVScrollBar.Value;
      this.fMouseData.Tag = (object) tag;
      if (this.fImmediateRowResizing)
        return;
      this.DrawHResizeLine(this.fMouseData.Bounds.Y + tag.BaseRowHeight - 1);
    }

    private void ProcessRowResizeAreaMouseMovePressed(int x, int y)
    {
      iGResizeRowData tag = (iGResizeRowData) this.fMouseData.Tag;
      if (!this.fIsRowResizing)
      {
        this.DoRowHeightStartChange(tag.BaseRowHeight);
        this.fIsRowResizing = true;
      }
      int height = tag.BaseRowHeight + (y - this.fMouseData.MouseDownMousePos.Y);
      if (height < 0)
        height = 0;
      if (tag.MaxHeight >= 0 && height > tag.MaxHeight)
        height = tag.MaxHeight;
      if (tag.MinHeight >= 0 && height < tag.MinHeight)
        height = tag.MinHeight;
      if (this.fImmediateRowResizing)
      {
        int num1 = tag.BaseVScrollBarValue - this.fVScrollBar.Value;
        if (num1 > 0)
        {
          int num2 = height - this.GetRowDataInternal(this.fMouseData.RowIndex).Height;
          if (num2 > 0)
          {
            int num3 = num2 <= num1 ? num2 : num1;
            tag.BaseVScrollBarValue -= num3;
            this.fMouseData.MouseDownMousePos = new Point(this.fMouseData.MouseDownMousePos.X, this.fMouseData.MouseDownMousePos.Y + num3);
            height -= num3;
          }
        }
        this.SetRowHeight(this.fMouseData.RowIndex, height);
        tag.NewRowHeight = height;
      }
      else if (height != tag.NewRowHeight)
      {
        this.DrawHResizeLine(this.fMouseData.Bounds.Y + tag.NewRowHeight - 1);
        tag.NewRowHeight = height;
        this.DrawHResizeLine(this.fMouseData.Bounds.Y + tag.NewRowHeight - 1);
      }
      this.fMouseData.Tag = (object) tag;
      this.DoRowHeightChanging(height);
    }

    private bool StopResizingRow(bool apply)
    {
      if (!this.fIsRowResizing)
        return false;
      iGResizeRowData tag = (iGResizeRowData) this.fMouseData.Tag;
      if (!this.fImmediateRowResizing)
      {
        this.DrawHResizeLine(this.fMouseData.Bounds.Y + tag.NewRowHeight - 1);
        if (apply)
          this.SetRowHeight(this.fMouseData.RowIndex, tag.NewRowHeight);
      }
      this.fMouseData.State = iGControlState.Normal;
      this.fMouseData.Button = MouseButtons.None;
      this.fMouseData.Bounds = this.GetRowHdrBounds(this.fMouseData.RowIndex);
      this.DoRowHeightEndChange(tag.NewRowHeight);
      this.fIsRowResizing = false;
      return true;
    }

    private void ProcessRowResizeAreaMouseUp(int x, int y, MouseButtons button)
    {
      if (button != MouseButtons.Left || this.StopResizingRow(true))
        return;
      this.fMouseData.State = iGControlState.Normal;
      this.fMouseData.Button = MouseButtons.None;
    }

    private void ProcessRowResizeAreaDoubleClick()
    {
      if (!this.DoRowDividerDoubleClick() || this.fMouseData.IsEmpty)
        return;
      int rowIndex = this.fMouseData.RowIndex;
      int baseRowHeight = ((iGResizeRowData) this.fMouseData.Tag).BaseRowHeight;
      this.EmptyMouse();
      this.DoRowHeightStartChange(baseRowHeight);
      this.DoRowHeightEndChange(this.AutoHeightRow(rowIndex));
    }

    private void DoRowResizeAreaMouseLeave()
    {
      this.InvalidateMouseDataCellOnHotChangedIfRequired();
      this.SetCursor((Cursor) null);
    }

    private void DoRowResizeMouseEnter()
    {
      this.InvalidateMouseDataCellOnHotChangedIfRequired();
    }

    private bool DoRequestRowResize(int rowIndex, out int minHeight, out int maxHeight)
    {
      iGRequestRowResizeEventArgs e = new iGRequestRowResizeEventArgs(rowIndex);
      this.OnRequestRowResize(e);
      minHeight = e.MinHeight;
      maxHeight = e.MaxHeight;
      return e.AllowResizing;
    }

    private void DoRowHeightStartChange(int height)
    {
      this.OnRowHeightStartChange(new iGRowHeightEventArgs(this.fMouseData.RowIndex, height));
    }

    private void DoRowHeightEndChange(int height)
    {
      this.OnRowHeightEndChange(new iGRowHeightEventArgs(this.fMouseData.RowIndex, height));
    }

    private void DoRowHeightChanging(int height)
    {
      this.OnRowHeightChanging(new iGRowHeightEventArgs(this.fMouseData.RowIndex, height));
    }

    private bool DoRowDividerDoubleClick()
    {
      iGRowDividerDoubleClickEventArgs e = new iGRowDividerDoubleClickEventArgs(this.fMouseData.RowIndex);
      this.OnRowDividerDoubleClick(e);
      return e.DoDefault;
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestRowResize" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestRowResizeEventArgs" /> that contains the event data.</param>
    protected virtual void OnRequestRowResize(iGRequestRowResizeEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestRowResize == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestRowResize((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHeightStartChange" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHeightEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHeightStartChange(iGRowHeightEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHeightStartChange == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHeightStartChange((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHeightChanging" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHeightEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHeightChanging(iGRowHeightEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHeightChanging == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHeightChanging((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHeightEndChange" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHeightEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHeightEndChange(iGRowHeightEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHeightEndChange == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHeightEndChange((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowDividerDoubleClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowDividerDoubleClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowDividerDoubleClick(iGRowDividerDoubleClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowDividerDoubleClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowDividerDoubleClick((object) this, e);
    }

    private void ProcessEmptyAreaMouseDown(int x, int y, MouseButtons button)
    {
      int rowIndex;
      if (button != MouseButtons.Left || !this.IsPointOverRowLevelArea(x, y, out rowIndex))
        return;
      this.ChangeSelectionAndCurCellOnMouseDownInLevelArea(rowIndex, Control.ModifierKeys);
    }

    private void ProcessEmptyAreaMouseUp(int x, int y, MouseButtons button)
    {
      int rowIndex;
      if (button != MouseButtons.Left || !this.IsPointOverRowLevelArea(x, y, out rowIndex))
        return;
      this.ChangeSelectionOnLevelAreaMouseUp(rowIndex);
    }

    /// <summary>Gets or sets a value indicating whether a row should be resized immediately as the user is dragging its edge.</summary>
    /// <value>True if the row should be resized immediately; otherwise, False.</value>
    [DefaultValue(true)]
    [Description("Determines whether a row should be resized immediately as the user is dragging the edge of the rows's header.")]
    [Category("Behavior")]
    public bool ImmediateRowResizing
    {
      get
      {
        return this.fImmediateRowResizing;
      }
      set
      {
        this.fImmediateRowResizing = value;
      }
    }

    /// <summary>Gets or sets a value specifying where the user can resize rows: in the row header, the frozen columns and row header, or all the columns and the row header.</summary>
    /// <value>One of the <see cref="T:TenTec.Windows.iGridLib.iGRowResizeMode" /> enumeration members. The default is <see cref="F:TenTec.Windows.iGridLib.iGRowResizeMode.RowHdr" />.</value>
    [DefaultValue(iGRowResizeMode.RowHdr)]
    [Description("Determines the areas of the grid where rows can be resized by using the mouse.")]
    [Category("Behavior")]
    public iGRowResizeMode RowResizeMode
    {
      get
      {
        return this.fRowResizeMode;
      }
      set
      {
        this.fRowResizeMode = value;
      }
    }

    /// <summary>Occurs when a column header is clicked.</summary>
    [Category("Column Header Action")]
    [Description("Occurs when a column header is clicked.")]
    public event iGColHdrClickEventHandler ColHdrClick;

    /// <summary>Occurs when a column header is double-clicked.</summary>
    [Category("Column Header Action")]
    [Description("Occurs when a column header is double-clicked.")]
    public event iGColHdrDoubleClickEventHandler ColHdrDoubleClick;

    /// <summary>Occurs when the mouse pointer is over a column header and a mouse button is pressed.</summary>
    [Category("Column Header Mouse")]
    [Description("Occurs when the mouse pointer is over a column header and a mouse button is pressed. Using this event you can prohibit sorting of a column and indication of the pressed state of the column's header.")]
    public event iGColHdrMouseDownEventHandler ColHdrMouseDown;

    /// <summary>Occurs when the mouse pointer is over a column header and a mouse button is released.</summary>
    [Category("Column Header Mouse")]
    [Description("Occurs when the mouse pointer is over a column header and a mouse button is released.")]
    public event iGColHdrMouseUpEventHandler ColHdrMouseUp;

    /// <summary>Occurs when the mouse pointer enters a column header.</summary>
    [Category("Column Header Mouse")]
    [Description("Occurs when the mouse pointer enters a column header.")]
    public event iGColHdrMouseEnterLeaveEventHandler ColHdrMouseEnter;

    /// <summary>Occurs when the mouse pointer leaves a column header.</summary>
    [Category("Column Header Mouse")]
    [Description("Occurs when the mouse pointer leaves a column header.")]
    public event iGColHdrMouseEnterLeaveEventHandler ColHdrMouseLeave;

    /// <summary>Occurs when the mouse pointer moves over a column header.</summary>
    [Category("Column Header Mouse")]
    [Description("Occurs when the mouse pointer moves over a column header.")]
    public event iGColHdrMouseMoveEventHandler ColHdrMouseMove;

    /// <summary>Occurs when the divider of a column header is double-clicked. The default action is adjusting of the column's width.</summary>
    [Category("Column Header Action")]
    [Description("Occurs when the divider of a column header is double-clicked. The default action is adjusting of the column's width.")]
    public event iGColDividerDoubleClickEventHandler ColDividerDoubleClick;

    /// <summary>Occurs when the user starts column resizing.</summary>
    [Category("Columns")]
    [Description("Occurs when the user starts column resizing.")]
    public event iGColWidthEventHandler ColWidthStartChange;

    /// <summary>Occurs when the user has finished column resizing.</summary>
    [Category("Columns")]
    [Description("Occurs when the user has finished column resizing.")]
    public event iGColWidthEventHandler ColWidthEndChange;

    /// <summary>Occurs while the user resizes a column.</summary>
    [Category("Columns")]
    [Description("Occurs while the user resizes a column.")]
    public event iGColWidthEventHandler ColWidthChanging;

    /// <summary>Occurs when the user starts to drag a column header.</summary>
    [Category("Column Header Action")]
    [Description("Occurs when the user starts to drag a column header.")]
    public event iGColHdrStartDragEventHandler ColHdrStartDrag;

    /// <summary>Occurs when column header dragging has been finished. The default action is column grouping or moving.</summary>
    [Category("Column Header Action")]
    [Description("Occurs when column header dragging has been finished. The default action is column grouping or moving.")]
    public event iGColHdrEndDragEventHandler ColHdrEndDrag;

    /// <summary>Occurs while dragging a column header. Use this event to limit legal positions of the column.</summary>
    [Category("Column Header Action")]
    [Description("Occurs while dragging a column header. Use this event to limit legal positions of the column.")]
    public event iGColHdrEndDragEventHandler ColHdrDragging;

    /// <summary>Occurs when the mouse pointer moves over a footer cell.</summary>
    [Category("Footer Mouse")]
    [Description("Occurs when the mouse pointer moves over a footer cell.")]
    public event iGFooterCellMouseMoveEventHandler FooterCellMouseMove;

    /// <summary>Occurs when the mouse pointer is over the footer area (a footer cell or another part) and a mouse button is pressed.</summary>
    [Category("Footer Mouse")]
    [Description("Occurs when the mouse pointer is over a footer cell and a mouse button is pressed.")]
    public event iGFooterCellMouseDownEventHandler FooterCellMouseDown;

    /// <summary>Occurs when the mouse pointer is over the footer area (a footer cell or another part) and a mouse button is released.</summary>
    [Category("Footer Mouse")]
    [Description("Occurs when the mouse pointer is over a footer cell and a mouse button is released.")]
    public event iGFooterCellMouseUpEventHandler FooterCellMouseUp;

    /// <summary>Occurs when the mouse pointer enters any cell in the footer area (a normal footer cell, the row header footer cell or the extra footer cell).</summary>
    [Category("Footer Mouse")]
    [Description("Occurs when the mouse pointer enters a footer cell.")]
    public event iGFooterCellMouseEnterLeaveEventHandler FooterCellMouseEnter;

    /// <summary>Occurs when the mouse pointer leaves any cell in the footer area (a normal footer cell, the row header footer cell or the extra footer cell).</summary>
    [Category("Footer Mouse")]
    [Description("Occurs when the mouse pointer leaves a footer cell.")]
    public event iGFooterCellMouseEnterLeaveEventHandler FooterCellMouseLeave;

    /// <summary>Occurs when a footer cell is clicked.</summary>
    [Category("Footer Cell Action")]
    [Description("Occurs when a footer cell is clicked.")]
    public event iGFooterCellClickEventHandler FooterCellClick;

    /// <summary>Occurs when a footer cell is double-clicked.</summary>
    [Category("Footer Cell Action")]
    [Description("Occurs when a footer cell is double-clicked.")]
    public event iGFooterCellDoubleClickEventHandler FooterCellDoubleClick;

    /// <summary>Occurs when the mouse pointer is over a cell and a mouse button is pressed.</summary>
    [Category("Cell Mouse")]
    [Description("Occurs when the mouse pointer is over a cell and a mouse button is pressed.")]
    public event iGCellMouseDownEventHandler CellMouseDown;

    /// <summary>Occurs when the mouse pointer is over a cell and a mouse button is released.</summary>
    [Category("Cell Mouse")]
    [Description("Occurs when the mouse pointer is over a cell and a mouse button is released.")]
    public event iGCellMouseUpEventHandler CellMouseUp;

    /// <summary>Occurs when the mouse pointer enters a cell.</summary>
    [Category("Cell Mouse")]
    [Description("Occurs when the mouse pointer enters a cell.")]
    public event iGCellMouseEnterLeaveEventHandler CellMouseEnter;

    /// <summary>Occurs when the mouse pointer leaves a cell.</summary>
    [Category("Cell Mouse")]
    [Description("Occurs when the mouse pointer leaves a cell.")]
    public event iGCellMouseEnterLeaveEventHandler CellMouseLeave;

    /// <summary>Occurs when a cell is double-clicked.</summary>
    [Category("Cell Action")]
    [Description("Occurs when a cell is double-clicked.")]
    public event iGCellDoubleClickEventHandler CellDoubleClick;

    /// <summary>Occurs when a cell is clicked.</summary>
    [Category("Cell Action")]
    [Description("Occurs when a cell is clicked.")]
    public event iGCellClickEventHandler CellClick;

    /// <summary>Occurs when the mouse pointer moves over a cell.</summary>
    [Category("Cell Mouse")]
    [Description("Occurs when the mouse pointer moves over a cell.")]
    public event iGCellMouseMoveEventHandler CellMouseMove;

    /// <summary>Occurs when the ellipsis button in a cell is clicked.</summary>
    [Category("Cell Action")]
    [Description("Occurs when the ellipsis button in a cell is clicked.")]
    public event iGEllipsisButtonClickEventHandler CellEllipsisButtonClick;

    /// <summary>Occurs when the mouse pointer is over a row header and a mouse button is pressed.</summary>
    [Category("Row Header Mouse")]
    [Description("Occurs when the mouse pointer is over a row header and a mouse button is pressed.")]
    public event iGRowHdrMouseDownEventHandler RowHdrMouseDown;

    /// <summary>Occurs when the mouse pointer is over a row header and a mouse button is released.</summary>
    [Category("Row Header Mouse")]
    [Description("Occurs when the mouse pointer is over a row header and a mouse button is released.")]
    public event iGRowHdrMouseUpEventHandler RowHdrMouseUp;

    /// <summary>Occurs when the mouse pointer enters a row header.</summary>
    [Category("Row Header Mouse")]
    [Description("Occurs when the mouse pointer enters a row header.")]
    public event iGRowHdrMouseEnterLeaveEventHandler RowHdrMouseEnter;

    /// <summary>Occurs when the mouse pointer leaves a row header.</summary>
    [Category("Row Header Mouse")]
    [Description("Occurs when the mouse pointer leaves a row header.")]
    public event iGRowHdrMouseEnterLeaveEventHandler RowHdrMouseLeave;

    /// <summary>Occurs when a row header is double-clicked.</summary>
    [Category("Row Header Action")]
    [Description("Occurs when a row header is double-clicked.")]
    public event iGRowHdrDoubleClickEventHandler RowHdrDoubleClick;

    /// <summary>Occurs when a row header is clicked.</summary>
    [Category("Row Header Action")]
    [Description("Occurs when a row header is clicked.")]
    public event iGRowHdrClickEventHandler RowHdrClick;

    /// <summary>Occurs when the mouse pointer moves over a row header.</summary>
    [Category("Row Header Mouse")]
    [Description("Occurs when the mouse pointer moves over a row header.")]
    public event iGRowHdrMouseMoveEventHandler RowHdrMouseMove;

    /// <summary>Occurs when the height of a row is about to be changed. This event does not occur when you programmatically set the height of a row.</summary>
    [Category("Rows")]
    [Description("Occurs when the mouse pointer is near a row edge. This event allows you to prohibit resizing separate rows as well as set their minimal and maximal heights.")]
    public event iGRequestRowResizeEventHandler RequestRowResize;

    /// <summary>Occurs while the user starts resizing a row.</summary>
    [Category("Rows")]
    [Description("Occurs when the user starts resizing a row.")]
    public event iGRowHeightEventHandler RowHeightStartChange;

    /// <summary>Occurs while the user finishes resizing a row.</summary>
    [Category("Rows")]
    [Description("Occurs when the user has finished resizing a row.")]
    public event iGRowHeightEventHandler RowHeightEndChange;

    /// <summary>Occurs while the user resizes a row.</summary>
    [Category("Rows")]
    [Description("Occurs while the user resizes a row.")]
    public event iGRowHeightEventHandler RowHeightChanging;

    /// <summary>Occurs after the user has double-clicked a row edge in the area enabled for row resizing.</summary>
    [Category("Row Header Action")]
    [Description("Occurs when the divider of a row is double-clicked. The default action is adjusting of the rows's width.")]
    public event iGRowDividerDoubleClickEventHandler RowDividerDoubleClick;

    private void InitializeRowHeader()
    {
      this.fRowHeader = new iGRowHeader(this);
    }

    internal System.Drawing.Color GetRowHdrParentBackColor()
    {
      return this.fCellControlPaintStyle.BackColor;
    }

    internal iGRowHdrGlyph GetRowHdrGlyph(int rowIndex)
    {
      if (this.fCurCell.RowIndex != rowIndex)
        return iGRowHdrGlyph.None;
      return this.IsEditing ? iGRowHdrGlyph.Editing : iGRowHdrGlyph.CurRow;
    }

    internal System.Drawing.Color GetRowHdrBackColor(int rowIndex)
    {
      return this.DoRowHdrDynamicBackColor(rowIndex);
    }

    /// <summary>Draws the specified standard row header glyph on the specified graphics surface.</summary>
    /// <param name="g">The graphics surface to drawn on.</param>
    /// <param name="glyph">The glyph to be drawn.</param>
    /// <param name="glyphAreaX">The X-coordinate of the area where the glyph will be drawn. The glyph will be drawn in the center of this area. If the area is smaller than the glyph, the glyph will be cropped.</param>
    /// <param name="glyphAreaY">The y-coordinate of the area where the glyph will be drawn. The glyph will be drawn in the center of this area. If the area is smaller than the glyph, the glyph will be cropped.</param>
    /// <param name="glyphAreaWidth">The width of the area where the glyph will be drawn. The glyph will be drawn in the center of this area. If the area is smaller than the glyph, the glyph will be cropped.</param>
    /// <param name="glyphAreaHeight">The height of the area where the glyph will be drawn. The glyph will be drawn in the center of this area. If the area is smaller than the glyph, the glyph will be cropped.</param>
    public void DrawRowHdrGlyph(Graphics g, iGRowHdrGlyph glyph, int glyphAreaX, int glyphAreaY, int glyphAreaWidth, int glyphAreaHeight)
    {
      iGRowHeader.DrawRowHdrGlyph(g, glyph, glyphAreaX, glyphAreaY, glyphAreaWidth, glyphAreaHeight, this.RightToLeft == RightToLeft.Yes);
    }

    internal Rectangle GetRowHeaderAreaBounds()
    {
      if (!this.fRowHeader.Visible)
        return Rectangle.Empty;
      Rectangle headerAreaBounds = this.GetCellsAndRowHeaderAreaBounds(true);
      if (this.RightToLeft == RightToLeft.Yes)
        headerAreaBounds.X = headerAreaBounds.Right - this.fRowHeader.EffectiveWidth();
      headerAreaBounds.Width = this.fRowHeader.EffectiveWidth();
      return headerAreaBounds;
    }

    internal int GetRowHeaderAreaLeft()
    {
      return this.GetRowHeaderAreaLeft(this.RightToLeft == RightToLeft.Yes);
    }

    private int GetRowHeaderAreaLeft(bool rightToLeft)
    {
      int num = this.GetRowHeaderAreaLeft_NoRighToLeft();
      if (rightToLeft)
        num = this.Width - num - this.fRowHeader.EffectiveWidth();
      return num;
    }

    private int GetRowHeaderAreaLeft_NoRighToLeft()
    {
      return this.GetBorderSize();
    }

    private bool ShouldSerializeRowHeader()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.RowHeader);
    }

    private void ResetRowHeader()
    {
      iGInternalInfrastructure.iGSerializeManager.Reset((object) this.RowHeader);
    }

    private System.Drawing.Color DoRowHdrDynamicBackColor(int rowIndex)
    {
      iGRowHdrDynamicColorEventArgs e = new iGRowHdrDynamicColorEventArgs(rowIndex, this.fRowHeader.EffectiveBackColor);
      this.OnRowHdrDynamicBackColor(e);
      return e.Color;
    }

    internal bool DoCustomDrawRowHdrBackground(int rowIndex, Graphics g, Rectangle bounds, iGControlState state, bool selected)
    {
      iGCustomDrawRowHdrBackgroundEventArgs e = new iGCustomDrawRowHdrBackgroundEventArgs(rowIndex, g, bounds, state, selected);
      this.OnCustomDrawRowHdrBackground(e);
      return e.DoDefault;
    }

    internal bool DoCustomDrawRowHdrForeground(int rowIndex, Graphics g, Rectangle glyphAreaBounds, Rectangle customAreaBounds, iGControlState state, bool selected)
    {
      iGCustomDrawRowHdrForegroundEventArgs e = new iGCustomDrawRowHdrForegroundEventArgs(rowIndex, g, glyphAreaBounds, customAreaBounds, state, selected);
      this.OnCustomDrawRowHdrForeground(e);
      return e.DoDefault;
    }

    internal void DoCustomDrawRowHdrGetWidth(int rowIndex, Graphics g, ref int glyphAreaWidth, out int customAreaWidth, out bool includeIndents)
    {
      iGCustomDrawRowHdrGetWidthEventArgs e = new iGCustomDrawRowHdrGetWidthEventArgs(rowIndex, g, glyphAreaWidth);
      this.OnCustomDrawRowHdrGetWidth(e);
      glyphAreaWidth = e.GlyphAreaWidth;
      customAreaWidth = e.CustomAreaWidth;
      includeIndents = e.IncludeIndents;
    }

    internal void DoCustomDrawRowHdrGetHeight(int rowIndex, Graphics g, ref int glyphAreaHeight, out int customAreaHeight, out bool includeIndents)
    {
      iGCustomDrawRowHdrGetHeightEventArgs e = new iGCustomDrawRowHdrGetHeightEventArgs(rowIndex, g, glyphAreaHeight);
      this.OnCustomDrawRowHdrGetHeight(e);
      glyphAreaHeight = e.GlyphAreaHeight;
      customAreaHeight = e.CustomAreaHeight;
      includeIndents = e.IncludeIndents;
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowHdrDynamicBackColor" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowHdrDynamicColorEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowHdrDynamicBackColor(iGRowHdrDynamicColorEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowHdrDynamicBackColor == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowHdrDynamicBackColor((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawRowHdrBackground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawRowHdrBackgroundEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawRowHdrBackground(iGCustomDrawRowHdrBackgroundEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawRowHdrBackground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawRowHdrBackground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawRowHdrForeground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawRowHdrForegroundEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawRowHdrForeground(iGCustomDrawRowHdrForegroundEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawRowHdrForeground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawRowHdrForeground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawRowHdrGetWidth" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawRowHdrGetWidthEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawRowHdrGetWidth(iGCustomDrawRowHdrGetWidthEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawRowHdrGetWidth == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawRowHdrGetWidth((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawRowHdrGetHeight" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawRowHdrGetHeightEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawRowHdrGetHeight(iGCustomDrawRowHdrGetHeightEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawRowHdrGetHeight == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawRowHdrGetHeight((object) this, e);
    }

    /// <summary>Gets the object which represents the row header in the grid.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGRowHeader" /> object which represents the row header.</value>
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Category("iGrid Areas")]
    [Description("Exposes the set of properties which allow you to set up the row header.")]
    public iGRowHeader RowHeader
    {
      get
      {
        return this.fRowHeader;
      }
    }

    /// <summary>Occurs when the grid determines the background color of a row header while drawing.  It allows you to adjust the background color dynamically.</summary>
    [Category("Row Header Appearance")]
    [Description("Occurs when the grid determines the background color of a row header while drawing. Allows you to adjust the background color dynamically.")]
    public event iGRowHdrDynamicColorEventHandler RowHdrDynamicBackColor;

    /// <summary>Occurs when the row header background is being drawn.</summary>
    [Category("Row Header Appearance")]
    [Description("Occurs when the background of a row header is redrawn.")]
    public event iGCustomDrawRowHdrBackgroundEventHandler CustomDrawRowHdrBackground;

    /// <summary>Occurs when the row header foreground is being drawn.</summary>
    [Category("Row Header Appearance")]
    [Description("Occurs when the background of a row header is redrawn.")]
    public event iGCustomDrawRowHdrForegroundEventHandler CustomDrawRowHdrForeground;

    /// <summary>Occurs when the grid requires the width needed to display all the contents of a custom draw row header entirely.</summary>
    [Category("Row Header Appearance")]
    [Description("Occurs when the grid requires the width necessary to display all the contents of a custom draw row header entirely (occurs while row header width adjusting).")]
    public event iGCustomDrawRowHdrGetWidthEventHandler CustomDrawRowHdrGetWidth;

    /// <summary>Occurs when the grid requires the height needed to display all the contents of a custom draw row header entirely.</summary>
    [Category("Row Header Appearance")]
    [Description("Occurs when the grid requires the height necessary to display all the contents of a custom draw row header entirely (occurs while row height adjusting).")]
    public event iGCustomDrawRowHdrGetHeightEventHandler CustomDrawRowHdrGetHeight;

    internal bool GetCellSelected(int rowIndex, int colIndex)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      return this.GetCellSelectedInternal(rowIndex, colIndex);
    }

    internal bool GetRowSelected(int rowIndex)
    {
      this.CheckRowIndex(rowIndex);
      return this.GetRowSelectedInternal(rowIndex);
    }

    internal void SetCellSelected(int rowIndex, int colIndex, bool value)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      if (this.fRowMode || this.fSelectionMode == iGSelectionMode.None || value && !this.CanSelectCell(rowIndex, this.GetColOrder(colIndex), false))
        return;
      bool flag = false;
      if (this.SelectionMode == iGSelectionMode.One)
      {
        if (!value)
          return;
        this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, colIndex), true);
      }
      else if (this.fSelectionMode == iGSelectionMode.MultiSimple || this.fSelectionMode == iGSelectionMode.MultiExtended)
        flag = !value ? this.SetCellSelectedToFalse(rowIndex, colIndex, true) : this.SetCellSelectedToTrue(rowIndex, colIndex, true, true);
      if (!flag)
        return;
      this.DoSelectionChanged();
    }

    internal void SetRowSelected(int rowIndex, bool value)
    {
      this.CheckRowIndex(rowIndex);
      if (value && !this.CanSelectRow(rowIndex, false))
        return;
      bool flag = false;
      if (this.fRowMode)
      {
        if (this.fSelectionMode == iGSelectionMode.None)
          return;
        if (this.fSelectionMode == iGSelectionMode.One)
        {
          if (!value)
            return;
          int selectionColIsClicked = this.GetColIndexOfCellToSelectWhenNotIncludedInSelectionColIsClicked(rowIndex);
          if (selectionColIsClicked >= 0)
            this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, selectionColIsClicked), true);
        }
        else if (this.fSelectionMode == iGSelectionMode.MultiSimple || this.fSelectionMode == iGSelectionMode.MultiExtended)
          flag = !value ? this.SetRowSelectedToFalse(rowIndex, true) : this.SetRowSelectedToTrue(rowIndex, true, true);
      }
      else
      {
        if (this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.None)
          return;
        flag = !value ? this.SetRowSelectedToFalse(rowIndex, true) : this.SetRowSelectedToTrue(rowIndex, this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.MultipleRows, true);
      }
      if (!flag)
        return;
      this.DoSelectionChanged();
    }

    private void AdjustSelectionOnModeChanged()
    {
      if (this.fRowMode)
      {
        this.DeselectAllCells(false, true);
        if (this.fSelectionMode == iGSelectionMode.None)
        {
          this.DeselectAllRows(false, true);
        }
        else
        {
          if (this.fSelectionMode != iGSelectionMode.One || this.fSelectedRows.Count <= 1 || !this.SetRowSelectedToTrue(this.fSelectedRows.GetItem(0), false, true))
            return;
          this.DoSelectionChanged();
        }
      }
      else
      {
        if (this.fSelectionMode == iGSelectionMode.None)
          this.DeselectAllCells(false, true);
        else if (this.fSelectionMode == iGSelectionMode.One && this.fSelectedCells.Count > 1)
        {
          iGCellNavigator iGcellNavigator = this.fSelectedCells.GetItem(0);
          if (this.SetCellSelectedToTrue(iGcellNavigator.RowIndex, iGcellNavigator.ColIndex, false, true))
            this.DoSelectionChanged();
        }
        if (this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.None)
        {
          this.DeselectAllRows(false, true);
        }
        else
        {
          if (this.fRowSelectionInCellMode != iGRowSelectionInCellModeTypes.SingleRow || this.fSelectedRows.Count <= 1 || !this.SetRowSelectedToTrue(this.fSelectedRows.GetItem(0), false, true))
            return;
          this.DoSelectionChanged();
        }
      }
    }

    private int GetColIndexOfCellToSelectWhenNotIncludedInSelectionColIsClicked(int rowIndex)
    {
      if (!this.fCurCell.IsEmpty && this.CanSelectCell(rowIndex, this.GetColOrder(this.fCurCell.ColIndex), false))
        return this.fCurCell.ColIndex;
      int cellToNavigateInRow = this.GetColOrderOfFirstCellToNavigateInRow(rowIndex);
      if (cellToNavigateInRow < 0)
        return -1;
      return this.fColIdxFromOrd[cellToNavigateInRow];
    }

    private bool CanSelectRow(int rowIndex, bool isRangeSelection)
    {
      bool checkVisible;
      bool allowGroupRows;
      if (isRangeSelection)
      {
        checkVisible = !this.fSelectInvisibleCells;
        allowGroupRows = false;
      }
      else
      {
        checkVisible = true;
        allowGroupRows = true;
      }
      return this.CanSelectRowCore(rowIndex, checkVisible, allowGroupRows, true);
    }

    internal bool CanSelectCellsInRow(int rowIndex, bool isRangeSelection, bool checkVisible)
    {
      bool checkVisible1;
      bool allowGroupRows;
      if (isRangeSelection)
      {
        checkVisible1 = !this.fSelectInvisibleCells;
        allowGroupRows = false;
      }
      else
      {
        checkVisible1 = checkVisible;
        allowGroupRows = true;
      }
      return this.CanSelectRowCore(rowIndex, checkVisible1, allowGroupRows, this.fRowMode);
    }

    private bool CanSelectRowCore(int rowIndex, bool checkVisible, bool allowGroupRows, bool checkRowSelectable)
    {
      if (rowIndex < 0)
        throw new ArgumentOutOfRangeException(nameof (rowIndex));
      iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
      return (!checkVisible || this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded)) && (allowGroupRows || !this.IsGroupRow(rowDataInternal)) && (!checkRowSelectable || rowDataInternal.Selectable);
    }

    private bool CanSelectCellsInCol(int colOrder, bool isRangeSelection, bool checkVisible)
    {
      int colIndex = this.fColIdxFromOrd[colOrder];
      iGColData fColData = this.fColDatas[colIndex];
      return fColData.IncludeInSelect && ((isRangeSelection ? (!this.fSelectInvisibleCells ? 1 : 0) : (checkVisible ? 1 : 0)) == 0 || this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex));
    }

    internal bool CanSelectCell(int rowIndex, int colOrder, bool isRangeSelection)
    {
      return this.CanSelectCell(rowIndex, colOrder, isRangeSelection, true);
    }

    internal bool CanSelectCell(int rowIndex, int colOrder, bool isRangeSelection, bool checkRowColVisible)
    {
      if (!this.CanSelectCellsInRow(rowIndex, isRangeSelection, checkRowColVisible))
        return false;
      if (colOrder == 0)
      {
        if (!this.IsGroupRow(rowIndex) && !this.IsRowTextDisplayed())
          return false;
      }
      else if (!this.CanSelectCellsInCol(colOrder, isRangeSelection, checkRowColVisible))
        return false;
      int colIndex = this.fColIdxFromOrd[colOrder];
      iGColData fColData = this.fColDatas[colIndex];
      if (isRangeSelection && !this.fSelectInvisibleCells)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
        if (!this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          return false;
        if (this.IsGroupRow(rowDataInternal))
        {
          if (colOrder != 0)
            return false;
        }
        else
        {
          switch (this.GetColDisposition(colOrder))
          {
            case iGColDisposition.Auxiliary:
              return false;
            case iGColDisposition.Normal:
            case iGColDisposition.AboveRowText:
              if (!this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
                return false;
              break;
          }
        }
      }
      return this.GetPropFromStyles_Selectable(this.GetCellDataInternal(rowIndex, colIndex).Style, this.GetRowDataInternal(rowIndex).CellStyle, fColData.CellStyle) && this.IsCellInClientScrollableArea(rowIndex, colOrder, !this.CanScrollVert() && this.fAreCellsSrollableVert, !this.CanScrollHorz() && this.fAreCellsSrollableHorz);
    }

    private void ActionFirstRow(bool initiatedFromCode, bool skipGroupRows)
    {
      if (this.fRowCount == 0 || this.fColCount == 0)
        return;
      for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
      {
        bool flag = this.IsGroupRow(rowIndex);
        if (!(skipGroupRows & flag))
        {
          int colOrder = this.GetColOrderOfCellToSelectInRowNoMerged(rowIndex);
          if (colOrder >= 0)
          {
            int num1 = rowIndex;
            int num2 = colOrder;
            if (flag)
              colOrder = 0;
            else
              this.IfMergedCellSetRowColToRoot(ref rowIndex, ref colOrder);
            if (this.CanSelectCell(rowIndex, colOrder, false))
            {
              int colIndex = this.fColIdxFromOrd[colOrder];
              if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
                break;
              this.SetCurCellWithEventsEnsureVisibleIfSpecified(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode, true);
              this.fEnterMergedCellRowIndex = num1;
              this.fEnterMergedCellColOrder = num2;
              break;
            }
          }
        }
      }
    }

    private void ActionLastRow(bool initiatedFromCode, bool skipGroupRows)
    {
      if (this.fRowCount == 0 || this.fColCount == 0)
        return;
      for (int rowIndex = this.fRowCount - 1; rowIndex >= 0; --rowIndex)
      {
        bool flag = this.IsGroupRow(rowIndex);
        if (!(skipGroupRows & flag))
        {
          int colOrder = this.GetColOrderOfCellToSelectInRowNoMerged(rowIndex);
          if (colOrder >= 0)
          {
            int num1 = rowIndex;
            int num2 = colOrder;
            if (flag)
              colOrder = 0;
            else
              this.IfMergedCellSetRowColToRoot(ref rowIndex, ref colOrder);
            if (this.CanSelectCell(rowIndex, colOrder, false))
            {
              int colIndex = this.fColIdxFromOrd[colOrder];
              if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
                break;
              this.SetCurCellWithEventsEnsureVisibleIfSpecified(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode, true);
              this.fEnterMergedCellRowIndex = num1;
              this.fEnterMergedCellColOrder = num2;
              break;
            }
          }
        }
      }
    }

    private void ActionFirstCol(bool initiatedFromCode)
    {
      int rowIndex = 0;
      int index = 0;
      if (!this.FindFirstCol(ref rowIndex, ref index))
        return;
      this.IfMergedCellSetRowColToRoot(ref rowIndex, ref index);
      int colIndex = this.fColIdxFromOrd[index];
      if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
        return;
      this.SetCurCellWithEventsEnsureVisibleIfSpecified(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode, true);
    }

    private bool FindFirstCol(ref int newCurCellRowIndex, ref int newCurCellColOrder)
    {
      if (this.fCurCell.IsEmpty)
      {
        for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
        {
          int colOrder = !this.IsGroupRow(rowIndex) ? this.GetColOrderOfFirstCellToNavigateInRow(rowIndex) : 0;
          if (colOrder >= 0 && this.CanSelectCell(rowIndex, colOrder, false))
          {
            newCurCellColOrder = colOrder;
            newCurCellRowIndex = rowIndex;
            return true;
          }
        }
        return false;
      }
      int colOrder1 = !this.IsGroupRow(this.fCurCell.RowIndex) ? this.GetColOrderOfFirstCellToNavigateInRow(this.fCurCell.RowIndex) : 0;
      if (colOrder1 < 0 || !this.CanSelectCell(this.fCurCell.RowIndex, colOrder1, false))
        return false;
      newCurCellColOrder = colOrder1;
      newCurCellRowIndex = this.fCurCell.RowIndex;
      return true;
    }

    private void ActionLastCol(bool initiatedFromCode)
    {
      int rowIndex = 0;
      int index = 0;
      if (!this.FindLastCol(ref rowIndex, ref index))
        return;
      this.IfMergedCellSetRowColToRoot(ref rowIndex, ref index);
      int colIndex = this.fColIdxFromOrd[index];
      if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
        return;
      this.SetCurCellWithEventsEnsureVisibleIfSpecified(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode, true);
    }

    private bool FindLastCol(ref int newCurCellRowIndex, ref int newCurCellColIndex)
    {
      if (this.fCurCell.IsEmpty)
      {
        for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
        {
          int colOrder = !this.IsGroupRow(rowIndex) ? this.GetColOrderOfLastCellToNavigateInRow(rowIndex) : 0;
          if (colOrder >= 0 && this.CanSelectCell(rowIndex, colOrder, false))
          {
            newCurCellColIndex = this.GetColIndex(colOrder);
            newCurCellRowIndex = rowIndex;
            return true;
          }
        }
        return false;
      }
      int colOrder1 = !this.IsGroupRow(this.fCurCell.RowIndex) ? this.GetColOrderOfLastCellToNavigateInRow(this.fCurCell.RowIndex) : 0;
      if (colOrder1 < 0 || !this.CanSelectCell(this.fCurCell.RowIndex, colOrder1, false))
        return false;
      newCurCellColIndex = this.GetColIndex(colOrder1);
      newCurCellRowIndex = this.fCurCell.RowIndex;
      return true;
    }

    private void ActionFirstRowCol(bool initiatedFromCode, bool skipGroupRows)
    {
      if (this.fRowCount == 0 || this.fColCount == 0)
        return;
      for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
      {
        bool flag = this.IsGroupRow(rowIndex);
        if (!(skipGroupRows & flag))
        {
          int colOrder = !flag ? this.GetColOrderOfFirstCellToNavigateInRow(rowIndex) : 0;
          if (colOrder >= 0)
          {
            if (!flag)
              this.IfMergedCellSetRowColToRoot(ref rowIndex, ref colOrder);
            if (this.CanSelectCell(rowIndex, colOrder, false))
            {
              int colIndex = this.fColIdxFromOrd[colOrder];
              if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
                break;
              this.SetCurCellWithEventsEnsureVisibleIfSpecified(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode, true);
              break;
            }
          }
        }
      }
    }

    private void ActionLastRowCol(bool initiatedFromCode, bool skipGroupRows)
    {
      if (this.fRowCount == 0 || this.fColCount == 0)
        return;
      for (int rowIndex = this.fRowCount - 1; rowIndex >= 0; --rowIndex)
      {
        bool flag = this.IsGroupRow(rowIndex);
        if (!(skipGroupRows & flag))
        {
          int colOrder = !flag ? this.GetColOrderOfLastCellToNavigateInRow(rowIndex) : 0;
          if (colOrder >= 0)
          {
            if (!flag)
              this.IfMergedCellSetRowColToRoot(ref rowIndex, ref colOrder);
            if (this.CanSelectCell(rowIndex, colOrder, false))
            {
              int colIndex = this.fColIdxFromOrd[colOrder];
              if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
                break;
              this.SetCurCellWithEventsEnsureVisibleIfSpecified(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode, true);
              break;
            }
          }
        }
      }
    }

    private void ActionPrevCol(bool initiatedFromCode)
    {
      if (this.fColCount == 0 || this.fRowCount == 0)
        return;
      if (this.fCurCell.IsEmpty)
      {
        this.ActionNextCol(initiatedFromCode);
      }
      else
      {
        int rowIndex = this.fCurCell.RowIndex;
        int colOrder = this.GetColOrder(this.fCurCell.ColIndex);
        if (this.IsGroupRow(rowIndex))
          colOrder = this.GetColOrder(1);
        if (this.fMergedCellCountAll > 0 && this.GetCellDataInternal(this.fCurCell.RowIndex, this.fCurCell.ColIndex).SpanRows > 1)
          rowIndex = this.fEnterMergedCellRowIndex;
        int num1;
        for (; this.GetPrevColToNavigate(ref colOrder) || this.GetPrevRowToNavigate(ref rowIndex); rowIndex = num1)
        {
          num1 = rowIndex;
          int num2 = colOrder;
          if (this.IsGroupRow(rowIndex))
            colOrder = 0;
          else
            this.IfMergedCellSetRowColToRoot(ref rowIndex, ref colOrder);
          if (this.CanSelectCell(rowIndex, colOrder, false, false))
          {
            int colIndex = this.fColIdxFromOrd[colOrder];
            if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
              break;
            this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode);
            this.fEnterMergedCellRowIndex = num1;
            this.fEnterMergedCellColOrder = num2;
            break;
          }
        }
      }
    }

    internal void ActionNextCol(bool initiatedFromCode)
    {
      if (this.fColCount == 0 || this.fRowCount == 0)
        return;
      bool isEmpty = this.fCurCell.IsEmpty;
      int rowIndex = this.fCurCell.RowIndex;
      int colOrder = isEmpty ? -1 : this.GetColOrder(this.fCurCell.ColIndex);
      if (this.fMergedCellCountAll > 0 && !isEmpty)
      {
        iGCellData cellDataInternal = this.GetCellDataInternal(this.fCurCell.RowIndex, this.fCurCell.ColIndex);
        if (cellDataInternal.SpanCols > 1)
          colOrder += cellDataInternal.SpanCols - 1;
        if (cellDataInternal.SpanRows > 1)
          rowIndex = this.fEnterMergedCellRowIndex;
      }
      while (!(!this.GetNextColToNavigate(ref colOrder) | isEmpty) || this.GetNextRowToNavigate(ref rowIndex))
      {
        int num1 = rowIndex;
        int num2 = colOrder;
        if (this.IsGroupRow(rowIndex))
          colOrder = 0;
        else
          this.IfMergedCellSetRowColToRoot(ref rowIndex, ref colOrder);
        if (this.CanSelectCell(rowIndex, colOrder, false, false))
        {
          int colIndex = this.fColIdxFromOrd[colOrder];
          if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
            break;
          this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode);
          this.fEnterMergedCellRowIndex = num1;
          this.fEnterMergedCellColOrder = num2;
          break;
        }
        if (this.GetCellKindAsMerged(rowIndex, colOrder) == iGrid.iGCellKindAsMerged.MergedRoot)
        {
          iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, this.fColIdxFromOrd[colOrder]);
          colOrder += cellDataInternal.SpanCols - 1;
          rowIndex = num1;
        }
      }
    }

    private void ActionPrevRow(bool initiatedFromCode, bool skipGroupRows)
    {
      if (this.fColCount == 0 || this.fRowCount == 0)
        return;
      if (this.fCurCell.IsEmpty)
      {
        this.ActionNextCol(initiatedFromCode);
      }
      else
      {
        int rowIndex = this.fCurCell.RowIndex;
        while (this.GetPrevRowToNavigate(ref rowIndex))
        {
          bool flag = this.IsGroupRow(rowIndex);
          if (!(skipGroupRows & flag))
          {
            int colOrder = this.GetColOrderOfCellToSelectInRowNoMerged(rowIndex);
            if (colOrder >= 0)
            {
              int num1 = rowIndex;
              int num2 = colOrder;
              if (flag)
                colOrder = 0;
              else
                this.IfMergedCellSetRowColToRoot(ref rowIndex, ref colOrder);
              if (this.CanSelectCell(rowIndex, colOrder, false, false))
              {
                int colIndex = this.fColIdxFromOrd[colOrder];
                if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
                  break;
                this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode);
                this.fEnterMergedCellRowIndex = num1;
                this.fEnterMergedCellColOrder = num2;
                break;
              }
            }
          }
        }
      }
    }

    private void ActionNextRow(bool initiatedFromCode, bool skipGroupRows)
    {
      if (this.fColCount == 0 || this.fRowCount == 0)
        return;
      if (this.fCurCell.IsEmpty)
      {
        this.ActionNextCol(initiatedFromCode);
      }
      else
      {
        int rowIndex = this.fCurCell.RowIndex;
        if (this.fMergedCellCountAll > 0)
        {
          iGCellData cellDataInternal = this.GetCellDataInternal(this.fCurCell.RowIndex, this.fCurCell.ColIndex);
          if (cellDataInternal.SpanRows > 1)
            rowIndex += cellDataInternal.SpanRows - 1;
        }
        while (this.GetNextRowToNavigate(ref rowIndex))
        {
          bool flag = this.IsGroupRow(rowIndex);
          if (!(skipGroupRows & flag))
          {
            int colOrder = this.GetColOrderOfCellToSelectInRowNoMerged(rowIndex);
            if (colOrder >= 0)
            {
              int num1 = rowIndex;
              int num2 = colOrder;
              if (flag)
                colOrder = 0;
              else
                this.IfMergedCellSetRowColToRoot(ref rowIndex, ref colOrder);
              if (this.CanSelectCell(rowIndex, colOrder, false, false))
              {
                int colIndex = this.fColIdxFromOrd[colOrder];
                if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, initiatedFromCode))
                  break;
                this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, colIndex), initiatedFromCode);
                this.fEnterMergedCellRowIndex = num1;
                this.fEnterMergedCellColOrder = num2;
                break;
              }
              if (this.GetCellKindAsMerged(rowIndex, colOrder) == iGrid.iGCellKindAsMerged.MergedRoot)
              {
                iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, this.fColIdxFromOrd[colOrder]);
                rowIndex += cellDataInternal.SpanRows - 1;
              }
            }
          }
        }
      }
    }

    private void ActionPrevPage(bool initiatedFromCode, bool skipGroupRows)
    {
      if (this.fRowCount == 0 || this.fColCount == 0)
        return;
      if (this.fCurCell.IsEmpty)
        this.ActionNextCol(initiatedFromCode);
      else if (!this.IsScrollableVert())
      {
        this.ActionFirstRow(initiatedFromCode, skipGroupRows);
      }
      else
      {
        int fLargeChange = this.fVScrollBar.fLargeChange;
        int num1 = 0;
        int rowIndex1 = this.fCurCell.RowIndex;
        int index = this.GetColOrder(this.fCurCell.ColIndex);
        bool flag1 = false;
        int num2 = -1;
        int num3 = -1;
        for (int rowIndex2 = this.fCurCell.RowIndex; rowIndex2 >= 0 && (num1 < fLargeChange || !flag1); --rowIndex2)
        {
          iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex2);
          if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          {
            num1 += rowDataInternal.Height;
            bool flag2 = this.IsGroupRow(rowIndex2);
            if (!(skipGroupRows & flag2))
            {
              int colOrder = this.GetColOrderOfCellToSelectInRowNoMerged(rowIndex2);
              if (colOrder >= 0)
              {
                num2 = rowIndex2;
                num3 = colOrder;
                if (flag2)
                  colOrder = 0;
                else
                  this.IfMergedCellSetRowColToRoot(ref rowIndex2, ref colOrder);
                if (this.CanSelectCell(rowIndex2, colOrder, false))
                {
                  flag1 = true;
                  rowIndex1 = rowIndex2;
                  index = colOrder;
                }
              }
            }
          }
        }
        if (!flag1)
          return;
        int colIndex = this.fColIdxFromOrd[index];
        if (!this.CurCellOrRowChangeRequestAccepted(rowIndex1, colIndex, initiatedFromCode))
          return;
        if (rowIndex1 < this.fFrozenRowCount && this.CanScrollVert())
          this.SetVScrollBarValue(0, true);
        this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex1, colIndex), initiatedFromCode);
        this.fEnterMergedCellRowIndex = num2;
        this.fEnterMergedCellColOrder = num3;
      }
    }

    private void ActionNextPage(bool initiatedFromCode, bool skipGroupRows)
    {
      if (this.fRowCount == 0 || this.fColCount == 0)
        return;
      if (this.fCurCell.IsEmpty)
        this.ActionNextCol(initiatedFromCode);
      else if (!this.IsScrollableVert())
      {
        this.ActionLastRow(initiatedFromCode, skipGroupRows);
      }
      else
      {
        int fLargeChange = this.fVScrollBar.fLargeChange;
        int num1 = 0;
        int rowIndex1 = this.fCurCell.RowIndex;
        int index = this.GetColOrder(this.fCurCell.ColIndex);
        bool flag1 = false;
        int num2 = -1;
        int num3 = -1;
        for (int rowIndex2 = this.fCurCell.RowIndex; rowIndex2 < this.fRowCount && (num1 < fLargeChange || !flag1); ++rowIndex2)
        {
          iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex2);
          if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          {
            num1 += rowDataInternal.Height;
            bool flag2 = this.IsGroupRow(rowIndex2);
            if (!(skipGroupRows & flag2))
            {
              int colOrder = this.GetColOrderOfCellToSelectInRowNoMerged(rowIndex2);
              if (colOrder >= 0)
              {
                num2 = rowIndex2;
                num3 = colOrder;
                if (flag2)
                  colOrder = 0;
                else
                  this.IfMergedCellSetRowColToRoot(ref rowIndex2, ref colOrder);
                if (this.CanSelectCell(rowIndex2, colOrder, false))
                {
                  flag1 = true;
                  rowIndex1 = rowIndex2;
                  index = this.GetColIndex(colOrder);
                }
                rowIndex2 = num2;
              }
            }
          }
        }
        if (!flag1)
          return;
        int colIndex = this.fColIdxFromOrd[index];
        if (!this.CurCellOrRowChangeRequestAccepted(rowIndex1, colIndex, initiatedFromCode))
          return;
        this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex1, colIndex), initiatedFromCode);
        this.fEnterMergedCellRowIndex = num2;
        this.fEnterMergedCellColOrder = num3;
      }
    }

    private bool CurCellOrRowChangeRequestAccepted(int rowIndex, int colIndex, bool initiatedFromCode)
    {
      if (initiatedFromCode)
        return true;
      if (this.fCurCell.IsEmpty || this.fCurCell.RowIndex != rowIndex)
      {
        iGCurRowChangeRequestEventArgs e = new iGCurRowChangeRequestEventArgs(rowIndex, true);
        this.OnCurRowChangeRequest(e);
        if (!e.DoDefault)
          return false;
      }
      if (this.fCurCell.IsEmpty || this.fCurCell.RowIndex != rowIndex || this.fCurCell.ColIndex != colIndex)
      {
        iGCurCellChangeRequestEventArgs e = new iGCurCellChangeRequestEventArgs(rowIndex, colIndex - 1, true);
        this.OnCurCellChangeRequest(e);
        if (!e.DoDefault)
          return false;
      }
      return true;
    }

    private bool CanNavigateToCellCheckColWidth(int rowIndex, int colOrder)
    {
      if (this.CanSelectCell(rowIndex, colOrder, false))
        return this.fColDatas[this.fColIdxFromOrd[colOrder]].Width > 0;
      return false;
    }

    private int GetColOrderOfCellToSelectInRowNoMerged(int rowIndex)
    {
      int num;
      if (this.fCurCell.IsEmpty)
      {
        num = this.GetColOrderOfFirstCellToNavigateInRow(rowIndex);
      }
      else
      {
        num = this.GetColOrder(this.fCurCell.ColIndex);
        if ((num == 0 ? 1 : (this.GetCellKindAsMerged(this.fCurCell) == iGrid.iGCellKindAsMerged.MergedRoot ? 1 : 0)) != 0)
        {
          if (this.fEnterMergedCellColOrder != -1)
            num = this.fEnterMergedCellColOrder;
          if (!this.CanSelectCell(rowIndex, num, false))
            num = this.FindFirstSelectableCellColOrderInRowNoMerged(rowIndex, num);
        }
      }
      return num;
    }

    private int FindFirstSelectableCellColOrderInRowNoMerged(int rowIndex, int startColOrder)
    {
      int drawColOrder = this.ColOrderToDrawColOrder(startColOrder);
      int colDrawOrder = drawColOrder;
      do
      {
        int colOrder = this.DrawColOrderToColOrder(colDrawOrder);
        if (this.CanNavigateToCellCheckColWidth(rowIndex, colOrder))
          return colOrder;
        ++colDrawOrder;
        if (colDrawOrder == this.fColCount)
          colDrawOrder = 0;
      }
      while (colDrawOrder != drawColOrder);
      return -1;
    }

    private bool GetPrevColToNavigate(ref int colOrder)
    {
      for (int colDrawOrder = this.ColOrderToDrawColOrder(colOrder) - 1; colDrawOrder >= 0; --colDrawOrder)
      {
        colOrder = this.DrawColOrderToColOrder(colDrawOrder);
        if (this.CanNavigateToCellsInCol(colOrder))
          return true;
      }
      colOrder = this.DrawColOrderToColOrder(this.fColCount - 1);
      return false;
    }

    private bool GetNextColToNavigate(ref int colOrder)
    {
      for (int colDrawOrder = this.ColOrderToDrawColOrder(colOrder) + 1; colDrawOrder < this.fColCount; ++colDrawOrder)
      {
        colOrder = this.DrawColOrderToColOrder(colDrawOrder);
        if (this.CanNavigateToCellsInCol(colOrder))
          return true;
      }
      colOrder = this.DrawColOrderToColOrder(0);
      return false;
    }

    private bool CanNavigateToCellsInCol(int colOrder)
    {
      if (this.CanSelectCellsInCol(colOrder, false, true))
        return this.fColDatas[this.fColIdxFromOrd[colOrder]].Width > 0;
      return false;
    }

    private bool GetPrevRowToNavigate(ref int rowIndex)
    {
      while (rowIndex > 0)
      {
        rowIndex = rowIndex - 1;
        if (this.CanNavigateToCellsInRow(rowIndex))
          return true;
      }
      return false;
    }

    private bool GetNextRowToNavigate(ref int rowIndex)
    {
      while (rowIndex < this.fRowCount - 1)
      {
        rowIndex = rowIndex + 1;
        if (this.CanNavigateToCellsInRow(rowIndex))
          return true;
      }
      return false;
    }

    private bool CanNavigateToCellsInRow(int rowIndex)
    {
      if (this.CanSelectCellsInRow(rowIndex, false, true))
        return this.GetRowDataInternal(rowIndex).Height > 0;
      return false;
    }

    private int GetColOrderOfFirstCellToNavigateInRow(int rowIndex)
    {
      for (int colDrawOrder = 0; colDrawOrder < this.fColCount; ++colDrawOrder)
      {
        int colOrder = this.DrawColOrderToColOrder(colDrawOrder);
        int rowIndex1 = rowIndex;
        this.IfMergedCellSetRowColToRoot(ref rowIndex1, ref colOrder);
        if (this.CanNavigateToCellCheckColWidth(rowIndex1, colOrder))
          return colOrder;
      }
      return -1;
    }

    private int GetColOrderOfLastCellToNavigateInRow(int rowIndex)
    {
      for (int colDrawOrder = this.fColCount - 1; colDrawOrder >= 0; --colDrawOrder)
      {
        int colOrder = this.DrawColOrderToColOrder(colDrawOrder);
        int rowIndex1 = rowIndex;
        this.IfMergedCellSetRowColToRoot(ref rowIndex1, ref colOrder);
        if (this.CanNavigateToCellCheckColWidth(rowIndex1, colOrder))
          return colOrder;
      }
      return -1;
    }

    private bool SetItemSelectedToTrue(int rowIndex, int colIndex, bool multiSelect, bool invalidate)
    {
      if (this.fRowMode)
        return this.SetRowSelectedToTrue(rowIndex, multiSelect, invalidate);
      return this.SetCellSelectedToTrue(rowIndex, colIndex, multiSelect, invalidate);
    }

    internal bool SetRowSelectedToTrue(int rowIndex, bool multiSelect, bool invalidate)
    {
      int num1 = this.fSelectedRows.Count != 1 ? 0 : (this.fSelectedRows.GetItem(0) == rowIndex ? 1 : 0);
      if (num1 == 0 && !multiSelect)
        this.DeselectAllRows(invalidate, false);
      bool flag = false;
      if (num1 == 0 && !this.fSelectedRows.Contains(rowIndex))
      {
        this.fSelectedRows.Add(rowIndex);
        flag = true;
      }
      if (this.fRedraw & invalidate & flag)
        this.InvalidateRow(rowIndex);
      int num2 = 0;
      return num1 == num2;
    }

    private bool SetCellSelectedToTrue(int rowIndex, int colIndex, bool multiSelect, bool invalidate)
    {
      bool flag1 = this.fSelectedCells.Count == 1 && this.fSelectedCells.GetItem(0) == new iGCellNavigator(rowIndex, colIndex);
      if (!flag1 && !multiSelect)
        this.DeselectAllCells(invalidate, false);
      bool flag2 = false;
      if (!flag1 && !this.GetCellSelectedInternal(rowIndex, colIndex))
      {
        this.fSelectedCells.Add(new iGCellNavigator(rowIndex, colIndex));
        flag2 = true;
      }
      if (this.fRedraw & invalidate & flag2)
        this.InvalidateCell(rowIndex, colIndex);
      return !flag1;
    }

    private bool SetItemSelectedToFalse(int rowIndex, int colIndex, bool invalidate)
    {
      if (this.fRowMode)
        return this.SetRowSelectedToFalse(rowIndex, invalidate);
      return this.SetCellSelectedToFalse(rowIndex, colIndex, invalidate);
    }

    private bool SetRowSelectedToFalse(int rowIndex, bool invalidate)
    {
      int index = this.fSelectedRows.IndexOf(rowIndex);
      if (index < 0)
        return false;
      this.fSelectedRows.RemoveAt(index);
      if (this.fRedraw & invalidate)
        this.InvalidateRow(rowIndex);
      return true;
    }

    private bool SetCellSelectedToFalse(int rowIndex, int colIndex, bool invalidate)
    {
      int index = this.fSelectedCells.IndexOf(new iGCellNavigator(rowIndex, colIndex));
      if (index < 0)
        return false;
      this.fSelectedCells.RemoveAt(index);
      if (this.fRedraw & invalidate)
        this.InvalidateCell(rowIndex, colIndex);
      return true;
    }

    internal bool GetItemSelectedInternal(int rowIndex, int colIndex)
    {
      if (this.fRowMode)
        return this.GetRowSelectedInternal(rowIndex);
      return this.GetCellSelectedInternal(rowIndex, colIndex);
    }

    internal bool GetCellSelectedInternal(int rowIndex, int colIndex)
    {
      return this.fSelectedCells.Contains(new iGCellNavigator(rowIndex, colIndex));
    }

    internal bool GetRowSelectedInternal(int rowIndex)
    {
      if (this.fSelectedRows == null)
        return false;
      return this.fSelectedRows.Contains(rowIndex);
    }

    private void SelectRange(iGCellNavigator navigator1, iGCellNavigator navigator2, bool select)
    {
      if (this.fRowMode)
        this.SelectRangeOfRows(navigator1.RowIndex, navigator2.RowIndex, select);
      else
        this.SelectRangeOfCells(navigator1, navigator2, select);
    }

    private void SelectRangeOfRows(int rowIndex1, int rowIndex2, bool select)
    {
      int min;
      int max;
      this.GetMinMax(rowIndex1, rowIndex2, out min, out max);
      int index = this.fSelectedRows.IndexOf(min);
      for (; min <= max; ++min)
      {
        int startIndex = index < 0 ? ~index : index;
        index = startIndex >= this.fSelectedRows.Count ? ~this.fSelectedRows.Count : this.fSelectedRows.IndexOf(min, startIndex);
        if (index >= 0)
        {
          if (!select)
            this.fSelectedRows.RemoveAt(index);
        }
        else if (select && this.CanSelectRow(min, true))
          this.fSelectedRows.Insert(min, ~index);
      }
    }

    private void SelectRangeOfCells(iGCellNavigator navigator1, iGCellNavigator navigator2, bool select)
    {
      int min1;
      int max1;
      this.GetMinMax(navigator1.RowIndex, navigator2.RowIndex, out min1, out max1);
      int min2;
      int max2;
      this.GetMinMax(this.GetColOrder(navigator1.ColIndex), this.GetColOrder(navigator2.ColIndex), out min2, out max2);
      if (this.fMergedCellCountAll == 0)
      {
        int startIndex1 = this.fSelectedCells.IndexOfRow(min1);
        for (int rowIndex = min1; rowIndex <= max1; ++rowIndex)
        {
          int startIndex2 = startIndex1 < 0 ? ~startIndex1 : startIndex1;
          startIndex1 = startIndex2 >= this.fSelectedCells.Count ? ~this.fSelectedCells.Count : this.fSelectedCells.IndexOfRow(rowIndex, startIndex2);
          for (int colOrder = min2; colOrder <= max2; ++colOrder)
          {
            iGCellNavigator iGcellNavigator = new iGCellNavigator(rowIndex, this.fColIdxFromOrd[colOrder]);
            int index = startIndex1 < 0 ? startIndex1 : this.fSelectedCells.IndexOf(iGcellNavigator, startIndex1);
            if (index >= 0)
            {
              if (!select)
                this.fSelectedCells.RemoveAt(index);
            }
            else if (select && this.CanSelectCell(rowIndex, colOrder, true))
            {
              this.fSelectedCells.Insert(iGcellNavigator, ~index);
              if (startIndex1 < 0)
                startIndex1 = ~startIndex1;
            }
          }
        }
      }
      else
      {
        for (int rowIndex1 = min1; rowIndex1 <= max1; ++rowIndex1)
        {
          for (int index1 = min2; index1 <= max2; ++index1)
          {
            iGrid.iGCellKindAsMerged cellKindAsMerged = this.GetCellKindAsMerged(rowIndex1, this.fColIdxFromOrd[index1]);
            int rowIndex2 = rowIndex1;
            int colOrder = index1;
            this.IfMergedCellSetRowColToRoot(ref rowIndex2, ref colOrder);
            int colIndex = this.fColIdxFromOrd[colOrder];
            iGCellNavigator iGcellNavigator = new iGCellNavigator(rowIndex2, colIndex);
            int index2 = this.fSelectedCells.IndexOf(iGcellNavigator);
            if (index2 >= 0)
            {
              if (!select)
                this.fSelectedCells.RemoveAt(index2);
            }
            else if (select)
            {
              bool flag1;
              if (cellKindAsMerged == iGrid.iGCellKindAsMerged.Normal)
              {
                flag1 = this.CanSelectCell(rowIndex2, colOrder, true);
              }
              else
              {
                bool flag2 = false;
                bool flag3 = false;
                iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex2, colIndex);
                int num;
                int max3;
                this.GetMinMax(rowIndex2, min1, out num, out max3);
                int min3;
                this.GetMinMax(rowIndex2 + cellDataInternal.SpanRows - 1, max1, out min3, out num);
                for (int rowIndex3 = max3; rowIndex3 <= min3; ++rowIndex3)
                {
                  if (this.IsRowVisibleInternal(rowIndex3))
                  {
                    flag2 = true;
                    break;
                  }
                }
                int max4;
                this.GetMinMax(colOrder, min2, out num, out max4);
                int min4;
                this.GetMinMax(colOrder + cellDataInternal.SpanCols - 1, max2, out min4, out num);
                for (int index3 = max4; index3 <= min4; ++index3)
                {
                  if (this.IsColVisible(this.fColIdxFromOrd[index3]))
                  {
                    flag3 = true;
                    break;
                  }
                }
                flag1 = !(flag2 & flag3) ? this.fSelectInvisibleCells : this.CanSelectCell(rowIndex2, colOrder, false, false);
              }
              if (flag1)
                this.fSelectedCells.Insert(iGcellNavigator, ~index2);
            }
          }
        }
      }
    }

    private void SelectAllCells()
    {
      if (this.fRowCount == 0 || this.fRowMode || (this.fSelectionMode == iGSelectionMode.None || this.fSelectionMode == iGSelectionMode.One))
        return;
      this.fSelectedCells.Clear();
      this.fSelectedCells.SetCapacity(this.fRowCount * this.fColCount);
      for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
      {
        for (int colIndex = 1; colIndex < this.fColCount; ++colIndex)
        {
          if (this.CanSelectCell(rowIndex, this.GetColOrder(colIndex), true))
            this.fSelectedCells.Insert(new iGCellNavigator(rowIndex, colIndex), this.fSelectedCells.Count);
        }
      }
      this.DoSelectionChanged();
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void SelectAllRows()
    {
      if (this.fRowCount == 0)
        return;
      if (this.fRowMode)
      {
        if (this.fSelectionMode == iGSelectionMode.None || this.fSelectionMode == iGSelectionMode.One)
          return;
      }
      else if (this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.None || this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.SingleRow)
        return;
      this.fSelectedRows.Clear();
      this.fSelectedRows.SetCapacity(this.fRowCount);
      for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
      {
        if (this.CanSelectRow(rowIndex, true))
          this.fSelectedRows.Insert(rowIndex, this.fSelectedRows.Count);
      }
      this.DoSelectionChanged();
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private bool DeselectAll(bool invalidate, bool generateEvent, bool checkSelectionMode)
    {
      if (checkSelectionMode && (this.fSelectionMode == iGSelectionMode.None || this.fSelectionMode == iGSelectionMode.One))
        return false;
      if (this.fRowMode)
        return this.DeselectAllRows(invalidate, generateEvent);
      return this.DeselectAllCells(invalidate, generateEvent);
    }

    private void DeselectAllCells()
    {
      this.DeselectAllCells(true, true);
    }

    private void DeselectAllRows()
    {
      this.DeselectAllRows(true, true);
    }

    private bool DeselectAllRows(bool invalidate, bool generateEvent)
    {
      if (this.fSelectedRows.Count == 0)
        return false;
      if (this.fRedraw & invalidate)
        this.InvalidateSelectedRows();
      this.fSelectedRows.Clear();
      if (generateEvent)
        this.DoSelectionChanged();
      return true;
    }

    private bool DeselectAllCells(bool invalidate, bool generateEvent)
    {
      if (this.fSelectedCells.Count == 0)
        return false;
      if (this.fRedraw & invalidate)
        this.InvalidateSelectedCells();
      this.fSelectedCells.Clear();
      if (generateEvent)
        this.DoSelectionChanged();
      return true;
    }

    private void InvalidateSelected()
    {
      if (this.fRowMode)
      {
        this.InvalidateSelectedRows();
      }
      else
      {
        this.InvalidateSelectedRows();
        this.InvalidateSelectedCells();
      }
    }

    private void InvalidateSelectedRows()
    {
      if (this.fSelectedRows.Count <= 0)
        return;
      if (this.fSelectedRows.Count == 1)
        this.InvalidateRow(this.fSelectedRows.GetItem(0));
      else
        this.Invalidate();
    }

    private void InvalidateSelectedCells()
    {
      if (this.fSelectedCells.Count <= 0)
        return;
      if (this.fSelectedCells.Count == 1)
      {
        iGCellNavigator iGcellNavigator = this.fSelectedCells.GetItem(0);
        this.InvalidateCell(iGcellNavigator.RowIndex, iGcellNavigator.ColIndex);
      }
      else
        this.Invalidate();
    }

    private void ChangeSelectionOnCurCellChanged(ref bool raiseSelChanged)
    {
      if (this.fSelectionMode != iGSelectionMode.One)
        return;
      if (!this.fCurCell.IsEmpty)
        raiseSelChanged = raiseSelChanged | this.SetItemSelectedToTrue(this.fCurCell.RowIndex, this.fCurCell.ColIndex, false, false);
      else
        raiseSelChanged = raiseSelChanged | this.DeselectAll(false, false, false);
    }

    private bool ChangeSelectionAndCurCellOnMouseDownInCell(Keys modifierKeys)
    {
      int colIndex = this.GetColIndex(this.fMouseData.ColOrder);
      return this.ChangeSelectionAndCurCellOnMouseDownCore(this.fMouseData.RowIndex, colIndex, this.GetColData(colIndex).IncludeInSelect, modifierKeys);
    }

    private void ChangeSelectionAndCurCellOnMouseDownInLevelArea(int rowIndex, Keys modifierKeys)
    {
      this.ChangeSelectionAndCurCellOnMouseDownCore(rowIndex, -1, false, modifierKeys);
    }

    private void ChangeSelectionAndCurCellOnMouseDownInRowHeader(Keys modifierKeys)
    {
      if (this.fRowMode)
        this.ChangeSelectionAndCurCellOnMouseDownCore(this.fMouseData.RowIndex, -1, false, modifierKeys);
      else if (this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.None)
      {
        this.ChangeSelectionAndCurCellOnMouseDownCore(this.fMouseData.RowIndex, -1, false, modifierKeys);
      }
      else
      {
        if (!this.CanSelectRow(this.fMouseData.RowIndex, false))
          return;
        this.ChangeRowSelectionOnRowHdrMouseDownInCellMode(this.fMouseData.RowIndex, (modifierKeys & Keys.Control) == Keys.Control, (modifierKeys & Keys.Shift) == Keys.Shift);
      }
    }

    private bool ChangeSelectionAndCurCellOnMouseDownCore(int rowIndex, int colIndex, bool isColIndexSpecified, Keys modifierKeys)
    {
      if (!isColIndexSpecified)
      {
        colIndex = this.GetColIndexOfCellToSelectWhenNotIncludedInSelectionColIsClicked(rowIndex);
        if (colIndex < 0)
          return false;
      }
      else if (!this.CanSelectCell(rowIndex, this.GetColOrder(colIndex), false, false))
        return false;
      if (!this.CurCellOrRowChangeRequestAccepted(rowIndex, colIndex, false))
        return false;
      this.ChangeSelectionOnCellMouseDown(rowIndex, colIndex, (modifierKeys & Keys.Control) == Keys.Control, (modifierKeys & Keys.Shift) == Keys.Shift, true);
      this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, colIndex), false);
      return true;
    }

    internal void ChangeSelectionOnCurCellKeyboardChange(iGCellNavigator oldCurCell, bool control, bool shift)
    {
      bool flag1 = false;
      switch (this.fSelectionMode)
      {
        case iGSelectionMode.None:
          this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
          return;
        case iGSelectionMode.One:
          this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
          flag1 = this.fCurCell.IsEmpty ? this.DeselectAll(true, false, false) : this.SetItemSelectedToTrue(this.fCurCell.RowIndex, this.fCurCell.ColIndex, false, true);
          break;
        case iGSelectionMode.MultiSimple:
        case iGSelectionMode.MultiExtended:
          if (this.fSelectionMode == iGSelectionMode.MultiExtended)
          {
            if (!shift && !control)
            {
              this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
              if (!this.fCurCell.IsEmpty)
              {
                flag1 = this.SetItemSelectedToTrue(this.fCurCell.RowIndex, this.fCurCell.ColIndex, false, true);
                break;
              }
              break;
            }
            if (!control)
            {
              bool flag2 = flag1 | this.DeselectAll(true, false, false);
            }
          }
          if (!shift)
          {
            this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
            return;
          }
          if (this.fCurCell.IsEmpty)
            return;
          if (oldCurCell.IsEmpty || this.GetRowDataInternal(oldCurCell.RowIndex).Type != iGRowType.Normal && this.fBeginSelectWithShiftCell.IsEmpty)
          {
            flag1 = this.SetItemSelectedToTrue(this.fCurCell.RowIndex, this.fCurCell.ColIndex, true, true);
            break;
          }
          if (this.fBeginSelectWithShiftCell.IsEmpty)
            this.fBeginSelectWithShiftCell = oldCurCell;
          this.SelectRange(this.fBeginSelectWithShiftCell, this.fCurCell, true);
          flag1 = true;
          this.Invalidate();
          break;
      }
      if (!flag1)
        return;
      this.DoSelectionChanged();
    }

    private void ChangeRowSelectionOnRowHdrMouseDownInCellMode(int rowIndex, bool ctrlPressed, bool shiftPressed)
    {
      if (this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.None)
        return;
      bool flag1 = false;
      bool multiSelect = ctrlPressed && this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.MultipleRows;
      if (shiftPressed && this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.MultipleRows && (this.fLastSelectedInCellModeRowIndex >= 0 && this.GetRowDataInternal(rowIndex).Type == iGRowType.Normal))
      {
        bool selectedInternal = this.GetRowSelectedInternal(this.fLastSelectedInCellModeRowIndex);
        if (this.fLastSelectedInCellModeRowIndex != rowIndex)
        {
          if (!multiSelect)
            this.DeselectAllRows(false, false);
          this.SelectRangeOfRows(rowIndex, this.fLastSelectedInCellModeRowIndex, selectedInternal);
          flag1 = true;
          this.Invalidate();
        }
      }
      else
      {
        bool selectedInternal = this.GetRowSelectedInternal(rowIndex);
        bool flag2 = selectedInternal && this.fSelectedRows.Count == 1;
        if (selectedInternal && this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.MultipleRows)
        {
          this.fChangeSelectionOnMouseUp = true;
          this.fCtrlWasPressedWhenMouseDown = ctrlPressed;
        }
        else
        {
          this.fLastSelectedInCellModeRowIndex = rowIndex;
          if (selectedInternal && multiSelect | flag2)
            flag1 |= this.SetRowSelectedToFalse(rowIndex, true);
          else
            flag1 |= this.SetRowSelectedToTrue(rowIndex, multiSelect, true);
        }
      }
      if (!flag1)
        return;
      this.DoSelectionChanged();
    }

    private void ChangeRowSelectionOnRowHdrMouseUpInCellMode(int rowIndex)
    {
      if (!this.fChangeSelectionOnMouseUp)
        return;
      bool flag1 = false;
      bool multiSelect = this.fCtrlWasPressedWhenMouseDown && this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.MultipleRows;
      int num = this.GetRowSelectedInternal(rowIndex) ? 1 : 0;
      bool flag2 = num != 0 && this.fSelectedRows.Count == 1;
      this.fLastSelectedInCellModeRowIndex = rowIndex;
      if (!(num == 0 || !(multiSelect | flag2) ? flag1 | this.SetRowSelectedToTrue(rowIndex, multiSelect, true) : flag1 | this.SetRowSelectedToFalse(rowIndex, true)))
        return;
      this.DoSelectionChanged();
    }

    private void ChangeSelectionOnCellMouseDown(int rowIndex, int colIndex, bool ctrlPressed, bool shiftPressed, bool canDelayTillMouseUp)
    {
      if (this.fSelectionMode == iGSelectionMode.None)
        return;
      bool flag = false;
      bool multiSelect = ctrlPressed && this.fSelectionMode == iGSelectionMode.MultiExtended || this.fSelectionMode == iGSelectionMode.MultiSimple;
      iGCellNavigator navigator1 = new iGCellNavigator(rowIndex, colIndex);
      if (shiftPressed && !this.fCurCell.IsEmpty && (this.fSelectionMode == iGSelectionMode.MultiExtended || this.fSelectionMode == iGSelectionMode.MultiSimple) && (!this.fBeginSelectWithShiftCell.IsEmpty || this.GetRowDataInternal(this.fCurCell.RowIndex).Type == iGRowType.Normal))
      {
        if (this.fBeginSelectWithShiftCell.IsEmpty)
          this.fBeginSelectWithShiftCell = this.fCurCell;
        bool selectedInternal = this.GetItemSelectedInternal(this.fBeginSelectWithShiftCell.RowIndex, this.fBeginSelectWithShiftCell.ColIndex);
        if (this.fCurCell != navigator1)
        {
          if (!multiSelect)
            this.DeselectAll(false, false, false);
          this.SelectRange(navigator1, this.fBeginSelectWithShiftCell, selectedInternal);
          flag = true;
          this.Invalidate();
        }
      }
      else
      {
        this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
        bool selectedInternal = this.GetItemSelectedInternal(navigator1.RowIndex, navigator1.ColIndex);
        if (canDelayTillMouseUp & selectedInternal && (this.fSelectionMode == iGSelectionMode.MultiSimple || this.fSelectionMode == iGSelectionMode.MultiExtended))
        {
          this.fChangeSelectionOnMouseUp = true;
          this.fCtrlWasPressedWhenMouseDown = ctrlPressed;
        }
        else if (selectedInternal & multiSelect)
          flag |= this.SetItemSelectedToFalse(rowIndex, colIndex, true);
        else
          flag |= this.SetItemSelectedToTrue(rowIndex, colIndex, multiSelect, true);
      }
      if (!flag)
        return;
      this.DoSelectionChanged();
    }

    private void ChangeSelectionOnCellMouseUp()
    {
      int colIndex = this.GetColIndex(this.fMouseData.ColOrder);
      this.ChangeSelectionOnMouseUpInternal(this.fMouseData.RowIndex, colIndex, this.GetColData(colIndex).IncludeInSelect);
    }

    private void ChangeSelectionOnLevelAreaMouseUp(int rowIndex)
    {
      this.ChangeSelectionOnMouseUpInternal(rowIndex, -1, false);
    }

    private void ChangeSelectionOnRowHdrMouseUp()
    {
      if (this.fRowMode)
        this.ChangeSelectionOnMouseUpInternal(this.fMouseData.RowIndex, -1, false);
      else if (this.fRowSelectionInCellMode == iGRowSelectionInCellModeTypes.None)
        this.ChangeSelectionOnMouseUpInternal(this.fMouseData.RowIndex, -1, false);
      else
        this.ChangeRowSelectionOnRowHdrMouseUpInCellMode(this.fMouseData.RowIndex);
    }

    private void ChangeSelectionOnMouseUpInternal(int rowIndex, int colIndex, bool isColIndexSpecified)
    {
      if (!this.fChangeSelectionOnMouseUp)
        return;
      if (!isColIndexSpecified)
      {
        colIndex = this.GetColIndexOfCellToSelectWhenNotIncludedInSelectionColIsClicked(rowIndex);
        if (colIndex < 0)
          return;
      }
      else if (!this.CanSelectCell(rowIndex, this.GetColOrder(colIndex), false))
        return;
      bool flag = false;
      bool multiSelect = this.fCtrlWasPressedWhenMouseDown && this.fSelectionMode == iGSelectionMode.MultiExtended || this.fSelectionMode == iGSelectionMode.MultiSimple;
      if (!(!(this.GetItemSelectedInternal(rowIndex, colIndex) & multiSelect) ? flag | this.SetItemSelectedToTrue(rowIndex, colIndex, multiSelect, true) : flag | this.SetItemSelectedToFalse(rowIndex, colIndex, true)))
        return;
      this.DoSelectionChanged();
    }

    private void ResetChangeSelectionOnMouseUp()
    {
      this.fChangeSelectionOnMouseUp = false;
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnGotFocus(EventArgs e)
    {
      this.InvalidateSelected();
      this.InvalidateCurrentCellOrRowIfNecessary();
      base.OnGotFocus(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnLostFocus(EventArgs e)
    {
      this.InvalidateSelected();
      this.InvalidateCurrentCellOrRowIfNecessary();
      this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
      base.OnLostFocus(e);
    }

    /// <summary>Makes the row with the specified key current.</summary>
    /// <param name="rowKey">The key of the row to make current.</param>
    public void SetCurRow(string rowKey)
    {
      this.SetCurRow(this.RowKeyToIndex(rowKey, true));
    }

    /// <summary>Makes the row with the specified index current.</summary>
    /// <param name="rowIndex">The index of the row to make current.</param>
    public void SetCurRow(int rowIndex)
    {
      this.CheckRowIndex(rowIndex);
      if (this.fCurCell.RowIndex == rowIndex)
        return;
      if (this.fCurCell.IsEmpty)
        this.SetFirstCellInRowCurrent(rowIndex);
      else if (this.CanSelectCell(rowIndex, this.GetColOrder(this.fCurCell.ColIndex), false))
        this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, this.fCurCell.ColIndex), true);
      else
        this.SetFirstCellInRowCurrent(rowIndex);
    }

    private void SetFirstCellInRowCurrent(int rowIndex)
    {
      int cellToNavigateInRow = this.GetColOrderOfFirstCellToNavigateInRow(rowIndex);
      if (cellToNavigateInRow < 0)
        this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, 0), true);
      else
        this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, this.fColIdxFromOrd[cellToNavigateInRow]), true);
    }

    /// <summary>Makes the cell with the specified row and column indices current.</summary>
    /// <param name="rowIndex">The row index of the cell to make current.</param>
    /// <param name="colIndex">The column index of the cell to make current.</param>
    public void SetCurCell(int rowIndex, int colIndex)
    {
      int colIndex1 = colIndex + 1;
      this.CheckCellIndices(rowIndex, colIndex1);
      this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, colIndex1), true);
    }

    /// <summary>Makes the cell with the specified row and column keys current.</summary>
    /// <param name="rowKey">The row key of the cell to make current.</param>
    /// <param name="colKey">The column key of the cell to make current.</param>
    public void SetCurCell(string rowKey, string colKey)
    {
      this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(this.RowKeyToIndex(rowKey, true), this.ColKeyToIndex(colKey, true)), true);
    }

    /// <summary>Makes the cell with the specified row key and column index current.</summary>
    /// <param name="rowKey">The row key of the cell to make current.</param>
    /// <param name="colIndex">The column index of the cell to make current.</param>
    public void SetCurCell(string rowKey, int colIndex)
    {
      int index = this.RowKeyToIndex(rowKey, true);
      int colIndex1 = colIndex + 1;
      this.CheckColIndex(colIndex1);
      this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(index, colIndex1), true);
    }

    /// <summary>Makes the cell with the specified row index and column key current.</summary>
    /// <param name="rowIndex">The row index of the cell to make current.</param>
    /// <param name="colKey">The column key of the cell to make current.</param>
    public void SetCurCell(int rowIndex, string colKey)
    {
      this.SetCurCellWithEventsEnsureVisible(new iGCellNavigator(rowIndex, this.ColKeyToIndex(colKey, true)), true);
    }

    private void SetCurCellToNone()
    {
      this.SetCurCellWithEventsEnsureVisible(iGCellNavigator.Empty, true);
    }

    internal void SetCurCellWithEventsEnsureVisible(iGCellNavigator newCurCell, bool initiatedFromCode)
    {
      this.SetCurCellWithEventsEnsureVisibleIfSpecified(newCurCell, initiatedFromCode, true);
    }

    internal void SetCurCellWithEventsEnsureVisibleIfSpecified(iGCellNavigator newCurCell, bool initiatedFromCode, bool ensureVisibleIfRedraw)
    {
      bool raiseCurCellChanged = false;
      bool raiseCurRowChanged = false;
      bool raiseSelChanged = false;
      if (!newCurCell.IsEmpty && this.GetCellKindAsMerged(newCurCell) == iGrid.iGCellKindAsMerged.MergedNonRoot)
      {
        int rowIndex = newCurCell.RowIndex;
        int colOrder = this.GetColOrder(newCurCell.ColIndex);
        this.IfMergedCellSetRowColToRoot(ref rowIndex, ref colOrder);
        newCurCell = new iGCellNavigator(rowIndex, this.fColIdxFromOrd[colOrder]);
      }
      this.SetCurCellNoEvents(newCurCell, initiatedFromCode, initiatedFromCode, ensureVisibleIfRedraw, ref raiseCurCellChanged, ref raiseCurRowChanged, ref raiseSelChanged);
      if (raiseSelChanged)
        this.DoSelectionChanged();
      if (raiseCurCellChanged)
      {
        this.DoCurCellChanged();
        raiseCurCellChanged = false;
      }
      if (!raiseCurRowChanged)
        return;
      this.DoCurRowChanged();
    }

    private void SetCurCellNoEvents(iGCellNavigator newCurCell, bool resetBeginWithShift, bool changeSelection, bool ensureVisibleIfRedraw, ref bool raiseCurCellChanged, ref bool raiseCurRowChanged, ref bool raiseSelChanged)
    {
      this.CancelAnyEdit();
      if (!this.IsSearchAsTypeFilteringActive() && newCurCell.RowIndex != this.fCurCell.RowIndex)
        this.CancelSearchAsType();
      if (!newCurCell.IsEmpty)
      {
        this.CheckRowIndex(newCurCell.RowIndex);
        this.CheckColIndex(newCurCell.ColIndex);
        if (this.fRedraw & ensureVisibleIfRedraw)
          this.EnsureVisibleCell(newCurCell.RowIndex, newCurCell.ColIndex);
      }
      if (newCurCell == this.fCurCell)
        return;
      this.InvalidateCurrentCellOrRowIfNecessary();
      int rowIndex1 = this.fCurCell.RowIndex;
      this.SetCurCellCore(newCurCell);
      this.InvalidateCurrentCellOrRowIfNecessary();
      raiseCurCellChanged = true;
      int rowIndex2 = this.fCurCell.RowIndex;
      if (rowIndex1 != rowIndex2)
        raiseCurRowChanged = true;
      if (resetBeginWithShift)
        this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
      if (!changeSelection)
        return;
      this.ChangeSelectionOnCurCellChanged(ref raiseSelChanged);
    }

    private void SetCurCellCore(iGCellNavigator value)
    {
      if (!value.IsEmpty)
      {
        this.fEnterMergedCellRowIndex = value.RowIndex;
        this.fEnterMergedCellColOrder = this.GetColOrder(value.ColIndex);
      }
      else
      {
        this.fEnterMergedCellRowIndex = -1;
        this.fEnterMergedCellColOrder = -1;
      }
      this.fCurCell = value;
    }

    private void CurCellOnRowRemoved(int rowIndex, int count)
    {
      if (this.fCurCell.RowIndex >= rowIndex)
      {
        if (this.fCurCell.RowIndex < rowIndex + count || this.fCurCell.RowIndex - count < 0)
        {
          int rowIndex1 = this.fCurCell.RowIndex;
          this.SetCurCellCore(iGCellNavigator.Empty);
          this.DoCurCellChanged();
          int rowIndex2 = this.fCurCell.RowIndex;
          if (rowIndex1 != rowIndex2)
            this.DoCurRowChanged();
        }
        else
          this.SetCurCellCore(new iGCellNavigator(this.fCurCell.RowIndex - count, this.fCurCell.ColIndex));
      }
      this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
    }

    private void CurCellOnRowAdded(int rowIndex, int count)
    {
      if (this.fCurCell.RowIndex >= rowIndex)
        this.SetCurCellCore(new iGCellNavigator(this.fCurCell.RowIndex + count, this.fCurCell.ColIndex));
      this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
    }

    private void CurCellOnColRemoved(int colIndex, int count)
    {
      if (this.fCurCell.ColIndex >= colIndex)
      {
        if (this.fCurCell.ColIndex < colIndex + count || this.fCurCell.ColIndex - count < 0)
        {
          int rowIndex1 = this.fCurCell.RowIndex;
          this.SetCurCellCore(iGCellNavigator.Empty);
          this.DoCurCellChanged();
          int rowIndex2 = this.fCurCell.RowIndex;
          if (rowIndex1 != rowIndex2)
            this.DoCurRowChanged();
        }
        else
          this.SetCurCellCore(new iGCellNavigator(this.fCurCell.RowIndex, this.fCurCell.ColIndex - count));
      }
      this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
    }

    private void CurCellOnColAdded(int colIndex, int count)
    {
      if (this.fCurCell.ColIndex >= colIndex)
        this.SetCurCellCore(new iGCellNavigator(this.fCurCell.RowIndex, this.fCurCell.ColIndex + count));
      this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
    }

    private void CurCellOnRowsClear()
    {
      this.SetCurCellCore(iGCellNavigator.Empty);
      this.fBeginSelectWithShiftCell = iGCellNavigator.Empty;
    }

    private void CurCellAfterRowsMove(int srcIndex, int count, int dstIndex)
    {
      if (this.fCurCell.IsEmpty)
        return;
      if (this.fCurCell.RowIndex >= srcIndex && this.fCurCell.RowIndex < srcIndex + count)
        this.SetCurCellCore(new iGCellNavigator(dstIndex + this.fCurCell.RowIndex - srcIndex, this.fCurCell.ColIndex));
      else if (srcIndex < dstIndex)
      {
        if (this.fCurCell.RowIndex <= srcIndex || this.fCurCell.RowIndex >= dstIndex + count)
          return;
        this.SetCurCellCore(new iGCellNavigator(this.fCurCell.RowIndex - count, this.fCurCell.ColIndex));
      }
      else
      {
        if (this.fCurCell.RowIndex >= srcIndex || this.fCurCell.RowIndex < dstIndex)
          return;
        this.SetCurCellCore(new iGCellNavigator(this.fCurCell.RowIndex + count, this.fCurCell.ColIndex));
      }
    }

    private unsafe void CurCellOnSort(iGRowNavigatorMapItem[] map, int rowStartSortIndex)
    {
      if (this.fCurCell.IsEmpty)
        return;
      fixed (iGRowNavigatorMapItem* navigatorMapItemPtr = &map[0])
      {
        for (int index = map.Length - 1; index >= 0; --index)
        {
          if (navigatorMapItemPtr[index].InitialRowIndex == this.fCurCell.RowIndex)
          {
            this.SetCurCellCore(new iGCellNavigator(index + rowStartSortIndex, this.fCurCell.ColIndex));
            if (!this.fRedraw)
              break;
            this.EnsureVisibleRow(index + rowStartSortIndex);
            break;
          }
        }
      }
    }

    private void InvalidateCurrentCellOrRowIfNecessary()
    {
      if (!this.fRedraw || this.fCurCell.IsEmpty)
        return;
      if (this.fRowHeader.Visible)
        this.Invalidate(this.GetRowHdrBounds(this.fCurCell.RowIndex));
      if (this.fRowMode)
        this.InvalidateRow(this.fCurCell.RowIndex);
      else
        this.InvalidateCell(this.fCurCell.RowIndex, this.fCurCell.ColIndex);
    }

    private void DoSelectionChanged()
    {
      this.OnSelectionChanged(EventArgs.Empty);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.SelectionChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnSelectionChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.SelectionChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.SelectionChanged((object) this, e);
    }

    internal void DoCurCellChanged()
    {
      this.OnCurCellChanged(EventArgs.Empty);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CurCellChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnCurCellChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CurCellChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CurCellChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CurCellChangeRequest" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCurCellChangeRequestEventArgs" /> that contains the event data.</param>
    protected virtual void OnCurCellChangeRequest(iGCurCellChangeRequestEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CurCellChangeRequest == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CurCellChangeRequest((object) this, e);
    }

    private void DoCurRowChanged()
    {
      this.OnCurRowChanged(EventArgs.Empty);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CurRowChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnCurRowChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CurRowChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CurRowChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CurRowChangeRequest" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCurRowChangeRequestEventArgs" /> that contains the event data.</param>
    protected virtual void OnCurRowChangeRequest(iGCurRowChangeRequestEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CurRowChangeRequest == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CurRowChangeRequest((object) this, e);
    }

    private bool ShouldSerializeFocusRectColor1()
    {
      return this.fFocusRectColor1 != iGrid.cDefaultFocusRectColor1;
    }

    private bool ShouldSerializeFocusRectColor2()
    {
      return this.fFocusRectColor2 != iGrid.cDefaultFocusRectColor2;
    }

    private bool ShouldSerializeCurCellBackColor()
    {
      return this.fCurCellBackColor != iGrid.cDefaultCurCellBackColor;
    }

    private bool ShouldSerializeCurCellForeColor()
    {
      return this.fCurCellForeColor != iGrid.cDefaultCurCellForeColor;
    }

    private bool ShouldSerializeCurCellBackColorNoFocus()
    {
      return this.fCurCellBackColorNoFocus != iGrid.cDefaultCurCellBackColorNoFocus;
    }

    private bool ShouldSerializeCurCellForeColorNoFocus()
    {
      return this.fCurCellForeColorNoFocus != iGrid.cDefaultCurCellForeColorNoFocus;
    }

    private bool ShouldSerializeSelCellsBackColor()
    {
      return this.fSelCellsBackColor != iGrid.cDefaultSelCellsBackColor;
    }

    private bool ShouldSerializeSelCellsForeColor()
    {
      return this.fSelCellsForeColor != iGrid.cDefaultSelCellsForeColor;
    }

    private bool ShouldSerializeSelCellsBackColorNoFocus()
    {
      return this.fSelCellsBackColorNoFocus != iGrid.cDefaultSelCellsBackColorNoFocus;
    }

    private bool ShouldSerializeSelCellsForeColorNoFocus()
    {
      return this.fSelCellsForeColorNoFocus != iGrid.cDefaultSelCellsForeColorNoFocus;
    }

    private bool ShouldSerializeSelRowsBackColor()
    {
      return this.fSelRowsBackColor != iGrid.cDefaultSelRowsBackColor;
    }

    private bool ShouldSerializeSelRowsForeColor()
    {
      return this.fSelRowsForeColor != iGrid.cDefaultSelRowsForeColor;
    }

    private bool ShouldSerializeSelRowsBackColorNoFocus()
    {
      return this.fSelRowsBackColorNoFocus != iGrid.cDefaultSelRowsBackColorNoFocus;
    }

    private bool ShouldSerializeSelRowsForeColorNoFocus()
    {
      return this.fSelRowsForeColorNoFocus != iGrid.cDefaultSelRowsForeColorNoFocus;
    }

    private void ResetFocusRectColor1()
    {
      this.fFocusRectColor1 = iGrid.cDefaultFocusRectColor1;
    }

    private void ResetFocusRectColor2()
    {
      this.fFocusRectColor2 = iGrid.cDefaultFocusRectColor2;
    }

    private void ResetSelCellsBackColor()
    {
      this.fSelCellsBackColor = iGrid.cDefaultSelCellsBackColor;
    }

    private void ResetSelCellsBackColorNoFocus()
    {
      this.fSelCellsBackColorNoFocus = iGrid.cDefaultSelCellsBackColorNoFocus;
    }

    private void ResetSelCellsForeColor()
    {
      this.fSelCellsForeColor = iGrid.cDefaultSelCellsForeColor;
    }

    private void ResetSelCellsForeColorNoFocus()
    {
      this.fSelCellsForeColorNoFocus = iGrid.cDefaultSelCellsForeColorNoFocus;
    }

    private void ResetSelRowsBackColor()
    {
      this.fSelRowsBackColor = iGrid.cDefaultSelRowsBackColor;
    }

    private void ResetSelRowsBackColorNoFocus()
    {
      this.fSelRowsBackColorNoFocus = iGrid.cDefaultSelRowsBackColorNoFocus;
    }

    private void ResetSelRowsForeColor()
    {
      this.fSelRowsForeColor = iGrid.cDefaultSelRowsForeColor;
    }

    private void ResetSelRowsForeColorNoFocus()
    {
      this.fSelRowsForeColorNoFocus = iGrid.cDefaultSelRowsForeColorNoFocus;
    }

    /// <summary>Gets or sets a value indicating whether to highlight the current cell in row mode.</summary>
    /// <value>True is the current cell is present in row mode; otherwise, False. The default value is False.</value>
    [Category("Behavior")]
    [DefaultValue(false)]
    [Description("Determines whether to highlight the current cell in row mode.")]
    public bool RowModeHasCurCell
    {
      get
      {
        return this.fRowModeHasCurCell;
      }
      set
      {
        if (this.fRowModeHasCurCell == value)
          return;
        this.fRowModeHasCurCell = value;
        if (!this.fRedraw || !this.fRowMode)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets a value indicating whether to select the invisible cells when selecting multiple cells (using a combination with the SHIFT key or mouse pressed move).</summary>
    /// <value>True if the invisible cells are included in selection; otherwise, False.</value>
    [Category("Behavior")]
    [DefaultValue(false)]
    [Description("Determines whether to select the invisible cells when selecting multiple cells (using a combination with the Shift key or mouse pressed move).")]
    public bool SelectInvisibleCells
    {
      get
      {
        return this.fSelectInvisibleCells;
      }
      set
      {
        this.fSelectInvisibleCells = value;
      }
    }

    /// <summary>Gets the collection of the selected cells.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGSelectedCellsCollection" /> object that represents the collection of selected cells.</value>
    [Browsable(false)]
    public iGSelectedCellsCollection SelectedCells
    {
      get
      {
        if (this.fSelectedCellsPublicCollection == null)
          this.fSelectedCellsPublicCollection = new iGSelectedCellsCollection(this, this.fSelectedCells);
        return this.fSelectedCellsPublicCollection;
      }
    }

    /// <summary>Gets the collection of the selected rows.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGSelectedRowsCollection" /> object that represents the selected rows.</value>
    [Browsable(false)]
    public iGSelectedRowsCollection SelectedRows
    {
      get
      {
        if (this.fSelectedRowsPublicCollection == null)
          this.fSelectedRowsPublicCollection = new iGSelectedRowsCollection(this, this.fSelectedRows);
        return this.fSelectedRowsPublicCollection;
      }
    }

    /// <summary>Gets or sets a value indicating whether to display the focus rectangle.</summary>
    /// <value>True if the focus rectangle is displayed; otherwise, False.</value>
    [DefaultValue(true)]
    [Category("Appearance")]
    [Description("Determines whether to display the focus rectangle.")]
    public bool FocusRect
    {
      get
      {
        return this.fFocusRect;
      }
      set
      {
        if (this.fFocusRect == value)
          return;
        this.fFocusRect = value;
        this.InvalidateCurrentCellOrRowIfNecessary();
      }
    }

    /// <summary>Gets or sets the first color of the focus rectangle.</summary>
    /// <value>A color.</value>
    [Category("Appearance")]
    [Description("The first color of the focus rectangle.")]
    public System.Drawing.Color FocusRectColor1
    {
      get
      {
        return this.fFocusRectColor1;
      }
      set
      {
        if (value == this.fFocusRectColor1)
          return;
        this.fFocusRectColor1 = value;
        this.InvalidateCurrentCellOrRowIfNecessary();
      }
    }

    /// <summary>Gets or sets the second color of the focus rectangle.</summary>
    /// <value>A color.</value>
    [Category("Appearance")]
    [Description("The second color of the focus rectangle.")]
    public System.Drawing.Color FocusRectColor2
    {
      get
      {
        return this.fFocusRectColor2;
      }
      set
      {
        if (value == this.fFocusRectColor2)
          return;
        this.fFocusRectColor2 = value;
        this.InvalidateCurrentCellOrRowIfNecessary();
      }
    }

    /// <summary>Gets or sets the color of the text in the current cell.</summary>
    /// <value>The foreground color of the current cell. The default is <see cref="F:System.Drawing.Color.Empty" /> which means that the current cell is drawn using the <see cref="P:TenTec.Windows.iGridLib.iGrid.SelCellsForeColor" />, <see cref="P:TenTec.Windows.iGridLib.iGrid.SelCellsForeColorNoFocus" />, <see cref="P:TenTec.Windows.iGridLib.iGrid.SelRowsForeColor" />, or <see cref="P:TenTec.Windows.iGridLib.iGrid.SelRowsForeColorNoFocus" /> property.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The color of the text in the current cell.")]
    public System.Drawing.Color CurCellForeColor
    {
      get
      {
        return this.fCurCellForeColor;
      }
      set
      {
        if (this.fCurCellForeColor == value)
          return;
        this.fCurCellForeColor = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the background color of the current cell.</summary>
    /// <value>The background color of the current cell. The default is <see cref="F:System.Drawing.Color.Empty" /> which means that the current cell is filled using the <see cref="P:TenTec.Windows.iGridLib.iGrid.SelCellsBackColor" />,  <see cref="P:TenTec.Windows.iGridLib.iGrid.SelCellsBackColorNoFocus" />, <see cref="P:TenTec.Windows.iGridLib.iGrid.SelRowsBackColor" />, or <see cref="P:TenTec.Windows.iGridLib.iGrid.SelRowsBackColorNoFocus" /> property.</value>
    [Category("Appearance")]
    [Description("The background color of the current cell.")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    public System.Drawing.Color CurCellBackColor
    {
      get
      {
        return this.fCurCellBackColor;
      }
      set
      {
        if (value == this.fCurCellBackColor)
          return;
        this.fCurCellBackColor = value;
        if (!this.fRedraw)
          return;
        this.InvalidateCurrentCellOrRowIfNecessary();
      }
    }

    /// <summary>Determines the foreground color of the current cell when the grid does not have input focus.</summary>
    /// <value>A <see cref="T:System.Drawing.Color" /> value. The default value is <see cref="F:System.Drawing.Color.Empty" />.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The color of the text in the current cell when the grid does not have focus.")]
    public System.Drawing.Color CurCellForeColorNoFocus
    {
      get
      {
        return this.fCurCellForeColorNoFocus;
      }
      set
      {
        if (this.fCurCellForeColorNoFocus == value)
          return;
        this.fCurCellForeColorNoFocus = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Determines the background color of the current cell when the grid does not have input focus.</summary>
    /// <value>A <see cref="T:System.Drawing.Color" /> value. The default value is <see cref="F:System.Drawing.Color.Empty" />.</value>
    [Category("Appearance")]
    [Description("The background color of the current cell when the grid does not have focus.")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    public System.Drawing.Color CurCellBackColorNoFocus
    {
      get
      {
        return this.fCurCellBackColorNoFocus;
      }
      set
      {
        if (value == this.fCurCellBackColorNoFocus)
          return;
        this.fCurCellBackColorNoFocus = value;
        if (!this.fRedraw)
          return;
        this.InvalidateCurrentCellOrRowIfNecessary();
      }
    }

    /// <summary>Determines the background color of the selected cells when the grid has the input focus. If the <see cref="P:TenTec.Windows.iGridLib.iGrid.SelRowsBackColor" /> is <see cref="F:System.Drawing.Color.Empty" />, the <see cref="P:TenTec.Windows.iGridLib.iGrid.SelCellsBackColor" /> is also used to highlight selected rows.</summary>
    /// <value>A color. The default is <see cref="P:System.Drawing.SystemColors.Highlight" />.</value>
    [Category("Appearance")]
    [Description("The background color of the selected cells when the grid has focus.")]
    public System.Drawing.Color SelCellsBackColor
    {
      get
      {
        return this.fSelCellsBackColor;
      }
      set
      {
        if (value == this.fSelCellsBackColor)
          return;
        this.fSelCellsBackColor = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Determines the color of the text in the selected cells when the grid has the input focus.</summary>
    /// <value>A color. The default is <see cref="P:System.Drawing.SystemColors.HighlightText" />.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The color of the text in the selected cells when the grid has focus.")]
    public System.Drawing.Color SelCellsForeColor
    {
      get
      {
        return this.fSelCellsForeColor;
      }
      set
      {
        if (value == this.fSelCellsForeColor)
          return;
        this.fSelCellsForeColor = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Determines the color of the text in the selected cells when the grid does not have input focus.</summary>
    /// <value>A color. The default is <see cref="P:System.Drawing.SystemColors.WindowText" />.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The color of the text in the selected cells when the grid does not have focus.")]
    public System.Drawing.Color SelCellsForeColorNoFocus
    {
      get
      {
        return this.fSelCellsForeColorNoFocus;
      }
      set
      {
        if (value == this.fSelCellsForeColorNoFocus)
          return;
        this.fSelCellsForeColorNoFocus = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Determines the background color of the selected cells when the grid does not have input focus.</summary>
    /// <value>A color. The default is <see cref="P:System.Drawing.SystemColors.Control" />.</value>
    [Category("Appearance")]
    [Description("The background color of the selected cells when the grid does not have focus.")]
    public System.Drawing.Color SelCellsBackColorNoFocus
    {
      get
      {
        return this.fSelCellsBackColorNoFocus;
      }
      set
      {
        if (value == this.fSelCellsBackColorNoFocus)
          return;
        this.fSelCellsBackColorNoFocus = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the background color of the cells in the selected rows when the grid has the input focus.</summary>
    /// <value>A color. The default is <see cref="F:System.Drawing.Color.Empty" />.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The background color of the selected rows when the grid has focus.")]
    public System.Drawing.Color SelRowsBackColor
    {
      get
      {
        return this.fSelRowsBackColor;
      }
      set
      {
        if (value == this.fSelRowsBackColor)
          return;
        this.fSelRowsBackColor = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the color of the cell text in the selected rows when the grid has the input focus.</summary>
    /// <value>A color. The default is <see cref="F:System.Drawing.Color.Empty" />.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The color of the text in the selected rows when the grid has focus.")]
    public System.Drawing.Color SelRowsForeColor
    {
      get
      {
        return this.fSelRowsForeColor;
      }
      set
      {
        if (value == this.fSelRowsForeColor)
          return;
        this.fSelRowsForeColor = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the color of the cell text in the selected rows when the grid does not have input focus.</summary>
    /// <value>A color. The default is <see cref="F:System.Drawing.Color.Empty" />.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The color of the text in the selected rows when the grid does not have focus.")]
    public System.Drawing.Color SelRowsForeColorNoFocus
    {
      get
      {
        return this.fSelRowsForeColorNoFocus;
      }
      set
      {
        if (value == this.fSelRowsForeColorNoFocus)
          return;
        this.fSelRowsForeColorNoFocus = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the background color of the cells in the selected rows when the grid does not have input focus.</summary>
    /// <value>A color. The default is <see cref="F:System.Drawing.Color.Empty" />.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The background color of the selected rows when the grid does not have focus.")]
    public System.Drawing.Color SelRowsBackColorNoFocus
    {
      get
      {
        return this.fSelRowsBackColorNoFocus;
      }
      set
      {
        if (value == this.fSelRowsBackColorNoFocus)
          return;
        this.fSelRowsBackColorNoFocus = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Returns the column header which is currently active (highlighted).</summary>
    /// <value>An <see cref="T:TenTec.Windows.iGridLib.iGColHdr" /> object that represents the column header which is currently highlighted.</value>
    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public iGColHdr CurColHdr
    {
      get
      {
        if (this.fColHdrDrawnHot.IsEmpty)
          return (iGColHdr) null;
        return new iGColHdr(this, this.fColHdrDrawnHot.RowIndex, this.fColHdrDrawnHot.ColIndex);
      }
    }

    /// <summary>Gets or sets the cell which has input focus.</summary>
    /// <value>An <see cref="T:TenTec.Windows.iGridLib.iGCell" /> object that represents the current cell, or null (Nothing in VB) if there is no current cell.</value>
    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public iGCell CurCell
    {
      get
      {
        if (this.fCurCell.IsEmpty)
          return (iGCell) null;
        return new iGCell(this, this.fCurCell.RowIndex, this.fCurCell.ColIndex);
      }
      set
      {
        if (value == null)
          this.SetCurCellToNone();
        else
          this.SetCurCell(value.RowIndex, value.ColIndex);
      }
    }

    /// <summary>Get or sets the row which contains the current cell.</summary>
    /// <value>An <see cref="T:TenTec.Windows.iGridLib.iGRow" /> object that represents the current row, or null (Nothing in VB) if there is no current row.</value>
    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public iGRow CurRow
    {
      get
      {
        if (this.fCurCell.IsEmpty)
          return (iGRow) null;
        return new iGRow(this, this.fCurCell.RowIndex);
      }
      set
      {
        if (value == null)
          this.SetCurCellToNone();
        else
          this.SetCurRow(value.Index);
      }
    }

    /// <summary>Gets or sets a value indicating whether to select by row or by cell.</summary>
    /// <value>True if the grid selects by rows; otherwise, False. The default is False.</value>
    [Category("Behavior")]
    [DefaultValue(false)]
    [Description("Determines whether to select by row or by cell.")]
    public bool RowMode
    {
      get
      {
        return this.fRowMode;
      }
      set
      {
        if (value == this.fRowMode)
          return;
        if (this.IsRowTextEnabled(value, this.fRowTextVisible) && this.fRowTextStartColNear < this.fFrozenColCount)
          throw new ArgumentException("Frozen area columns edge cannot break row text cells");
        if (this.IsRowTextDisplayed(value, this.fRowTextVisible, this.fRowTextStartColNear, this.fRowTextEndColFar, this.fColCount) && this.WillMergedCellsIntersectRowTexts(this.fRowTextStartColNear, this.fRowTextEndColFar, this.fColIdxFromOrd, int.MaxValue, 0))
          throw new ArgumentException("Row text cells and merged cells cannot overlap");
        this.fRowMode = value;
        this.AdjustSelectionOnModeChanged();
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the method in which cells are selected in the grid.</summary>
    /// <value>One of the <see cref="T:TenTec.Windows.iGridLib.iGSelectionMode" /> enumeration values. The default is <see cref="F:TenTec.Windows.iGridLib.iGSelectionMode.One" />.</value>
    [Category("Behavior")]
    [DefaultValue(iGSelectionMode.One)]
    [Description("The method in which cells are selected in the grid.")]
    public iGSelectionMode SelectionMode
    {
      get
      {
        return this.fSelectionMode;
      }
      set
      {
        if (this.fSelectionMode == value)
          return;
        this.fSelectionMode = value;
        this.AdjustSelectionOnModeChanged();
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets a value indicating whether the selected cells are highlighted.</summary>
    /// <value>True if the selected cells are highlighted; otherwise, False.</value>
    [Category("Appearance")]
    [DefaultValue(true)]
    [Description("Determines whether the selected cells should be highlighted.")]
    public bool HighlightSelCells
    {
      get
      {
        return this.fHighlightSelCells;
      }
      set
      {
        if (value == this.fHighlightSelCells)
          return;
        this.fHighlightSelCells = value;
        if (!this.fRedraw)
          return;
        this.InvalidateSelected();
      }
    }

    /// <summary>Gets or sets a value indicating which cell parts (controls and images) should be highlighted when the cell or row it is located in is selected.</summary>
    /// <value>One of the <see cref="T:TenTec.Windows.iGridLib.iGHighlightSelCellItems" /> enumeration values.</value>
    [Category("Appearance")]
    [DefaultValue(iGHighlightSelCellItems.None)]
    [Description("Determines whether the images and controls in the selected cells should be highlighted.")]
    public iGHighlightSelCellItems HighlightSelCellItems
    {
      get
      {
        return this.fHighlightSelCellItems;
      }
      set
      {
        if (value == this.fHighlightSelCellItems)
          return;
        this.fHighlightSelCellItems = value;
        if (!this.fRedraw)
          return;
        this.InvalidateSelected();
      }
    }

    /// <summary>Gets or sets a value indicating how many rows can be selected in cell mode.</summary>
    /// <value>One of the <see cref="T:TenTec.Windows.iGridLib.iGRowSelectionInCellModeTypes" /> enumeration members. The default is <see cref="F:TenTec.Windows.iGridLib.iGRowSelectionInCellModeTypes.None" />.</value>
    [Category("Behavior")]
    [DefaultValue(iGRowSelectionInCellModeTypes.None)]
    [Description("Determines whether and how rows can be selected in cell mode.")]
    public iGRowSelectionInCellModeTypes RowSelectionInCellMode
    {
      get
      {
        return this.fRowSelectionInCellMode;
      }
      set
      {
        if (value == this.fRowSelectionInCellMode)
          return;
        this.fRowSelectionInCellMode = value;
        this.AdjustSelectionOnModeChanged();
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Occurs when selection with mouse pressed move is started.</summary>
    [Category("Selection")]
    [Description("Occurs when selection with mouse pressed move is started.")]
    public event iGSelectionStartEndChangeEventHandler SelectionStartChange;

    /// <summary>Occurs while the selection is changing with mouse pressed move.</summary>
    [Category("Selection")]
    [Description("Occurs while the selection is changing with mouse pressed move.")]
    public event iGSelectionChangingEventHandler SelectionChanging;

    /// <summary>Occurs when the selection has been changed with mouse pressed move.</summary>
    [Category("Selection")]
    [Description("Occurs when the selection has been changed with mouse pressed move.")]
    public event iGSelectionStartEndChangeEventHandler SelectionEndChange;

    /// <summary>Occurs when the current cell is changed.</summary>
    [Category("Selection")]
    [Description("Occurs when the current cell is changed.")]
    public event EventHandler CurCellChanged;

    /// <summary>Occurs when the user is about to change the current cell.</summary>
    [Category("Selection")]
    [Description("Occurs when the current cell is about to be changed by the user.")]
    public event iGCurCellChangeRequestEventHandler CurCellChangeRequest;

    /// <summary>Occurs when the current row is changed.</summary>
    [Category("Selection")]
    [Description("Occurs when the current row is changed.")]
    public event EventHandler CurRowChanged;

    /// <summary>Occurs when the user is about to change the current row.</summary>
    [Category("Selection")]
    [Description("Occurs when the current row is about to be changed by the user.")]
    public event iGCurRowChangeRequestEventHandler CurRowChangeRequest;

    /// <summary>Occurs when the selection is changed.</summary>
    [Category("Selection")]
    [Description("Occurs when the selection is changed.")]
    public event EventHandler SelectionChanged;

    /// <summary>Initializes a new instance of the <see cref="T:TenTec.Windows.iGridLib.iGrid" /> class.</summary>
    public iGrid()
    {
      iGrid.fCreateTickCount = Environment.TickCount;
      this.Initialize();
    }

    private void Initialize()
    {
      this.InitializeScrollBars();
      this.InitializeRowHeader();
      this.InitializeData();
      this.fUIStrings = new iGUIStrings(this);
      this.fLayout = new iGLayout(this);
      this.SetStyle(ControlStyles.ResizeRedraw, true);
      this.SetStyle(ControlStyles.DoubleBuffer, true);
      this.BackColor = iGrid.cDefaultBackColor;
      this.ForeColor = iGrid.cDefaultForeColor;
      this.fHeaderControlPaintStyle = new iGControlPaintStyle();
      this.fCellControlPaintStyle = new iGControlPaintStyle();
      SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.SystemEvents_UserPreferenceChanged);
      this.fGridToolTip = new ToolTip();
      this.SetPasswordCharEffective();
    }

    private void InitializeData()
    {
      this.fMergedCells = new iGInternalOrderedCellCollection(this);
      this.fSelectedCells = new iGInternalOrderedCellCollection(this);
      this.fSelectedRows = new iGInternalOrderedRowCollection(this);
      this.fColCollection = new iGColCollection(this);
      this.fRowCollection = new iGRowCollection(this);
      this.fCellCollection = new iGCellCollection(this);
      this.fDefaultCol = new iGColPattern(this);
      this.fDefaultRow = new iGRowPattern();
      this.CreateHeaderData();
      this.AddColRange(0, (iGColPattern[]) null, 1, true);
      this.fRowTextColObject = new iGCol(this, 0);
      this.fAutoGroupRowLevelStyles = new iGCellStyle[1];
      this.fAutoGroupRowLevelStyles[0] = iGInternalInfrastructure.GetDefaultGroupRowStyle().Clone();
      this.fHeaderRowCollection = new iGHdrRowCollection(this);
      this.fColHdrCollection = new iGColHdrCollection(this);
      this.fFooterRowCollection = new iGFooterRowCollection(this);
      this.fFooterCellCollection = new iGFooterCellCollection(this);
      this.CreateFooterData();
    }

    internal static Stream GetResourceStream(string resourceName)
    {
      return Assembly.GetExecutingAssembly().GetManifestResourceStream("TenTec.Windows.iGridLib.Resources." + resourceName);
    }

    /// <summary>Disables updating and redrawing of the grid.</summary>
    public void BeginUpdate()
    {
      if (this.fBeginUpdateCounter == 0)
      {
        this.fRedraw = false;
        this.fAutoHeightHeaderWhenSetRedrawToTrue = false;
        this.fAutoHeightFooterWhenSetRedrawToTrue = false;
        this.fRedrawOffHScrollBarMaxValue = int.MaxValue;
        this.fRedrawOffVScrollBarMaxValue = int.MaxValue;
      }
      this.fBeginUpdateCounter = this.fBeginUpdateCounter + 1;
    }

    /// <summary>Enables updating and redrawing of the grid.</summary>
    public void EndUpdate()
    {
      if (this.fBeginUpdateCounter == 0)
        return;
      this.fBeginUpdateCounter = this.fBeginUpdateCounter - 1;
      if (this.fBeginUpdateCounter != 0)
        return;
      this.fRedraw = true;
      this.RecalcTotals();
      this.fIgnoreAdjustViewportFirstRowVars = true;
      if (this.fHScrollBar.Value > this.fRedrawOffHScrollBarMaxValue)
        this.SetHScrollBarValue(this.fRedrawOffHScrollBarMaxValue, true);
      if (this.fVScrollBar.Value > this.fRedrawOffVScrollBarMaxValue)
        this.SetVScrollBarValue(this.fRedrawOffVScrollBarMaxValue, true);
      this.fIgnoreAdjustViewportFirstRowVars = false;
      this.fOldVScrollValue = this.fVScrollBar.Value;
      this.NullViewportFirstRowVars();
      if (this.fVisibleRowCount != 0)
        this.AdjustViewportFirstRowVars_Plus(0);
      if (this.fAutoHeightHeaderWhenSetRedrawToTrue && this.IsHandleCreated)
        this.AutoHeightHeader(false);
      if (this.fAutoHeightFooterWhenSetRedrawToTrue && this.IsHandleCreated)
        this.AutoHeightFooter(false);
      this.AdjustScrollBars();
      this.Invalidate();
    }

    void ISupportInitialize.BeginInit()
    {
      this.BeginUpdate();
    }

    void ISupportInitialize.EndInit()
    {
      this.EndUpdate();
      if (!this.fDefaultRowHeightAutoSet)
        return;
      int preferredRowHeight = this.GetPreferredRowHeight(true, false);
      this.DefaultRow.Height = preferredRowHeight;
      this.DefaultRow.NormalCellHeight = preferredRowHeight;
      this.DefaultAutoGroupRow.Height = preferredRowHeight;
    }

    /// <summary>This member overrides <see cref="T:System.Windows.Forms.Control" />.<see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />.</summary>
    /// <param name="m">The Windows <see cref="T:System.Windows.Forms.Message" /> to process.</param>
    protected override void WndProc(ref Message m)
    {
      bool flag = false;
      switch (m.Msg)
      {
        case 282:
          flag = this.EnableGestures(ref m);
          break;
        case 533:
          if (this.IsAutoScroll())
          {
            this.AutoScrollOnCaptureChanged(ref m);
            break;
          }
          break;
        case 794:
          this.OnThemeChanged();
          break;
        case 132:
          Point client = this.PointToClient(new Point(m.LParam.ToInt32()));
          if (this.IsPointOverHScrollBar(client.X, client.Y))
          {
            m.Result = (IntPtr) 6;
            return;
          }
          if (this.IsPointOverVScrollBar(client.X, client.Y))
          {
            m.Result = (IntPtr) 7;
            return;
          }
          if (this.IsPointOverSizeBox(client.X, client.Y, false))
          {
            if (this.IsDrawSizeBox())
            {
              if (this.RightToLeft == RightToLeft.Yes)
              {
                m.Result = new IntPtr(16);
                return;
              }
              m.Result = new IntPtr(17);
              return;
            }
            m.Result = (IntPtr) 4;
            return;
          }
          break;
        case 281:
          flag = this.DecodeGesture(ref m);
          break;
        case 31:
        case 6:
        case 8:
          this.EmptyMouse();
          this.CancelSearchAsType();
          break;
        case 33:
          if (this.IsGridInTextEdit() && this.fMouseData.Area == iGMouseArea.Cells && (this.fEditCell.RowIndex == this.fMouseData.RowIndex && this.fEditCell.ColIndex == this.fColIdxFromOrd[this.fMouseData.ColOrder]) && this.fMouseData.ElemControl == iGElemControl.None)
          {
            m.Result = (IntPtr) 4;
            return;
          }
          if (this.fDoNotFocusOnMouseDown)
          {
            m.Result = (IntPtr) 3;
            return;
          }
          break;
      }
      base.WndProc(ref m);
      if (!flag)
        return;
      m.Result = new IntPtr(1);
    }

    private void SystemEvents_UserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e)
    {
      if (e.Category != UserPreferenceCategory.Window && e.Category != UserPreferenceCategory.Color)
        return;
      this.fCellControlPaintStyle.OnSettingChange();
      this.fHeaderControlPaintStyle.OnSettingChange();
      this.fRowHeader.OnSettingChange();
      if (this.fCustomControlPaint != null)
        this.fCustomControlPaint.OnSettingChange();
      int width1 = this.fVScrollBar.Width;
      this.fVScrollBar.SetDefaultWidth();
      int width2 = this.fVScrollBar.Width;
      if (width1 != width2)
        this.OnVScrollBarWidthChanged(EventArgs.Empty);
      int height1 = this.fHScrollBar.Height;
      this.fHScrollBar.SetDefaultHeight();
      int height2 = this.fHScrollBar.Height;
      if (height1 != height2)
        this.OnHScrollBarHeightChanged(EventArgs.Empty);
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(0, 0, false, true, true);
      if (!this.fRedraw)
        return;
      this.AdjustScrollBars();
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnSizeChanged(EventArgs e)
    {
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(0, 0, false, true, true);
      if (this.fRedraw)
      {
        this.AdjustScrollBars();
      }
      else
      {
        this.LayoutVScrollBar(this.GetBorderSize(), this.fHScrollBar.Visible);
        this.LayoutHScrollBar(this.GetBorderSize(), this.fVScrollBar.Visible);
      }
      base.OnSizeChanged(e);
      this.CancelAnyEdit();
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnFontChanged(EventArgs e)
    {
      if (this.fHeaderFont == null)
        this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnContentsChange, true);
      if (this.fFooterFont == null)
        this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnContentsChange, true);
      base.OnFontChanged(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnRightToLeftChanged(EventArgs e)
    {
      this.AdjustScrollBars();
      base.OnRightToLeftChanged(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnForeColorChanged(EventArgs e)
    {
      System.Drawing.Color foreColor = this.ForeColor;
      if ((this.fSpecifiedColors & iGSpecifiedColors.CellsForeColor) == iGSpecifiedColors.None)
        this.SetCellCtrlForeColorDirect(System.Drawing.Color.Empty);
      base.OnForeColorChanged(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnParentBackColorChanged(EventArgs e)
    {
      if ((this.fSpecifiedColors & iGSpecifiedColors.CellsBackColor) == iGSpecifiedColors.None)
        this.SetCellCtrlBackColorDirect(System.Drawing.Color.Empty);
      base.OnParentBackColorChanged(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnParentChanged(EventArgs e)
    {
      if ((this.fSpecifiedColors & iGSpecifiedColors.CellsBackColor) == iGSpecifiedColors.None)
        this.SetCellCtrlBackColorDirect(System.Drawing.Color.Empty);
      base.OnParentChanged(e);
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected override void OnHandleCreated(EventArgs e)
    {
      this.HeaderOnHandleCreated();
      this.FooterOnHandleCreated();
      base.OnHandleCreated(e);
    }

    /// <summary>Releases all resources used by the grid.</summary>
    /// <param name="disposing">True to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    protected override void Dispose(bool disposing)
    {
      if (!this.fDisposed && disposing)
      {
        SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.SystemEvents_UserPreferenceChanged);
        if (this.fDropDownManager != null)
        {
          this.fDropDownManager.Dispose();
          this.fDropDownManager = (iGDropDownManager) null;
        }
        if (this.fTreeBranchPen != null)
        {
          this.fTreeBranchPen.Dispose();
          this.fTreeBranchPen = (Pen) null;
        }
        if (this.fSearchAsTypeObject != null)
        {
          this.fSearchAsTypeObject.Dispose();
          this.fSearchAsTypeObject = (iGSearchAsType) null;
        }
        if (this.fCellControlPaintStyle != null)
        {
          this.fCellControlPaintStyle.Dispose();
          this.fCellControlPaintStyle = (iGControlPaintStyle) null;
        }
        if (this.fHeaderControlPaintStyle != null)
        {
          this.fHeaderControlPaintStyle.Dispose();
          this.fHeaderControlPaintStyle = (iGControlPaintStyle) null;
        }
        if (this.fRowHeader != null)
        {
          this.fRowHeader.Dispose();
          this.fRowHeader = (iGRowHeader) null;
        }
        if (this.fRefreshMouseDataTimer != null)
        {
          this.fRefreshMouseDataTimer.Stop();
          this.fRefreshMouseDataTimer.Dispose();
          this.fRefreshMouseDataTimer = (Timer) null;
        }
      }
      this.fDisposed = true;
      base.Dispose(disposing);
    }

    /// <summary>Displays the About box.</summary>
    public void About()
    {
      int num = (int) new iGAboutForm().ShowDialog((IWin32Window) this);
    }

    /// <summary>Performs the specified predefined actions.</summary>
    /// <param name="action">The predefined action to perform.</param>
    public void PerformAction(iGActions action)
    {
      switch (action)
      {
        case iGActions.GoNextRow:
          this.ActionNextRow(true, false);
          break;
        case iGActions.GoNextCol:
          this.ActionNextCol(true);
          break;
        case iGActions.GoNextPage:
          this.ActionNextPage(true, false);
          break;
        case iGActions.GoPrevRow:
          this.ActionPrevRow(true, false);
          break;
        case iGActions.GoPrevCol:
          this.ActionPrevCol(true);
          break;
        case iGActions.GoPrevPage:
          this.ActionPrevPage(true, false);
          break;
        case iGActions.GoFirstRow:
          this.ActionFirstRow(true, false);
          break;
        case iGActions.GoFirstCol:
          this.ActionFirstCol(true);
          break;
        case iGActions.GoLastRow:
          this.ActionLastRow(true, false);
          break;
        case iGActions.GoLastCol:
          this.ActionLastCol(true);
          break;
        case iGActions.GoFirstCell:
          this.ActionFirstRowCol(true, false);
          break;
        case iGActions.GoLastCell:
          this.ActionLastRowCol(true, false);
          break;
        case iGActions.SelectAllCells:
          this.SelectAllCells();
          break;
        case iGActions.DeselectAllCells:
          this.DeselectAllCells();
          break;
        case iGActions.SelectAllRows:
          this.SelectAllRows();
          break;
        case iGActions.DeselectAllRows:
          this.DeselectAllRows();
          break;
        case iGActions.ExpandAll:
          this.ExpandCollapseAll(true);
          break;
        case iGActions.CollapseAll:
          this.ExpandCollapseAll(false);
          break;
      }
    }

    private void SetCellCtrlBackColorDirect(System.Drawing.Color value)
    {
      if (value.IsEmpty)
      {
        value = this.Parent == null ? iGControlPaintStyle.cDefaultBackColor : this.Parent.BackColor;
        this.fSpecifiedColors = this.fSpecifiedColors & ~iGSpecifiedColors.CellsBackColor;
      }
      else
        this.fSpecifiedColors = this.fSpecifiedColors | iGSpecifiedColors.CellsBackColor;
      this.fCellControlPaintStyle.BackColor = value;
      if ((this.fSpecifiedColors & iGSpecifiedColors.HeaderBackColor) == iGSpecifiedColors.None)
        this.fHeaderControlPaintStyle.BackColor = value;
      if ((this.fSpecifiedColors & iGSpecifiedColors.ScrollBackColor) == iGSpecifiedColors.None)
      {
        this.fHScrollBar.BackColor = value;
        this.fVScrollBar.BackColor = value;
      }
      this.fRowHeader.OnParentColorChanged();
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void SetCellCtrlForeColorDirect(System.Drawing.Color value)
    {
      if (value == System.Drawing.Color.Empty)
      {
        value = this.ForeColor;
        this.fSpecifiedColors = this.fSpecifiedColors & ~iGSpecifiedColors.CellsForeColor;
      }
      else
        this.fSpecifiedColors = this.fSpecifiedColors | iGSpecifiedColors.CellsForeColor;
      this.fCellControlPaintStyle.ForeColor = value;
      if ((this.fSpecifiedColors & iGSpecifiedColors.HeaderSolidSortIconColor) == iGSpecifiedColors.None)
        this.fHeaderControlPaintStyle.ForeColor = value;
      if ((this.fSpecifiedColors & iGSpecifiedColors.ScrollForeColor) == iGSpecifiedColors.None)
      {
        this.fHScrollBar.ForeColor = value;
        this.fVScrollBar.ForeColor = value;
      }
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private bool IsCellInClientScrollableArea(int rowIndex, int colOrder, bool checkVert, bool checkHorz)
    {
      if (!checkVert && !checkHorz)
        return true;
      Rectangle cellBounds = this.GetCellBounds(rowIndex, colOrder, false);
      Rectangle rectangle = this.ClipFrozenArea(this.GetCellsAreaBoundsNoRowHdr(), rowIndex >= this.fFrozenRowCount, colOrder >= this.fFrozenColCount);
      return (!checkVert || cellBounds.Y >= rectangle.Y && cellBounds.Bottom <= rectangle.Bottom) && (!checkHorz || cellBounds.X >= rectangle.X && cellBounds.Right <= rectangle.Right);
    }

    private Rectangle ClipFrozenArea(Rectangle rect, bool clipRows, bool clipCols)
    {
      int borderSize = this.GetBorderSize();
      int num1 = this.fRowHeader.EffectiveWidth();
      if (this.fFrozenColCount > 1 & clipCols)
      {
        if (this.RightToLeft == RightToLeft.Yes)
        {
          int num2 = rect.X + rect.Width - (this.Width - this.fFrozenColsWidth - num1 - borderSize);
          if (num2 > 0)
            rect.Width -= num2;
        }
        else
        {
          int num2 = this.fFrozenColsWidth + num1 + borderSize - rect.X;
          if (num2 > 0)
          {
            rect.Width -= num2;
            rect.X += num2;
          }
        }
      }
      if (this.fFrozenRowCount > 0 & clipRows)
      {
        int num2 = this.GetHeaderAreaHeight() + this.fFrozenRowsHeight + borderSize - rect.Y;
        if (num2 > 0)
        {
          rect.Height -= num2;
          rect.Y += num2;
        }
      }
      return rect;
    }

    private void SetPasswordCharEffective()
    {
      if ((int) this.fPasswordChar != 0)
      {
        this.fPasswordCharEffective = this.fPasswordChar;
      }
      else
      {
        System.Windows.Forms.TextBox textBox = new System.Windows.Forms.TextBox();
        textBox.UseSystemPasswordChar = true;
        this.fPasswordCharEffective = (char) (int) iGNativeMethods.SendMessage(textBox.Handle, 210, IntPtr.Zero, IntPtr.Zero);
        textBox.Dispose();
      }
    }

    private bool IsTreeColSpecified()
    {
      return this.fTreeColIndex >= 1;
    }

    private void ClearTreeColIndex()
    {
      this.fTreeColIndex = -1;
    }

    private bool IsTreeCol(int colIndex)
    {
      return colIndex == this.fTreeColIndex;
    }

    internal void OnThemeChanged()
    {
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnThemeChange, true);
      this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnThemeChange, true);
    }

    internal void RefreshGridAndScrollBarsIfRedraw()
    {
      this.RefreshGridAndScrollBarsIfRedraw(true);
    }

    internal void RefreshGridAndScrollBarsIfRedraw(bool adjustScrollBars)
    {
      if (this.fRedraw)
      {
        if (adjustScrollBars)
          this.AdjustScrollBars();
        this.Invalidate();
      }
      else
      {
        if (!adjustScrollBars || !this.fAdjustScrollBarValuesRedrawOff)
          return;
        this.AdjustScrollBars();
      }
    }

    private void GridToolTipInitFromMouseData()
    {
      if (this.fMouseData.IsEmpty)
        return;
      switch (this.fMouseData.Area)
      {
        case iGMouseArea.Cells:
          this.GridToolTipInit(iGGridSection.Cells, this.fMouseData.RowIndex, this.GetColIndex(this.fMouseData.ColOrder), new iGColHdrKind?(), new iGFooterCellKind?());
          break;
        case iGMouseArea.Header:
          this.GridToolTipInit(iGGridSection.Header, this.fMouseData.RowIndex, this.GetColIndexOfColHdrFromMouseData(), new iGColHdrKind?(this.GetColHdrKindFromMouseData()), new iGFooterCellKind?());
          break;
        case iGMouseArea.Footer:
          this.GridToolTipInit(iGGridSection.Footer, this.fMouseData.RowIndex, this.GetColIndexOfFooterCellFromMouseData(), new iGColHdrKind?(), new iGFooterCellKind?(this.GetFooterCellKindFromMouseData()));
          break;
      }
    }

    private void GridToolTipInit(iGGridSection gridSection, int rowIndex, int colIndex, iGColHdrKind? colHdrKind, iGFooterCellKind? footerCellKind)
    {
      object myCellDataValue;
      object myCellDataAuxValue;
      int myCellDataImageIndex;
      iGStyleBase myCellStyle;
      iGStyleBase myRowStyle;
      iGStyleBase myColStyle;
      this.GetUniCellDataAndStyles(gridSection, rowIndex, colIndex, out myCellDataValue, out myCellDataAuxValue, out myCellDataImageIndex, out myCellStyle, out myRowStyle, out myColStyle);
      iGrid.iGCellContents contentsInternal = this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, myCellDataValue, myCellDataAuxValue, myCellDataImageIndex, myCellStyle, myRowStyle, myColStyle);
      this.fToolTipTextForCell = (string) null;
      bool flag = true;
      switch (gridSection)
      {
        case iGGridSection.Header:
          if (colHdrKind.Value != iGColHdrKind.Normal || this.fMouseData.IsGroupBox)
          {
            flag = false;
            break;
          }
          break;
        case iGGridSection.Cells:
          if ((this.GetPropFromStyles_DrawTypeFlags(myCellStyle, myRowStyle, myColStyle) & iGCellDrawTypeFlags.Password) == iGCellDrawTypeFlags.Password)
          {
            flag = false;
            break;
          }
          break;
        case iGGridSection.Footer:
          if (footerCellKind.Value != iGFooterCellKind.Normal)
          {
            flag = false;
            break;
          }
          break;
      }
      if (flag && this.IsUniCellPartClippedInternal(gridSection, rowIndex, colIndex, iGClippedCellParts.Text | iGClippedCellParts.CheckBox, true, contentsInternal, myCellStyle, myRowStyle, myColStyle))
        this.fToolTipTextForCell = contentsInternal.Text;
      if (this.fToolTipTextForCell != null && this.fToolTipTextForCell.Length > 300)
        this.fToolTipTextForCell = this.fToolTipTextForCell.Substring(0, 300) + "…";
      switch (gridSection)
      {
        case iGGridSection.Header:
          this.DoRequestColHdrToolTipText(rowIndex, colIndex, colHdrKind.Value, ref this.fToolTipTextForCell);
          break;
        case iGGridSection.Cells:
          this.DoRequestCellToolTipText(rowIndex, colIndex, ref this.fToolTipTextForCell);
          break;
        case iGGridSection.Footer:
          this.DoRequestFooterCellToolTipText(rowIndex, colIndex, footerCellKind.Value, ref this.fToolTipTextForCell);
          break;
      }
      if (string.IsNullOrEmpty(this.fToolTipTextForCell))
        this.GridToolTipClear();
      else
        this.GridToolTipSetTo(this.fToolTipTextForCell);
    }

    private void GridToolTipAdjustForElemControl(int rowIndex, int colIndex, bool isHeader, iGElemControl elemControl)
    {
      string toolTipTextForCell = this.fToolTipTextForCell;
      if (isHeader)
        this.DoRequestColHdrElemControlToolTipText(rowIndex, colIndex, elemControl, ref toolTipTextForCell);
      else
        this.DoRequestCellElemControlToolTipText(rowIndex, colIndex, elemControl, ref toolTipTextForCell);
      this.fToolTipTextForCellControlDiffers = this.fToolTipTextForCell != toolTipTextForCell;
      if (!this.fToolTipTextForCellControlDiffers)
        return;
      this.GridToolTipSetTo(toolTipTextForCell);
    }

    private void GridToolTipClear()
    {
      this.fGridToolTip.SetToolTip((Control) this, (string) null);
    }

    private void GridToolTipSetTo(string tipText)
    {
      this.fGridToolTip.SetToolTip((Control) this, tipText);
    }

    private int GetPreferredCellHeight(Graphics grfx, iGCellStyle colCellStyle, string cellDataValue, int cellDataImageIndex)
    {
      Font uniCellFont = this.GetUniCellFont(iGGridSection.Cells, -1, int.MinValue, (iGStyleBase) null, (iGStyleBase) this.fDefaultRow.CellStyle, (iGStyleBase) colCellStyle, iGControlState.Normal, false, false, false, false);
      return this.GetUniCellContentsHeight(iGGridSection.Cells, grfx, -1, int.MinValue, uniCellFont, int.MaxValue, (object) cellDataValue, (object) null, cellDataImageIndex, (iGStyleBase) null, (iGStyleBase) this.fDefaultRow.CellStyle, (iGStyleBase) colCellStyle);
    }

    /// <summary>Returns the row height necessary to display the cell images and/or text entirely. The height calculation is based on grid properties and the column styles.</summary>
    /// <param name="hasText">Indicates whether the default row has the text in the cells.</param>
    /// <param name="hasImage">Indicates whether the default row has the images in the cells.</param>
    /// <returns>The height needed to hold the specified contents.</returns>
    public int GetPreferredRowHeight(bool hasText, bool hasImage)
    {
      string cellDataValue = !hasText ? (string) null : "Test";
      int cellDataImageIndex = !hasImage ? -1 : 0;
      using (Graphics graphics = this.CreateGraphics())
      {
        int num = 0;
        if (this.fColCount == 1)
        {
          iGCellStyle cellStyle = this.fDefaultCol.CellStyle;
          num = this.GetPreferredCellHeight(graphics, cellStyle, cellDataValue, cellDataImageIndex);
        }
        else
        {
          for (int index = 1; index < this.fColCount; ++index)
          {
            iGCellStyle cellStyle = this.fColDatas[this.fColIdxFromOrd[index]].CellStyle;
            int preferredCellHeight = this.GetPreferredCellHeight(graphics, cellStyle, cellDataValue, cellDataImageIndex);
            if (preferredCellHeight > num)
              num = preferredCellHeight;
          }
        }
        return num + this.fHGridLinesStyle.Width;
      }
    }

    /// <summary>Adjusts the width of all the columns to place all of them to the visible area.</summary>
    public void DoAutoResizeCols()
    {
      this.DoAutoResizeCols(0, 0, true, true, true);
    }

    private void DoAutoResizeCols(bool adjustScrollBars)
    {
      this.DoAutoResizeCols(0, 0, adjustScrollBars, true, true);
    }

    private void NullOldColWidths()
    {
      this.fOldColsWidths = (int[]) null;
    }

    internal void DoAutoResizeCols(int exceptColOrder, int exceptColCount, bool adjustScrollBars, bool autoHeightHeaderIfNeed, bool autoHeightFooterIfNeed)
    {
      if (this.fOldColsWidths == null)
      {
        this.GetDataForSetColsWidths(0, this.fColCount, out this.fVisibleAllowSizeCount, out this.fOldColsWidths);
        this.fOldColsWidth = this.fVisibleColsWidthPlusGroupObjectLevelArea;
      }
      int borderSize = this.GetBorderSize();
      int num1 = this.fRowHeader.EffectiveWidth();
      int num2 = this.Width - 2 * borderSize - num1;
      if (this.GetScrollBarVisible(this.fVisibleRowsHeight, this.Height - 2 * borderSize - this.GetHeaderAreaHeight(), this.fVScrollBarVisibility))
        num2 -= this.fVScrollBar.Width;
      int visibleAllowSizeCount = this.fVisibleAllowSizeCount;
      bool[] flagArray = new bool[exceptColCount];
      int delta = num2 - this.fOldColsWidth;
      for (int index = exceptColOrder + exceptColCount - 1; index >= exceptColOrder; --index)
      {
        int colIndex = this.fColIdxFromOrd[index];
        iGColData fColData = this.fColDatas[colIndex];
        if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
        {
          if (fColData.AllowSizing)
            --visibleAllowSizeCount;
          delta -= fColData.Width - this.fOldColsWidths[index];
        }
        flagArray[index - exceptColOrder] = fColData.AllowSizing;
        this.fColDatas[colIndex].AllowSizing = false;
      }
      if (this.SetColsWidths(0, this.fOldColsWidths, visibleAllowSizeCount, delta) != 0)
      {
        if (autoHeightHeaderIfNeed)
          this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnResizeCol, false);
        if (autoHeightFooterIfNeed)
          this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnResizeCol, false);
        if (this.fRedraw & adjustScrollBars)
        {
          this.AdjustScrollBars();
          this.Invalidate();
        }
      }
      for (int index = exceptColOrder + exceptColCount - 1; index >= exceptColOrder; --index)
        this.fColDatas[this.fColIdxFromOrd[index]].AllowSizing = flagArray[index - exceptColOrder];
    }

    private IiGControlPaint GetGridSectionControlPaint(iGGridSection gridSection)
    {
      IiGControlPaint iGcontrolPaint = (IiGControlPaint) null;
      if (gridSection != iGGridSection.Header)
      {
        if ((uint) (gridSection - 1) <= 1U)
          iGcontrolPaint = (IiGControlPaint) this.fCellControlPaintStyle.ControlPaint;
      }
      else
        iGcontrolPaint = (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint;
      return iGcontrolPaint;
    }

    private int GetUniCellContentsWidth(iGGridSection gridSection, Graphics g, Font font, int cellContentHeight, int cellContentWidth, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, int rowIndex, int colIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle, bool includeCellButtons)
    {
      int num1 = 0;
      int num2 = 0;
      if (includeCellButtons)
      {
        int num3 = this.GetComboSize(int.MaxValue, int.MaxValue).Width + this.cComboIndent;
        if ((this.GetPropFromStyles_DrawTypeFlags(cellStyle, rowStyle, colStyle) & iGCellDrawTypeFlags.HasEllipsisButton) != iGCellDrawTypeFlags.None)
          num2 += num3;
        if (this.ShouldDrawComboButton(rowIndex, colIndex, cellStyle, rowStyle, colStyle))
          num2 += num3;
      }
      int num4;
      if ((this.GetPropFromStyles_CustomDrawFlags(cellStyle, rowStyle, colStyle) & iGCustomDrawFlags.Foreground) != iGCustomDrawFlags.None)
      {
        switch (gridSection)
        {
          case iGGridSection.Header:
            iGCustomDrawColHdrGetWidthEventArgs e1 = new iGCustomDrawColHdrGetWidthEventArgs(rowIndex, colIndex - 1, cellContentHeight);
            this.OnCustomDrawColHdrGetWidth(e1);
            num1 = e1.Width;
            break;
          case iGGridSection.Cells:
            iGCustomDrawCellGetWidthEventArgs e2 = new iGCustomDrawCellGetWidthEventArgs(rowIndex, colIndex - 1, cellContentHeight);
            this.OnCustomDrawCellGetWidth(e2);
            num1 = e2.Width;
            break;
          case iGGridSection.Footer:
            iGCustomDrawFooterCellGetWidthEventArgs e3 = new iGCustomDrawFooterCellGetWidthEventArgs(rowIndex, colIndex - 1, cellContentHeight);
            this.OnCustomDrawFooterCellGetWidth(e3);
            num1 = e3.Width;
            break;
        }
        num4 = num1 + num2;
      }
      else
      {
        iGIndent stylesContentIndent = this.GetPropFromStyles_ContentIndent(cellStyle, rowStyle, colStyle);
        iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType(cellStyle, rowStyle, colStyle);
        iGCellDrawTypeFlags stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags(cellStyle, rowStyle, colStyle);
        iGCellDrawFlags fromStylesDrawFlags = this.GetPropFromStyles_DrawFlags(cellStyle, rowStyle, colStyle);
        IiGDropDownControl cellDropDownControl = this.GetUniCellDropDownControl(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle, false);
        IiGControlPaint sectionControlPaint = this.GetGridSectionControlPaint(gridSection);
        if (fromStylesDrawType == iGCellDrawType.Check)
        {
          num4 = this.GetCheckSize(sectionControlPaint, int.MaxValue, int.MaxValue, new iGIndent()) + (stylesContentIndent.fLeft + stylesContentIndent.fRight);
        }
        else
        {
          iGrid.iGCellContents contentsInternal = this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle, fromStylesDrawType, stylesDrawTypeFlags, fromStylesDrawFlags, cellDropDownControl);
          Size imageSize = !this.IsCellImageReallyDrawn(contentsInternal) ? Size.Empty : contentsInternal.ImageList.ImageSize;
          if (this.IsCellTextReallyDrawn(contentsInternal))
          {
            int num3 = (int) ((double) font.GetHeight(g) + 0.99);
            StringFormat cellStringFormat = this.GetUniCellStringFormat(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle);
            ContentAlignment stylesImageAlign = this.GetPropFromStyles_ImageAlign(cellStyle, rowStyle, colStyle);
            iGIndent indentNoRightToLeft = this.GetCellTextIndent_NoRightToLeft(cellStyle, rowStyle, colStyle, imageSize, stylesContentIndent, stylesImageAlign);
            iGTextPosToImage stylesTextPosToImage = this.GetPropFromStyles_TextPosToImage(cellStyle, rowStyle, colStyle);
            int num5 = stylesTextPosToImage == iGTextPosToImage.Vertically ? 1 : (stylesTextPosToImage == iGTextPosToImage.Over ? 1 : 0);
            int num6;
            if ((cellStringFormat.FormatFlags & StringFormatFlags.DirectionVertical) > (StringFormatFlags) 0)
            {
              num6 = num3 + 4;
            }
            else
            {
              int availableHeight = cellContentHeight - indentNoRightToLeft.fTop - indentNoRightToLeft.fBottom;
              if (cellContentWidth != int.MinValue)
              {
                g.TextRenderingHint = this.fTextRenderingHint;
                num6 = (int) Math.Ceiling((double) g.MeasureString(contentsInternal.Text, font, cellContentWidth - (num2 + indentNoRightToLeft.fLeft + indentNoRightToLeft.fRight), cellStringFormat).Width);
              }
              else
                num6 = this.GetTextWidth(contentsInternal.Text, g, font, cellStringFormat, availableHeight);
            }
            num4 = num5 == 0 || num6 >= imageSize.Width ? num2 + num6 + indentNoRightToLeft.fLeft + indentNoRightToLeft.fRight : num2 + imageSize.Width + stylesContentIndent.fLeft + stylesContentIndent.fRight;
          }
          else
            num4 = num2 + imageSize.Width + stylesContentIndent.fLeft + stylesContentIndent.fRight;
        }
        if (num4 <= 0)
          num4 = 0;
      }
      return num4;
    }

    private int GetCellContentsHeight(Graphics g, int rowIndex, int colOrder, int cellContentWidth, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      Font uniCellFont = this.GetUniCellFont(iGGridSection.Cells, rowIndex, this.GetColIndex(colOrder), cellStyle, rowStyle, colStyle, iGControlState.Normal, false, false, false, false);
      return this.GetUniCellContentsHeight(iGGridSection.Cells, g, rowIndex, colOrder, uniCellFont, cellContentWidth, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle);
    }

    private int GetUniCellContentsHeight(iGGridSection gridSection, Graphics g, int rowIndex, int colOrder, Font font, int cellContentWidth, object cellDataValue, object cellDataAuxValue, int cellDataImageIndex, iGStyleBase cellStyle, iGStyleBase rowStyle, iGStyleBase colStyle)
    {
      int colIndex = -1;
      if (rowIndex != -1)
        colIndex = this.fColIdxFromOrd[colOrder];
      int num1 = 0;
      iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType(cellStyle, rowStyle, colStyle);
      iGCellDrawTypeFlags stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags(cellStyle, rowStyle, colStyle);
      iGCellDrawFlags fromStylesDrawFlags = this.GetPropFromStyles_DrawFlags(cellStyle, rowStyle, colStyle);
      int num2 = (uint) (this.GetPropFromStyles_CustomDrawFlags(cellStyle, rowStyle, colStyle) & iGCustomDrawFlags.Foreground) > 0U ? 1 : 0;
      IiGControlPaint sectionControlPaint = this.GetGridSectionControlPaint(gridSection);
      IiGDropDownControl cellDropDownControl = this.GetUniCellDropDownControl(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle, false);
      int num3 = 0;
      int num4 = 0;
      bool flag1 = this.ShouldDrawComboButton(fromStylesDrawType, stylesDrawTypeFlags, cellDropDownControl);
      bool flag2 = (uint) (stylesDrawTypeFlags & iGCellDrawTypeFlags.HasEllipsisButton) > 0U;
      if (flag1 | flag2)
      {
        Size comboSize = this.GetComboSize(int.MaxValue, int.MaxValue);
        num3 = comboSize.Height + 2 * this.cComboIndent;
        if (flag1)
          num4 += comboSize.Width + this.cComboIndent;
        if (flag2)
          num4 += comboSize.Width + this.cComboIndent;
      }
      if (num2 != 0)
      {
        switch (gridSection)
        {
          case iGGridSection.Header:
            iGCustomDrawColHdrGetHeightEventArgs e1 = new iGCustomDrawColHdrGetHeightEventArgs(rowIndex, colIndex - 1, cellContentWidth);
            this.OnCustomDrawColHdrGetHeight(e1);
            num1 = e1.Height;
            break;
          case iGGridSection.Cells:
            iGCustomDrawCellGetHeightEventArgs e2 = new iGCustomDrawCellGetHeightEventArgs(rowIndex, colIndex - 1, cellContentWidth);
            this.OnCustomDrawCellGetHeight(e2);
            num1 = e2.Height;
            break;
          case iGGridSection.Footer:
            iGCustomDrawFooterCellGetHeightEventArgs e3 = new iGCustomDrawFooterCellGetHeightEventArgs(rowIndex, colIndex - 1, cellContentWidth);
            this.OnCustomDrawFooterCellGetHeight(e3);
            num1 = e3.Height;
            break;
        }
        if (num3 > num1)
          num1 = num3;
      }
      else
      {
        iGIndent stylesContentIndent = this.GetPropFromStyles_ContentIndent(cellStyle, rowStyle, colStyle);
        if (fromStylesDrawType == iGCellDrawType.Check)
        {
          num1 = this.GetCheckSize(sectionControlPaint, int.MaxValue, int.MaxValue, new iGIndent()) + stylesContentIndent.fTop + stylesContentIndent.fBottom;
        }
        else
        {
          iGrid.iGCellContents contentsInternal;
          if (rowIndex == -1)
          {
            contentsInternal.Text = cellDataValue == null ? (string) null : cellDataValue.ToString();
            contentsInternal.DrawText = true;
            contentsInternal.ImageIndex = cellDataImageIndex;
            contentsInternal.ImageList = this.GetUniCellImageList(gridSection, cellStyle, rowStyle, colStyle, fromStylesDrawType, cellDropDownControl);
            contentsInternal.DrawImage = true;
            contentsInternal.CheckState = CheckState.Indeterminate;
          }
          else
            contentsInternal = this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, cellDataValue, cellDataAuxValue, cellDataImageIndex, cellStyle, rowStyle, colStyle, fromStylesDrawType, stylesDrawTypeFlags, fromStylesDrawFlags, cellDropDownControl);
          num1 = num3;
          Size imageSize = !this.IsCellImageReallyDrawn(contentsInternal) ? Size.Empty : contentsInternal.ImageList.ImageSize;
          int num5 = 0;
          if (this.IsCellTextReallyDrawn(contentsInternal))
          {
            ContentAlignment stylesImageAlign = this.GetPropFromStyles_ImageAlign(cellStyle, rowStyle, colStyle);
            StringFormat cellStringFormat = this.GetUniCellStringFormat(gridSection, rowIndex, colIndex, cellStyle, rowStyle, colStyle);
            iGIndent indentNoRightToLeft = this.GetCellTextIndent_NoRightToLeft(cellStyle, rowStyle, colStyle, imageSize, stylesContentIndent, stylesImageAlign);
            cellContentWidth -= indentNoRightToLeft.fLeft + indentNoRightToLeft.fRight + num4;
            num5 = this.GetTextHeight(contentsInternal.Text, g, font, cellStringFormat, cellContentWidth) + (indentNoRightToLeft.fBottom + indentNoRightToLeft.fTop);
          }
          if (num5 == 0 && rowIndex != -1)
            num5 = (int) ((double) font.GetHeight(g) + 0.99) + stylesContentIndent.fBottom + stylesContentIndent.fTop;
          if (num5 > num1)
            num1 = num5;
          int num6 = 0;
          if (!imageSize.IsEmpty)
            num6 = imageSize.Height + stylesContentIndent.fTop + stylesContentIndent.fBottom;
          if (num6 > num1)
            num1 = num6;
        }
      }
      return num1;
    }

    internal void AutoHeightHeader(bool adjustScrollBarsIfRedraw)
    {
      for (int rowIndex = this.fHeaderRowCount - 1; rowIndex >= 0; --rowIndex)
        this.AutoHeightHeaderRow(rowIndex, adjustScrollBarsIfRedraw);
    }

    internal void AutoHeightHeaderRow(int rowIndex, bool adjustScrollBarsIfRedraw)
    {
      this.CheckHeaderRowIndex(rowIndex);
      using (Graphics graphics = this.CreateGraphics())
      {
        int num1 = 0;
        IiGControlPaint controlPaint = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.Header) != iGControlPaintFunctions.Header ? (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint : this.fCustomControlPaint;
        iGIndent iGindent = !this.fHeaderDrawSystem ? new iGIndent(0) : controlPaint.GetHeaderIndent(false);
        int notGroupedColCount = this.GetSortedNotGroupedColCount();
        int headerHgridLinesWidth = this.GetHeaderHGridLinesWidth(rowIndex);
        int visibleFrozenColOrder = this.GetLastVisibleFrozenColOrder();
        bool drawFrColsSeparatingLine = this.IsGridLineVisible(this.fFrozenColsSeparatingLineStyle, iGOrientation.Vertical, false);
        this.IsGridLineVisible(this.fVLastColGridLineStyle, iGOrientation.Vertical, false);
        for (int colOrder1 = 0; colOrder1 < this.fColCount; ++colOrder1)
        {
          int index = this.fColIdxFromOrd[colOrder1];
          int fHeaderSpan = this.fHeaderSpanMap[rowIndex * this.fColCount + index];
          iGColData fColData1 = this.fColDatas[index];
          if ((rowIndex >= this.fHeaderRowCount - 1 || this.fHeaderSpanMap[(rowIndex + 1) * this.fColCount + index] != fHeaderSpan) && (rowIndex <= 0 || this.fHeaderSpanMap[(rowIndex - 1) * this.fColCount + index] != fHeaderSpan))
          {
            iGColHdrData fColHdr = this.fColHdrs[fHeaderSpan];
            int colOrder2 = colOrder1;
            int num2 = 0;
            int num3 = 0;
            int colIndex;
            while (true)
            {
              colIndex = this.fColIdxFromOrd[colOrder1];
              iGColData fColData2 = this.fColDatas[colIndex];
              if (this.IsColVisible(fColData2.Visible, fColData2.ShowWhenGrouped, colIndex, true))
              {
                num2 += fColData2.Width;
                ++num3;
                if (this.IsFirstVisibleCol(colOrder1))
                  num2 += this.GetGroupLevelsExtraWidth();
              }
              if (colOrder1 < this.fColCount - 1 && this.fHeaderSpanMap[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder1 + 1]] == fHeaderSpan)
                ++colOrder1;
              else
                break;
            }
            int num4 = num2 - this.GetHeaderVGridLinesWidth(colOrder1, drawFrColsSeparatingLine, visibleFrozenColOrder) - (iGindent.fLeft + iGindent.fRight);
            int sortIndexForDrawing = this.GetColHdrSortIndexForDrawing(rowIndex, colIndex, false, notGroupedColCount);
            Font uniCellFont = this.GetUniCellFont(iGGridSection.Header, rowIndex, colIndex, (iGStyleBase) fColHdr.Style, (iGStyleBase) null, (iGStyleBase) fColData1.ColHdrStyle, iGControlState.Normal, false, false, false, false);
            int cellContentWidth = num4 - this.GetSortAreaWidth(graphics, sortIndexForDrawing, controlPaint, uniCellFont, fColHdr.Style, fColData1.ColHdrStyle, false, false);
            if (num3 != 0)
            {
              int num5 = this.GetUniCellContentsHeight(iGGridSection.Header, graphics, rowIndex, colOrder2, uniCellFont, cellContentWidth, fColHdr.Value, (object) null, fColHdr.ImageIndex, (iGStyleBase) fColHdr.Style, (iGStyleBase) null, (iGStyleBase) fColData1.ColHdrStyle) + headerHgridLinesWidth;
              if (num5 > num1)
                num1 = num5;
            }
          }
        }
        if (num1 <= 0)
          num1 = this.GetHeaderFont().Height + iGStyleBase.cSuperIndent.fTop + iGStyleBase.cSuperIndent.fBottom + headerHgridLinesWidth;
        int num6 = num1 + (iGindent.fTop + iGindent.fBottom);
        if (!this.SetHeaderRowHeight(rowIndex, num6, adjustScrollBarsIfRedraw) || rowIndex != 0)
          return;
        this.NullGroupColsWidths();
      }
    }

    internal void AutoHeightFooter(bool adjustScrollBarsIfRedraw)
    {
      if (this.DesignMode)
        return;
      for (int rowIndex = 0; rowIndex < this.fFooterRowCount; ++rowIndex)
        this.AutoHeightFooterRow(rowIndex, adjustScrollBarsIfRedraw);
    }

    internal void AutoHeightFooterRow(int rowIndex, bool adjustScrollBarsIfRedraw)
    {
      this.CheckFooterRowIndex(rowIndex);
      using (Graphics graphics = this.CreateGraphics())
      {
        int num1 = 0;
        this.GetSortedNotGroupedColCount();
        int footerHgridLinesWidth = this.GetFooterHGridLinesWidth(rowIndex);
        int visibleFrozenColOrder = this.GetLastVisibleFrozenColOrder();
        this.IsGridLineVisible(this.fFrozenColsSeparatingLineStyle, iGOrientation.Vertical, false);
        this.IsGridLineVisible(this.fVLastColGridLineStyle, iGOrientation.Vertical, false);
        int endVisibleColOrder = this.GetRowTextEndVisibleColOrder();
        for (int colOrder1 = 0; colOrder1 < this.fColCount; ++colOrder1)
        {
          int index = this.fColIdxFromOrd[colOrder1];
          int fFooterSpan = this.fFooterSpanMap[rowIndex * this.fColCount + index];
          iGColData fColData1 = this.fColDatas[index];
          if ((rowIndex >= this.fFooterRowCount - 1 || this.fFooterSpanMap[(rowIndex + 1) * this.fColCount + index] != fFooterSpan) && (rowIndex <= 0 || this.fFooterSpanMap[(rowIndex - 1) * this.fColCount + index] != fFooterSpan))
          {
            iGFooterCellData fFooterCell = this.fFooterCells[fFooterSpan];
            int colOrder2 = colOrder1;
            int num2 = 0;
            int num3 = 0;
            int colIndex;
            while (true)
            {
              colIndex = this.fColIdxFromOrd[colOrder1];
              iGColData fColData2 = this.fColDatas[colIndex];
              if (this.IsColVisible(fColData2.Visible, fColData2.ShowWhenGrouped, colIndex, true))
              {
                num2 += fColData2.Width;
                ++num3;
                if (this.IsFirstVisibleCol(colOrder1))
                  num2 += this.GetGroupLevelsExtraWidth();
              }
              if (colOrder1 < this.fColCount - 1 && this.fFooterSpanMap[rowIndex * this.fColCount + this.fColIdxFromOrd[colOrder1 + 1]] == fFooterSpan)
                ++colOrder1;
              else
                break;
            }
            int cellContentWidth = num2 - this.GetVGridLineWidth(colOrder1, visibleFrozenColOrder, iGColDisposition.Normal, false, endVisibleColOrder);
            Font uniCellFont = this.GetUniCellFont(iGGridSection.Footer, rowIndex, colIndex, (iGStyleBase) fFooterCell.Style, (iGStyleBase) null, (iGStyleBase) fColData1.CellStyle, iGControlState.Normal, false, false, false, false);
            if (num3 > 0)
            {
              int num4 = this.GetUniCellContentsHeight(iGGridSection.Footer, graphics, rowIndex, colOrder2, uniCellFont, cellContentWidth, fFooterCell.Value, (object) null, fFooterCell.ImageIndex, (iGStyleBase) fFooterCell.Style, (iGStyleBase) null, (iGStyleBase) fColData1.CellStyle) + footerHgridLinesWidth;
              if (num4 > num1)
                num1 = num4;
            }
          }
        }
        if (num1 <= 0)
          num1 = this.GetFooterFont().Height + iGStyleBase.cSuperIndent.fTop + iGStyleBase.cSuperIndent.fBottom + footerHgridLinesWidth;
        this.SetFooterRowHeight(rowIndex, num1, adjustScrollBarsIfRedraw);
      }
    }

    internal void AutoHeightRows()
    {
      this.BeginUpdate();
      try
      {
        for (int rowIndex = this.fRowCount - 1; rowIndex >= 0; --rowIndex)
          this.AutoHeightRow(rowIndex);
      }
      finally
      {
        this.EndUpdate();
      }
    }

    internal int AutoHeightRow(int rowIndex)
    {
      this.CheckRowIndex(rowIndex);
      int minHeight;
      int maxHeight;
      if (!this.DoRequestRowResize(rowIndex, out minHeight, out maxHeight))
        return this.GetRowDataInternal(rowIndex).Height;
      int num1 = 0;
      using (Graphics graphics = this.CreateGraphics())
      {
        if ((this.fAutoHeightRowMode & iGAutoHeightRowMode.Cells) == iGAutoHeightRowMode.Cells)
        {
          int num2 = 0;
          bool isRowTextDrawn = this.IsRowTextDisplayed();
          int num3 = 0;
          int visibleFrozenRowIndex = this.GetLastVisibleFrozenRowIndex();
          int visibleFrozenColOrder = this.GetLastVisibleFrozenColOrder();
          iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
          int groupObjectColCount = this.GetGroupObjectColCount();
          int treeButtonAreaWidth = this.GetTreeButtonAreaWidth();
          int endVisibleColOrder = this.GetRowTextEndVisibleColOrder();
          if (this.IsGroupRow(rowDataInternal))
          {
            int index = 0;
            iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, index);
            iGColData fColData = this.fColDatas[index];
            int colOrder = 0;
            int cellContentWidth = this.GetCellBounds(rowIndex, index, false).Width - this.GetVGridLineWidth(colOrder, this.GetColDisposition(colOrder), true);
            num1 = this.GetCellContentsHeight(graphics, rowIndex, colOrder, cellContentWidth, cellDataInternal.Value, cellDataInternal.AuxValue, cellDataInternal.ImageIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) fColData.CellStyle);
            Size treeButtonFullSize = this.GetTreeButtonFullSize();
            if (num1 < treeButtonFullSize.Height + 6)
              num1 = treeButtonFullSize.Height + 6;
            num1 += this.GetHGridLineWidth(rowIndex, visibleFrozenRowIndex, true, false);
          }
          else
          {
            bool isFirstVisibleCol = true;
            for (int colDrawOrder = 0; colDrawOrder < this.fColCount; ++colDrawOrder)
            {
              int colOrder = this.DrawColOrderToColOrder(colDrawOrder);
              int colIndex = this.fColIdxFromOrd[colOrder];
              iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
              if (cellDataInternal.SpanCols >= 1 && cellDataInternal.SpanRows >= 1)
              {
                iGColData fColData = this.fColDatas[colIndex];
                iGColDisposition colDisposition = this.GetColDisposition(colOrder, isRowTextDrawn);
                bool flag = this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex);
                if (colDisposition != iGColDisposition.Auxiliary && (colDisposition == iGColDisposition.RowText || flag))
                {
                  int num4;
                  if (colDisposition == iGColDisposition.RowText)
                  {
                    num4 = num3;
                  }
                  else
                  {
                    num4 = this.GetCellWidthFromColWidth(isFirstVisibleCol, colIndex, fColData.Width, rowIndex, rowDataInternal.Level, groupObjectColCount);
                    if (cellDataInternal.SpanCols > 1)
                    {
                      num4 += this.MergedCellExpandWidthDelta(colOrder, cellDataInternal.SpanCols);
                      colDrawOrder += cellDataInternal.SpanCols - 1;
                    }
                    if (colDisposition == iGColDisposition.AboveRowText)
                      num3 += num4;
                    if ((!this.IsTreeColSpecified() ? isFirstVisibleCol : this.IsTreeCol(colIndex)) && (rowDataInternal.TreeButton & iGTreeButtonState.Hidden) > iGTreeButtonState.Absent)
                      num4 -= treeButtonAreaWidth;
                  }
                  isFirstVisibleCol = false;
                  int cellContentWidth = num4 - this.GetVGridLineWidth(colOrder, visibleFrozenColOrder, colDisposition, false, endVisibleColOrder);
                  int num5 = this.GetCellContentsHeight(graphics, rowIndex, colOrder, cellContentWidth, cellDataInternal.Value, cellDataInternal.AuxValue, cellDataInternal.ImageIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) fColData.CellStyle) + this.GetHGridLineWidth(rowIndex, visibleFrozenRowIndex, false, colDisposition == iGColDisposition.AboveRowText);
                  if (colDisposition == iGColDisposition.RowText)
                  {
                    int num6 = num2 + num5;
                    if (num6 > num1)
                      num1 = num6;
                    rowDataInternal.NormalCellHeight = num1 - num5;
                    this.SetRowDataNoVisibleHeightTypeSortableChange(rowIndex, rowDataInternal);
                    break;
                  }
                  if (colDisposition == iGColDisposition.AboveRowText)
                  {
                    if (num5 > num2)
                      num2 = num5;
                  }
                  else if (num5 > num1)
                    num1 = num5;
                }
              }
            }
          }
        }
        if ((this.fAutoHeightRowMode & iGAutoHeightRowMode.RowHdr) == iGAutoHeightRowMode.RowHdr)
        {
          int preferredHeight = this.fRowHeader.GetPreferredHeight(graphics, rowIndex, this.RightToLeft == RightToLeft.Yes);
          if (preferredHeight > num1)
            num1 = preferredHeight;
        }
      }
      if (maxHeight >= 0 && num1 > maxHeight)
        num1 = maxHeight;
      if (minHeight >= 0 && num1 < minHeight)
        num1 = minHeight;
      this.SetRowHeight(rowIndex, num1);
      return num1;
    }

    internal void AutoWidthCol(int colIndex, bool checkRowParms, int rowIndex, int rowCount, bool allowDecrease)
    {
      this.CheckColIndex(colIndex);
      if (checkRowParms)
        this.CheckRowIndexAndCount(rowIndex, rowCount, nameof (rowCount));
      bool flag1 = this.RightToLeft == RightToLeft.Yes;
      int groupObjectColCount = this.GetGroupObjectColCount();
      int rowTextEndColOrder = this.GetRowTextEndColOrder();
      int visibleFrozenColOrder = this.GetLastVisibleFrozenColOrder();
      iGColData fColData = this.fColDatas[colIndex];
      int colOrder = this.GetColOrder(colIndex);
      iGColDisposition colDisposition = this.GetColDisposition(colOrder);
      if (colDisposition == iGColDisposition.Auxiliary && this.fAutoResizeCols)
        return;
      int colLeft1;
      bool isFirstVisibleCol;
      if (colDisposition == iGColDisposition.Auxiliary)
      {
        colLeft1 = 0;
        isFirstVisibleCol = true;
      }
      else
        colLeft1 = this.ColToX(colOrder, false, out isFirstVisibleCol);
      int num1 = 0;
      int num2 = 0;
      using (Graphics graphics = this.CreateGraphics())
      {
        if ((this.fAutoWidthColMode & iGAutoWidthColMode.Cells) != (iGAutoWidthColMode) 0)
        {
          int visibleFrozenRowIndex = this.GetLastVisibleFrozenRowIndex();
          int treeButtonAreaWidth = this.GetTreeButtonAreaWidth();
          iGCellStyle cellStyle = this.GetColDataInternal(colIndex).CellStyle;
          for (int rowIndex1 = rowIndex + rowCount - 1; rowIndex1 >= rowIndex; --rowIndex1)
          {
            iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex1, colIndex);
            iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
            if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
            {
              bool isGroupRow = this.IsGroupRow(rowDataInternal);
              if (isGroupRow)
              {
                if (colDisposition != iGColDisposition.Auxiliary && colDisposition != iGColDisposition.RowText)
                  continue;
              }
              else if (colDisposition == iGColDisposition.Auxiliary)
                continue;
              if (cellDataInternal.SpanCols >= 1 && cellDataInternal.SpanRows >= 1)
              {
                int num3 = colDisposition != iGColDisposition.RowText ? (colDisposition != iGColDisposition.AboveRowText ? rowDataInternal.Height : rowDataInternal.NormalCellHeight) : rowDataInternal.Height - rowDataInternal.NormalCellHeight;
                if (cellDataInternal.SpanRows > 1)
                  num3 += this.MergedCellExpandHeightDelta(rowIndex1, cellDataInternal.SpanRows);
                int cellContentHeight = num3 - this.GetHGridLineWidth(rowIndex1, visibleFrozenRowIndex, isGroupRow, colDisposition == iGColDisposition.AboveRowText);
                Font uniCellFont = this.GetUniCellFont(iGGridSection.Cells, rowIndex1, colIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle, iGControlState.Normal, false, false, false, false);
                int cellContentsWidth = this.GetUniCellContentsWidth(iGGridSection.Cells, graphics, uniCellFont, cellContentHeight, int.MinValue, cellDataInternal.Value, cellDataInternal.AuxValue, cellDataInternal.ImageIndex, rowIndex1, colIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle, true);
                if ((!this.IsTreeColSpecified() ? isFirstVisibleCol : this.IsTreeCol(colIndex)) | isGroupRow && (rowDataInternal.TreeButton & iGTreeButtonState.Hidden) > iGTreeButtonState.Absent)
                  cellContentsWidth += treeButtonAreaWidth;
                int num4 = cellContentsWidth - this.GetCellWidthFromColWidth(isFirstVisibleCol | isGroupRow, colIndex, 0, rowIndex1, rowDataInternal.Level, groupObjectColCount);
                if (isGroupRow)
                {
                  if (num4 > num2)
                    num2 = num4;
                }
                else if (num4 > num1)
                  num1 = num4;
              }
            }
          }
          if (this.fFooterVisible)
          {
            for (int rowIndex1 = 0; rowIndex1 < this.fFooterRowCount; ++rowIndex1)
            {
              iGFooterCellData cellDataInternal = this.GetFooterCellDataInternal(rowIndex1, colIndex);
              iGFooterRowData fFooterRow = this.fFooterRows[rowIndex1];
              if (fFooterRow.Visible)
              {
                int num3 = rowIndex1 * this.fColCount;
                int fFooterSpan = this.fFooterSpanMap[num3 + colIndex];
                if ((colOrder == 0 || fFooterSpan != this.fFooterSpanMap[num3 + this.fColIdxFromOrd[colOrder - 1]]) && (colOrder == this.fColCount - 1 || fFooterSpan != this.fFooterSpanMap[num3 + this.fColIdxFromOrd[colOrder + 1]]))
                {
                  int height = fFooterRow.Height;
                  int cellContentHeight = rowIndex1 != 0 ? height - this.fHGridLinesStyle.Width : height - this.fFooterSeparatingLine.Width;
                  Font uniCellFont = this.GetUniCellFont(iGGridSection.Footer, rowIndex1, colIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle, iGControlState.Normal, false, false, false, false);
                  int cellContentsWidth = this.GetUniCellContentsWidth(iGGridSection.Footer, graphics, uniCellFont, cellContentHeight, int.MinValue, cellDataInternal.Value, cellDataInternal.AuxValue, cellDataInternal.ImageIndex, rowIndex1, colIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle, true);
                  if (cellContentsWidth > num1)
                    num1 = cellContentsWidth;
                }
              }
            }
          }
          int endVisibleColOrder = this.GetRowTextEndVisibleColOrder();
          num2 += this.GetVGridLineWidth(colOrder, visibleFrozenColOrder, colDisposition, true, endVisibleColOrder);
          num1 += this.GetVGridLineWidth(colOrder, visibleFrozenColOrder, colDisposition, false, endVisibleColOrder);
        }
        if ((this.fAutoWidthColMode & iGAutoWidthColMode.Header) != (iGAutoWidthColMode) 0)
        {
          if (colDisposition != iGColDisposition.Normal)
          {
            if (colDisposition != iGColDisposition.AboveRowText)
              goto label_59;
          }
          if (this.fHeaderVisible)
          {
            int num3 = 0;
            int num4 = -1;
            IiGControlPaint controlPaint = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.Header) != iGControlPaintFunctions.Header ? (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint : this.fCustomControlPaint;
            iGIndent headerIndent = controlPaint.GetHeaderIndent(false);
            int notGroupedColCount = this.GetSortedNotGroupedColCount();
            for (int rowIndex1 = 0; rowIndex1 < this.fHeaderRowCount; ++rowIndex1)
            {
              if (this.fHeaderRows[rowIndex1].Visible)
              {
                int num5 = rowIndex1 * this.fColCount;
                int fHeaderSpan = this.fHeaderSpanMap[num5 + colIndex];
                if (fHeaderSpan != num4)
                {
                  num4 = fHeaderSpan;
                  if ((colOrder == 0 || fHeaderSpan != this.fHeaderSpanMap[num5 + this.fColIdxFromOrd[colOrder - 1]]) && (colOrder == this.fColCount - 1 || fHeaderSpan != this.fHeaderSpanMap[num5 + this.fColIdxFromOrd[colOrder + 1]]))
                  {
                    iGColHdrData fColHdr = this.fColHdrs[fHeaderSpan];
                    int cellContentHeight = this.fHeaderRows[rowIndex1].Height - this.GetHeaderHGridLinesWidth(rowIndex1);
                    if (this.fHeaderDrawSystem)
                      cellContentHeight -= headerIndent.fTop + headerIndent.fBottom;
                    Font uniCellFont = this.GetUniCellFont(iGGridSection.Header, rowIndex1, colIndex, (iGStyleBase) fColHdr.Style, (iGStyleBase) null, (iGStyleBase) this.fColDatas[colIndex].ColHdrStyle, iGControlState.Normal, false, false, false, false);
                    int cellContentsWidth = this.GetUniCellContentsWidth(iGGridSection.Header, graphics, uniCellFont, cellContentHeight, int.MinValue, fColHdr.Value, (object) null, fColHdr.ImageIndex, rowIndex1, colIndex, (iGStyleBase) fColHdr.Style, (iGStyleBase) null, (iGStyleBase) this.fColDatas[colIndex].ColHdrStyle, true);
                    if (isFirstVisibleCol)
                      cellContentsWidth -= this.fLevelIndent * groupObjectColCount;
                    int sortIndexForDrawing = this.GetColHdrSortIndexForDrawing(rowIndex1, colIndex, false, notGroupedColCount);
                    int num6 = cellContentsWidth + this.GetSortAreaWidth(graphics, sortIndexForDrawing, controlPaint, uniCellFont, fColHdr.Style, this.fColDatas[colIndex].ColHdrStyle, false, false);
                    if (num6 > num3)
                      num3 = num6;
                  }
                }
                else
                  break;
              }
            }
            if (num3 > 0)
            {
              int num5 = num3 + this.GetHeaderVGridLinesWidth(colOrder, this.IsGridLineVisible(this.fFrozenColsSeparatingLineStyle, iGOrientation.Vertical, false), visibleFrozenColOrder);
              if (this.fHeaderDrawSystem)
                num5 += headerIndent.fLeft + headerIndent.fRight;
              if (num5 > num1)
                num1 = num5;
            }
          }
        }
      }
label_59:
      int num7 = -1;
      int colCount = 0;
      for (int colOrderOrIndex = 0; colOrderOrIndex < this.fColCount; ++colOrderOrIndex)
      {
        if (this.IsExtraCol(colOrderOrIndex))
        {
          if (num7 != -1)
            break;
        }
        else
        {
          if (num7 == -1)
            num7 = colOrderOrIndex;
          ++colCount;
        }
      }
      if (colDisposition != iGColDisposition.Auxiliary)
      {
        int num3 = colDisposition != iGColDisposition.RowText ? fColData.Width : this.GetSumOfColWidthsAboveRowText();
        int max;
        int min;
        this.GetColsMinMaxWidth(colOrder, 1, colLeft1, colLeft1 + num3, false, out max, out min);
        if (num1 > max)
          num1 = max;
        else if (num1 < min)
          num1 = min;
      }
      if (colDisposition == iGColDisposition.Auxiliary || colDisposition == iGColDisposition.RowText)
      {
        int num3 = this.fVisibleColsWidthPlusGroupObjectLevelArea - this.GetGroupLevelsExtraWidth();
        int colLeft2 = this.GetCellsAreaLeft_NoRightToLeft();
        if (flag1)
          colLeft2 = this.Width - colLeft2 - num3;
        if (num7 != -1)
        {
          int max;
          int min;
          this.GetColsMinMaxWidth(num7, colCount, colLeft2, colLeft2 + num3, false, out max, out min);
          if (num2 > max)
            num2 = max;
          else if (num2 < min)
            num2 = min;
        }
      }
      bool flag2 = false;
      if (colDisposition == iGColDisposition.RowText || colDisposition == iGColDisposition.Auxiliary)
      {
        int visibleAllowResizeCount;
        int[] oldWidths;
        if (colDisposition == iGColDisposition.RowText)
        {
          int forSetColsWidths = this.GetDataForSetColsWidths(this.fRowTextStartColNear, rowTextEndColOrder - this.fRowTextStartColNear + 1, out visibleAllowResizeCount, out oldWidths);
          if ((allowDecrease || num1 >= forSetColsWidths) && (visibleAllowResizeCount >= 1 && this.SetColsWidths(this.fRowTextStartColNear, oldWidths, visibleAllowResizeCount, num1 - forSetColsWidths) != 0))
          {
            flag2 = true;
            if (this.fAutoResizeCols)
              this.DoAutoResizeCols(num7, rowTextEndColOrder - num7 + 1, false, false, false);
          }
        }
        if (!this.fAutoResizeCols)
        {
          int visibleAllowDecreaseCount;
          int forSetColsWidths = this.GetDataForSetColsWidths(num7, colCount, this.fRowTextStartColNear, rowTextEndColOrder - this.fRowTextStartColNear + 1, out visibleAllowResizeCount, out visibleAllowDecreaseCount, out oldWidths);
          if ((allowDecrease || num2 >= forSetColsWidths) && (visibleAllowResizeCount >= 1 && this.SetColsWidths(num7, oldWidths, this.fRowTextStartColNear, rowTextEndColOrder - this.fRowTextStartColNear + 1, visibleAllowResizeCount, visibleAllowDecreaseCount, num2 - forSetColsWidths) != 0))
            flag2 = true;
        }
      }
      else
      {
        int width = fColData.Width;
        if (!allowDecrease && num1 < width)
          return;
        if (this.SetColWidthInternal(colIndex, num1))
        {
          flag2 = true;
          if (this.fAutoResizeCols)
            this.DoAutoResizeCols(0, colOrder + 1, false, false, false);
        }
      }
      if (!flag2)
        return;
      this.NullOldColWidths();
      this.AutoHeightHeaderOnEvent(iGAutoHeightEvents.OnResizeCol, false);
      this.AutoHeightFooterOnEvent(iGAutoHeightEvents.OnResizeCol, false);
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal void AutoWidthCols(bool checkRowParms, int rowIndex, int rowCount)
    {
      this.BeginUpdate();
      try
      {
        for (int colDrawOrder = 0; colDrawOrder < this.fColCount; ++colDrawOrder)
        {
          int colOrder = this.DrawColOrderToColOrder(colDrawOrder);
          int colIndex = this.fColIdxFromOrd[colOrder];
          iGColData fColData = this.fColDatas[colIndex];
          iGColDisposition colDisposition = this.GetColDisposition(colOrder);
          if (colDisposition != iGColDisposition.Auxiliary && fColData.AllowSizing)
          {
            if (colDisposition == iGColDisposition.RowText)
              this.AutoWidthCol(colIndex, checkRowParms, rowIndex, rowCount, false);
            else
              this.AutoWidthCol(colIndex, checkRowParms, rowIndex, rowCount, true);
          }
        }
      }
      finally
      {
        this.EndUpdate();
      }
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawCellGetWidth" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawCellGetWidthEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawCellGetWidth(iGCustomDrawCellGetWidthEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawCellGetWidth == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawCellGetWidth((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawCellGetHeight" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawCellGetHeightEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawCellGetHeight(iGCustomDrawCellGetHeightEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawCellGetHeight == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawCellGetHeight((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawColHdrGetWidth" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawColHdrGetWidthEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawColHdrGetWidth(iGCustomDrawColHdrGetWidthEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawColHdrGetWidth == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawColHdrGetWidth((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomDrawColHdrGetHeight" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomDrawColHdrGetHeightEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomDrawColHdrGetHeight(iGCustomDrawColHdrGetHeightEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomDrawColHdrGetHeight == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomDrawColHdrGetHeight((object) this, e);
    }

    private bool ShouldSerializeFrozenArea()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.FrozenArea);
    }

    private bool ShouldSerializeBorderColor()
    {
      return this.fBorderColor != iGrid.cDefaultBorderColor;
    }

    private bool ShouldSerializeForeColorDisabled()
    {
      return this.fForeColorDisabled != iGrid.cDefaultForeColorDisabled;
    }

    private bool ShouldSerializeBackColorEvenRows()
    {
      return this.fBackColorEvenRows != iGrid.cDefaultBackColorEvenRows;
    }

    private bool ShouldSerializeBackColorOddRows()
    {
      return this.fBackColorOddRows != iGrid.cDefaultBackColorOddRows;
    }

    private bool ShouldSerializeCols()
    {
      if (this.fColCollection != null)
        return this.fColCollection.Count > 0;
      return false;
    }

    private bool ShouldSerializeBackColor()
    {
      return this.BackColor != iGrid.cDefaultBackColor;
    }

    private bool ShouldSerializeForeColor()
    {
      return this.ForeColor != iGrid.cDefaultForeColor;
    }

    private bool ShouldSerializeRows()
    {
      if (this.fRowCollection != null)
        return this.fRowCollection.Count > 0;
      return false;
    }

    private bool ShouldSerializeDefaultRow()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.fDefaultRow);
    }

    private bool ShouldSerializeDefaultCol()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.DefaultCol);
    }

    private bool ShouldSerializeHScrollBar()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.HScrollBar);
    }

    private bool ShouldSerializeVScrollBar()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.VScrollBar);
    }

    private bool ShouldSerializeScrollBarSettings()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.ScrollBarSettings);
    }

    private bool ShouldSerializeCellCtrlBackColor()
    {
      return this.CellCtrlBackColor != iGControlPaintStyle.cDefaultBackColor;
    }

    private bool ShouldSerializeCellCtrlForeColor()
    {
      return this.CellCtrlForeColor != iGControlPaintStyle.cDefaultForeColor;
    }

    private bool ShouldSerializeRowTextStartColNear()
    {
      return this.RowTextStartColNear != this.FrozenColCount;
    }

    private bool ShouldSerializeRowTextCol()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.fRowTextColObject);
    }

    private bool ShouldSerializeGroupBox()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.GroupBox);
    }

    private bool ShouldSerializeDefaultAutoGroupRow()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.DefaultAutoGroupRow);
    }

    internal bool ShouldSerializeGroupRowLevelStyles()
    {
      return this.GroupRowLevelStyles.Length != 1 || !this.GroupRowLevelStyles[0].EqualsTo(iGInternalInfrastructure.GetDefaultGroupRowStyle());
    }

    private bool ShouldSerializeGridLines()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.GridLines);
    }

    private bool ShouldSerializeUIStrings()
    {
      return iGInternalInfrastructure.iGSerializeManager.ShouldSerialize((object) this.UIStrings);
    }

    private bool ShouldSerializeTreeCol()
    {
      return this.fTreeColIndex != -1;
    }

    internal DesignerTransaction BeforeChangePropWithStyle(string propName, string rootPropName)
    {
      DesignerTransaction designerTransaction = (DesignerTransaction) null;
      IDesignerHost service1 = (IDesignerHost) this.GetService(typeof (IDesignerHost));
      try
      {
        if (service1 != null)
          designerTransaction = service1.CreateTransaction("Change " + this.Name + "." + propName);
      }
      catch (CheckoutException ex)
      {
        if (ex == CheckoutException.Canceled)
          return (DesignerTransaction) null;
        throw ex;
      }
      IComponentChangeService service2 = (IComponentChangeService) this.GetService(typeof (IComponentChangeService));
      PropertyDescriptor property = TypeDescriptor.GetProperties((object) this)[rootPropName];
      if (service2 != null)
      {
        try
        {
          service2.OnComponentChanging((object) this, (MemberDescriptor) property);
        }
        catch (CheckoutException ex)
        {
          if (ex == CheckoutException.Canceled)
            return (DesignerTransaction) null;
          throw ex;
        }
      }
      return designerTransaction;
    }

    internal void AfterChangePropWithStyle(string rootPropName, DesignerTransaction transaction)
    {
      IReferenceService service1 = (IReferenceService) this.GetService(typeof (IReferenceService));
      iGInternalInfrastructure.ClearNonUsedDesignCellStyles(service1);
      iGInternalInfrastructure.ClearNonUsedDesignColHdrStyles(service1);
      IComponentChangeService service2 = (IComponentChangeService) this.GetService(typeof (IComponentChangeService));
      PropertyDescriptor property = TypeDescriptor.GetProperties((object) this)[rootPropName];
      if (service2 != null)
        service2.OnComponentChanged((object) this, (MemberDescriptor) property, (object) null, (object) null);
      if (transaction == null)
        return;
      transaction.Commit();
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.ResetBackColor" />.</summary>
    public override void ResetBackColor()
    {
      this.BackColor = iGrid.cDefaultBackColor;
    }

    /// <summary>This member overrides <see cref="M:System.Windows.Forms.Control.ResetForeColor" />.</summary>
    public override void ResetForeColor()
    {
      this.ForeColor = iGrid.cDefaultForeColor;
    }

    private void ResetCurCellBackColor()
    {
      this.CurCellBackColor = iGrid.cDefaultCurCellBackColor;
    }

    private void ResetCurCellBackColorNoFocus()
    {
      this.CurCellBackColorNoFocus = iGrid.cDefaultCurCellBackColorNoFocus;
    }

    private void ResetBackColorEvenRows()
    {
      this.BackColorEvenRows = iGrid.cDefaultBackColorEvenRows;
    }

    private void ResetBackColorOddRows()
    {
      this.BackColorOddRows = iGrid.cDefaultBackColorOddRows;
    }

    private void ResetBorderColor()
    {
      this.BorderColor = iGrid.cDefaultBorderColor;
    }

    private void ResetCellCtrlBackColor()
    {
      this.CellCtrlBackColor = iGControlPaintStyle.cDefaultBackColor;
    }

    private void ResetCellCtrlForeColor()
    {
      this.CellCtrlForeColor = iGControlPaintStyle.cDefaultForeColor;
    }

    private void ResetForeColorDisabled()
    {
      this.fForeColorDisabled = iGrid.cDefaultForeColorDisabled;
    }

    private void ResetCols()
    {
      DesignerTransaction transaction = this.BeforeChangePropWithStyle("Cols", "Cols");
      try
      {
        this.Cols.Clear();
      }
      finally
      {
        this.AfterChangePropWithStyle("Cols", transaction);
      }
    }

    private void ResetDefaultCol()
    {
      DesignerTransaction transaction = this.BeforeChangePropWithStyle("DefaultCol", "DefaultCol");
      try
      {
        if (this.DesignMode)
          this.fDefaultCol = (iGColPattern) new iGDesignTimeDefaultColPattern(this);
        else
          this.fDefaultCol = new iGColPattern(this);
      }
      finally
      {
        this.AfterChangePropWithStyle("DefaultCol", transaction);
      }
    }

    private void ResetDefaultRow()
    {
      DesignerTransaction transaction = this.BeforeChangePropWithStyle("DefaultRow", "DefaultRow");
      try
      {
        if (this.DesignMode)
          this.fDefaultRow = (iGRowPattern) new iGDesignTimeDefaultRowPattern(this);
        else
          this.fDefaultRow = new iGRowPattern();
      }
      finally
      {
        this.AfterChangePropWithStyle("DefaultRow", transaction);
      }
    }

    private void ResetRows()
    {
      DesignerTransaction transaction = this.BeforeChangePropWithStyle("Rows", "Rows");
      try
      {
        this.Rows.Clear();
      }
      finally
      {
        this.AfterChangePropWithStyle("Rows", transaction);
      }
    }

    private void ResetFrozenArea()
    {
      this.FrozenArea.ColCount = 0;
      this.FrozenArea.ColsEdge = iGGridLines.cDefaultFrozenEdgeSeparatingLineStyle.Clone();
      this.FrozenArea.RowCount = 0;
      this.FrozenArea.RowsEdge = iGGridLines.cDefaultFrozenEdgeSeparatingLineStyle.Clone();
      this.FrozenArea.SortFrozenRows = false;
    }

    private void ResetHScrollBar()
    {
      this.HScrollBar.CustomButtons.Clear();
      this.HScrollBar.Enabled = true;
      this.HScrollBar.SmallChange = 10;
      this.HScrollBar.Visibility = iGScrollBarVisibility.OnDemand;
    }

    private void ResetVScrollBar()
    {
      this.VScrollBar.CustomButtons.Clear();
      this.VScrollBar.Enabled = true;
      this.VScrollBar.SmallChange = 16;
      this.VScrollBar.Visibility = iGScrollBarVisibility.OnDemand;
    }

    private void ResetScrollBarSettings()
    {
      this.ScrollBarSettings.Appearance = iGControlPaintAppearance.Style3D;
      this.ScrollBarSettings.BackColor = iGControlPaintStyle.cDefaultBackColor;
      this.ScrollBarSettings.ForeColor = iGControlPaintStyle.cDefaultForeColor;
      this.ScrollBarSettings.ImageList = (ImageList) null;
      this.ScrollBarSettings.Opacity = 1.0;
      this.ScrollBarSettings.UseXPStyles = true;
    }

    private void ResetCurCellForeColor()
    {
      this.CurCellForeColor = iGrid.cDefaultCurCellForeColor;
    }

    private void ResetCurCellForeColorNoFocus()
    {
      this.CurCellForeColorNoFocus = iGrid.cDefaultCurCellForeColorNoFocus;
    }

    private void ResetRowTextCol()
    {
      DesignerTransaction transaction = this.BeforeChangePropWithStyle("RowTextCol", "RowTextCol");
      try
      {
        this.RowTextCol.Pattern = new iGColPattern();
      }
      finally
      {
        this.AfterChangePropWithStyle("RowTextCol", transaction);
      }
    }

    private void ResetGroupBox()
    {
      this.GroupBox.Visible = false;
      this.GroupBox.HintBackColor = iGGroupBox.cDefaultHintBackColor;
      this.GroupBox.HintForeColor = iGGroupBox.cDefaultHintForeColor;
      this.GroupBox.BackColor = iGGroupBox.cDefaultBackColor;
      this.GroupBox.ColHdrBorderColor = iGGroupBox.cDefaultColHdrBorderColor;
    }

    private void ResetDefaultAutoGroupRow()
    {
      this.DefaultAutoGroupRow.Height = 17;
      this.DefaultAutoGroupRow.Expanded = true;
      this.DefaultAutoGroupRow.TreeButton = iGTreeButtonState.Visible;
    }

    private void ResetGroupRowLevelStyles()
    {
      DesignerTransaction transaction = this.BeforeChangePropWithStyle("GroupRowLevelStyles", "GroupRowLevelStyles");
      try
      {
        this.GroupRowLevelStyles = new iGCellStyle[1]
        {
          iGInternalInfrastructure.GetDefaultGroupRowStyle().Clone()
        };
      }
      finally
      {
        this.AfterChangePropWithStyle("GroupRowLevelStyles", transaction);
      }
    }

    private void ResetGridLines()
    {
      iGInternalInfrastructure.iGSerializeManager.Reset((object) this.GridLines);
    }

    private void ResetUIStrings()
    {
      iGInternalInfrastructure.iGSerializeManager.Reset((object) this.UIStrings);
    }

    private void ResetTreeCol()
    {
      this.fTreeColIndex = -1;
      if (!this.fRedraw)
        return;
      this.Invalidate();
    }

    private void GetUniCellDataAndStyles(iGGridSection gridSection, int rowIndex, int colIndex, out object myCellDataValue, out object myCellDataAuxValue, out int myCellDataImageIndex, out iGStyleBase myCellStyle, out iGStyleBase myRowStyle, out iGStyleBase myColStyle)
    {
      switch (gridSection)
      {
        case iGGridSection.Header:
          iGColHdrData colHdrDataInternal = this.GetColHdrDataInternal(rowIndex, colIndex);
          myCellDataValue = colHdrDataInternal.Value;
          myCellDataAuxValue = (object) null;
          myCellDataImageIndex = colHdrDataInternal.ImageIndex;
          myCellStyle = (iGStyleBase) colHdrDataInternal.Style;
          myRowStyle = (iGStyleBase) null;
          myColStyle = (iGStyleBase) this.GetColDataInternal(colIndex).ColHdrStyle;
          break;
        case iGGridSection.Cells:
          iGCellData cellDataInternal1 = this.GetCellDataInternal(rowIndex, colIndex);
          myCellDataValue = cellDataInternal1.Value;
          myCellDataAuxValue = cellDataInternal1.AuxValue;
          myCellDataImageIndex = cellDataInternal1.ImageIndex;
          myCellStyle = (iGStyleBase) cellDataInternal1.Style;
          myRowStyle = (iGStyleBase) this.GetRowDataInternal(rowIndex).CellStyle;
          myColStyle = (iGStyleBase) this.GetColDataInternal(colIndex).CellStyle;
          break;
        case iGGridSection.Footer:
          iGFooterCellData cellDataInternal2 = this.GetFooterCellDataInternal(rowIndex, colIndex);
          myCellDataValue = cellDataInternal2.Value;
          myCellDataAuxValue = cellDataInternal2.AuxValue;
          myCellDataImageIndex = cellDataInternal2.ImageIndex;
          myCellStyle = (iGStyleBase) cellDataInternal2.Style;
          myRowStyle = (iGStyleBase) null;
          myColStyle = (iGStyleBase) this.GetColDataInternal(colIndex).CellStyle;
          break;
        default:
          myCellDataValue = (object) null;
          myCellDataAuxValue = (object) null;
          myCellDataImageIndex = -1;
          myCellStyle = (iGStyleBase) null;
          myRowStyle = (iGStyleBase) null;
          myColStyle = (iGStyleBase) null;
          break;
      }
    }

    internal Rectangle GetUniCellImageAreaBounds(iGGridSection gridSection, int rowIndex, int colIndex)
    {
      object myCellDataValue;
      object myCellDataAuxValue;
      int myCellDataImageIndex;
      iGStyleBase myCellStyle;
      iGStyleBase myRowStyle;
      iGStyleBase myColStyle;
      this.GetUniCellDataAndStyles(gridSection, rowIndex, colIndex, out myCellDataValue, out myCellDataAuxValue, out myCellDataImageIndex, out myCellStyle, out myRowStyle, out myColStyle);
      iGrid.iGCellContents contentsInternal = this.GetUniCellContentsInternal(gridSection, rowIndex, colIndex, myCellDataValue, myCellDataAuxValue, myCellDataImageIndex, myCellStyle, myRowStyle, myColStyle);
      if (!this.IsCellImageReallyDrawn(contentsInternal))
        return Rectangle.Empty;
      Rectangle rect = Rectangle.Empty;
      switch (gridSection)
      {
        case iGGridSection.Header:
          rect = this.GetColHdrImageAndTextAreaBounds(rowIndex, colIndex, false);
          break;
        case iGGridSection.Cells:
          rect = this.GetCellImageAndTextAreaBounds(rowIndex, colIndex, false);
          break;
        case iGGridSection.Footer:
          rect = this.GetFooterCellImageAndTextAreaBounds(rowIndex, colIndex, false);
          break;
      }
      int x = rect.X;
      int y = rect.Y;
      Size imageSize = contentsInternal.ImageList.ImageSize;
      int width = imageSize.Width;
      imageSize = contentsInternal.ImageList.ImageSize;
      int height = imageSize.Height;
      ContentAlignment stylesImageAlign = this.GetPropFromStyles_ImageAlign(myCellStyle, myRowStyle, myColStyle);
      iGAligner.AdjustImageLocation(ref x, ref y, rect.Width, rect.Height, width, height, stylesImageAlign, new iGIndent(0), this.RightToLeft == RightToLeft.Yes);
      Rectangle rectangle = new Rectangle(x, y, width, height);
      rectangle.Intersect(rect);
      return rectangle;
    }

    private bool IsPointOverTreeButton(int x, int y, int rowIndex, int colOrder, iGRowType rowDataType, int rowDataLevel, int cellX, int cellY, int cellWidth, int cellHeight)
    {
      if (rowDataType == iGRowType.Normal && !(!this.IsTreeColSpecified() ? this.GetFirstVisibleColOrder() == colOrder : this.IsTreeCol(this.GetColIndex(colOrder))))
        return false;
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int num1;
      int cellXWithoutGridLines;
      if (this.IsGroupRow(rowDataType) && !this.IsGroupRowContentScrollable())
      {
        Rectangle areaBoundsNoRowHdr = this.GetCellsAreaBoundsNoRowHdr(rightToLeft);
        num1 = Math.Min(this.fVisibleColsWidthPlusGroupObjectLevelArea, areaBoundsNoRowHdr.Width) - rowDataLevel * this.fLevelIndent;
        cellXWithoutGridLines = !rightToLeft ? areaBoundsNoRowHdr.X + rowDataLevel * this.fLevelIndent : areaBoundsNoRowHdr.Right - rowDataLevel * this.fLevelIndent - num1;
      }
      else
      {
        cellXWithoutGridLines = cellX;
        num1 = cellWidth;
      }
      int cellYWithoutGridLines = cellY;
      int num2 = cellHeight;
      iGColDisposition colDisposition = this.GetColDisposition(colOrder);
      bool aboveRowText = colDisposition == iGColDisposition.AboveRowText;
      int vgridLineWidth = this.GetVGridLineWidth(colOrder, colDisposition, (uint) rowDataType > 0U);
      int cellWidthWithoutGridLines = num1 - vgridLineWidth;
      if (rightToLeft)
        cellXWithoutGridLines += vgridLineWidth;
      int hgridLineWidth = this.GetHGridLineWidth(rowIndex, aboveRowText, (uint) rowDataType > 0U);
      int cellHeightWithoutGridLines = num2 - hgridLineWidth;
      return this.GetTreeButtonBounds(cellXWithoutGridLines, cellYWithoutGridLines, cellWidthWithoutGridLines, cellHeightWithoutGridLines, rightToLeft).Contains(x, y);
    }

    private Rectangle GetTreeButtonBounds(int cellXWithoutGridLines, int cellYWithoutGridLines, int cellWidthWithoutGridLines, int cellHeightWithoutGridLines, bool rightToLeft)
    {
      Size treeButtonFullSize = this.GetTreeButtonFullSize();
      int x;
      int width;
      this.GetTreeButtonXCoordinates(treeButtonFullSize.Width, cellXWithoutGridLines, cellWidthWithoutGridLines, rightToLeft, out x, out width);
      int y;
      int height;
      this.GetTreeButtonYCoordinates(treeButtonFullSize.Height, cellYWithoutGridLines, cellHeightWithoutGridLines, out y, out height);
      return new Rectangle(x, y, width, height);
    }

    private void GetTreeButtonXCoordinates(int buttonFullWidth, int cellXWithoutGridLines, int cellWidthWithoutGridLines, bool rightToLeft, out int x, out int width)
    {
      width = Math.Min(cellWidthWithoutGridLines - 3, buttonFullWidth);
      x = cellXWithoutGridLines + 3;
      if (!rightToLeft)
        return;
      x = 2 * cellXWithoutGridLines - x + cellWidthWithoutGridLines - width;
    }

    private void GetTreeButtonYCoordinates(int buttonFullHeight, int cellYWithoutGridLines, int cellHeightWithoutGridLines, out int y, out int height)
    {
      height = Math.Min(cellHeightWithoutGridLines, buttonFullHeight);
      y = cellYWithoutGridLines + (cellHeightWithoutGridLines - height) / 2;
      this.DoAdjustTreeButtonLocation(ref y, height, cellYWithoutGridLines, cellHeightWithoutGridLines);
    }

    internal Rectangle GetCellTextAreaBounds(int rowIndex, int colIndex)
    {
      return this.GetCellImageAndTextAreaBounds(rowIndex, colIndex, true);
    }

    private Rectangle GetCellImageAndTextAreaBounds(int rowIndex, int colIndex, bool excludeImageArea)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int colOrder = this.GetColOrder(colIndex);
      bool isFirstVisible;
      Rectangle cellBounds = this.GetCellBounds(rowIndex, colOrder, false, out isFirstVisible);
      int x = cellBounds.X;
      int y1 = cellBounds.Y;
      int width1 = cellBounds.Width;
      int height1 = cellBounds.Height;
      iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      iGCellStyle cellStyle = this.GetColData(colIndex).CellStyle;
      iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType((iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle);
      iGCellDrawTypeFlags stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags((iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle);
      iGCellDrawFlags fromStylesDrawFlags = this.GetPropFromStyles_DrawFlags((iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle);
      int stylesCustomDrawFlags = (int) this.GetPropFromStyles_CustomDrawFlags((iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle);
      IiGDropDownControl cellDropDownControl = this.GetUniCellDropDownControl(iGGridSection.Cells, rowIndex, colIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle, false);
      this.ExcludeTreeButtonFromCellBounds(rowDataInternal.TreeButton, isFirstVisible, colIndex, rightToLeft, ref x, ref y1, ref width1, ref height1);
      this.ExcludeGridLinesFromCellBounds(rowIndex, colOrder, ref x, ref y1, ref width1, ref height1, rightToLeft);
      if (this.IsGroupRow(rowDataInternal) && !this.IsGroupRowContentScrollable())
      {
        if (rightToLeft)
        {
          int num = this.GetCellsAreaBoundsNoRowHdr().Left - x;
          if (num > 0)
          {
            if (num > width1)
              num = width1;
            x += num;
            width1 -= num;
          }
        }
        else
        {
          int num = x + width1 - this.GetCellsAreaBoundsNoRowHdr().Right;
          if (num > 0)
          {
            if (num > width1)
              width1 = 0;
            else
              width1 -= num;
          }
        }
      }
      this.ExcludeEllipsisButtonFromCellBounds(stylesDrawTypeFlags, rightToLeft, ref x, ref y1, ref width1, ref height1);
      this.ExcludeComboButtonFromCellBounds(fromStylesDrawType, stylesDrawTypeFlags, cellDropDownControl, rightToLeft, ref x, ref y1, ref width1, ref height1);
      iGIndent stylesContentIndent = this.GetPropFromStyles_ContentIndent((iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle);
      iGIndent indent;
      if (excludeImageArea)
      {
        Size imageSize;
        if (fromStylesDrawType != iGCellDrawType.Check)
        {
          bool drawCellImage;
          int cellImageIndex;
          ImageList cellImageList;
          this.GetUniCellImageParamsInternal(iGGridSection.Cells, rowIndex, colIndex, cellDataInternal.Value, cellDataInternal.AuxValue, cellDataInternal.ImageIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle, fromStylesDrawType, stylesDrawTypeFlags, fromStylesDrawFlags, cellDropDownControl, out drawCellImage, out cellImageIndex, out cellImageList);
          imageSize = !drawCellImage || cellImageList == null || (cellImageIndex < 0 || cellImageIndex >= cellImageList.Images.Count) ? Size.Empty : cellImageList.ImageSize;
        }
        else
          imageSize = Size.Empty;
        indent = this.GetCellTextIndent_NoRightToLeft((iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle, imageSize, stylesContentIndent, this.GetPropFromStyles_ImageAlign((iGStyleBase) cellDataInternal.Style, (iGStyleBase) rowDataInternal.CellStyle, (iGStyleBase) cellStyle));
      }
      else
        indent = stylesContentIndent;
      if (rightToLeft)
        indent = iGAligner.RtlTranslateIndent(indent);
      x += indent.fLeft;
      int width2 = width1 - (indent.fLeft + indent.fRight);
      int y2 = y1 + indent.fTop;
      int height2 = height1 - (indent.fTop + indent.fBottom);
      return new Rectangle(x, y2, width2, height2);
    }

    private void ExcludeTreeButtonFromCellBounds(iGTreeButtonState rowDataTreeButton, bool isFirstVisibleCol, int colIndex, bool rightToLeft, ref int x, ref int y, ref int width, ref int height)
    {
      bool flag = !this.IsTreeColSpecified() ? isFirstVisibleCol : this.IsTreeCol(colIndex);
      if (!((rowDataTreeButton & iGTreeButtonState.Hidden) > iGTreeButtonState.Absent & flag))
        return;
      int treeButtonAreaWidth = this.GetTreeButtonAreaWidth();
      if (!rightToLeft)
        x = x + treeButtonAreaWidth;
      width = width - treeButtonAreaWidth;
    }

    private void ExcludeEllipsisButtonFromCellBounds(iGCellDrawTypeFlags cellDrawTypeFlags, bool rightToLeft, ref int x, ref int y, ref int width, ref int height)
    {
      if ((cellDrawTypeFlags & iGCellDrawTypeFlags.HasEllipsisButton) == iGCellDrawTypeFlags.None)
        return;
      int num = this.GetComboSize(width, height).Width + this.cComboIndent;
      if (rightToLeft)
        x = x + num;
      width = width - num;
    }

    private void ExcludeComboButtonFromCellBounds(iGCellDrawType cellDrawType, iGCellDrawTypeFlags cellDrawTypeFlags, IiGDropDownControl cellDropDownControl, bool rightToLeft, ref int x, ref int y, ref int width, ref int height)
    {
      if (!this.ShouldDrawComboButton(cellDrawType, cellDrawTypeFlags, cellDropDownControl))
        return;
      int num = this.GetComboSize(width, height).Width + this.cComboIndent;
      if (rightToLeft)
        x = x + num;
      width = width - num;
    }

    internal void ExcludeGridLinesFromCellBounds(int rowIndex, int colOrder, ref int x, ref int y, ref int width, ref int height, bool rightToLeft)
    {
      iGColDisposition colDisposition = this.GetColDisposition(colOrder);
      bool aboveRowText = colDisposition == iGColDisposition.AboveRowText;
      bool isGroupRow = this.IsGroupRow(rowIndex);
      int vgridLineWidth = this.GetVGridLineWidth(colOrder, colDisposition, isGroupRow);
      int hgridLineWidth = this.GetHGridLineWidth(rowIndex, aboveRowText, isGroupRow);
      if (rightToLeft)
        x = x + vgridLineWidth;
      width = width - vgridLineWidth;
      height = height - hgridLineWidth;
    }

    internal int ColToX(int colOrder, bool firstColIncludesGroupObjectLevelsIndents, out bool isFirstVisibleCol)
    {
      return this.ColToX(colOrder, this.RightToLeft == RightToLeft.Yes, firstColIncludesGroupObjectLevelsIndents, out isFirstVisibleCol);
    }

    private int ColToX(int colOrder, bool rightToLeft, bool firstColIncludesGroupObjectLevelsIndents, out bool isFirstVisible)
    {
      this.CheckColIndex(colOrder);
      int x = this.GetFirstColX(rightToLeft);
      int levelsExtraWidth = this.GetGroupLevelsExtraWidth();
      if (!firstColIncludesGroupObjectLevelsIndents)
      {
        if (rightToLeft)
          x -= levelsExtraWidth;
        else
          x += levelsExtraWidth;
      }
      iGColData fColData1 = this.fColDatas[this.fColIdxFromOrd[colOrder]];
      int index = 0;
      iGColDisposition colDisposition = this.GetColDisposition(colOrder);
      if (colDisposition == iGColDisposition.RowText)
        colOrder = !rightToLeft ? this.fRowTextStartColNear : this.GetRowTextEndColOrder();
      isFirstVisible = true;
      bool flag1 = true;
      bool flag2 = false;
      for (; index < this.fColCount; ++index)
      {
        if (index == this.fFrozenColCount)
          x = this.GetScrolledX(x, rightToLeft);
        int colIndex = this.fColIdxFromOrd[index];
        iGColData fColData2 = this.fColDatas[colIndex];
        if (this.IsColVisible(fColData2.Visible, fColData2.ShowWhenGrouped, colIndex))
        {
          if (rightToLeft)
          {
            x -= fColData2.Width;
            if (firstColIncludesGroupObjectLevelsIndents & isFirstVisible)
              x -= levelsExtraWidth;
            if (index == colOrder)
              break;
          }
          else if (index != colOrder)
          {
            if (firstColIncludesGroupObjectLevelsIndents & isFirstVisible)
              x += levelsExtraWidth;
            x += fColData2.Width;
          }
          else
            break;
          if (!flag2 && colDisposition == iGColDisposition.RowText)
          {
            flag1 = rightToLeft && index >= this.fRowTextStartColNear;
            flag2 = true;
          }
          isFirstVisible = false;
        }
        else if (index == colOrder)
        {
          isFirstVisible = false;
          break;
        }
      }
      if (colDisposition == iGColDisposition.RowText)
        isFirstVisible = flag1;
      return x;
    }

    internal bool GetColFromX(int x, out int colIndex, out int colX, out int colWidth)
    {
      int colOrder;
      int num = this.GetColFromXInternal(x, this.GetGroupObjectColCount(), false, out colOrder, out colX, out colWidth) ? 1 : 0;
      if (num != 0)
      {
        colIndex = this.fColIdxFromOrd[colOrder];
        return num != 0;
      }
      colIndex = colOrder;
      return num != 0;
    }

    private bool GetColFromXInternal(int x, int rowDataLevel, bool includeLevelIndents, out int colOrder, out int colX, out int colWidth)
    {
      bool isLastVisibleCol;
      return this.GetColFromXInternal(x, rowDataLevel, includeLevelIndents, out colOrder, out colX, out colWidth, 0, this.RightToLeft == RightToLeft.Yes, out isLastVisibleCol);
    }

    private bool GetColFromXInternal(int x, int rowDataLevel, bool includeLevelIndents, out int colOrder, out int colX, out int colWidth, int lastOffset, bool rightToLeft, out bool isLastVisibleCol)
    {
      if (rightToLeft)
        x = this.Width - x - 1;
      isLastVisibleCol = false;
      int x1 = this.GetBorderSize() + this.fRowHeader.EffectiveWidth();
      int num = 0;
      for (int index = 0; index < this.fColCount; ++index)
      {
        if (index == this.fFrozenColCount)
          x1 = this.GetScrolledX(x1, false);
        int colIndex = this.fColIdxFromOrd[index];
        iGColData fColData = this.fColDatas[colIndex];
        if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
        {
          bool flag = !this.IsTreeColSpecified() ? num == 0 : this.IsTreeCol(colIndex);
          if (flag && !includeLevelIndents)
            x1 += rowDataLevel * this.fLevelIndent;
          if (x >= x1)
          {
            ++num;
            int width = fColData.Width;
            if (flag)
            {
              int groupObjectColCount = this.GetGroupObjectColCount();
              if (includeLevelIndents)
                width += groupObjectColCount * this.fLevelIndent;
              else
                width -= (rowDataLevel - groupObjectColCount) * this.fLevelIndent;
            }
            x1 += width;
            if (num == this.fVisibleColCount)
              x1 += lastOffset;
            if (x1 > x)
            {
              colX = x1 - width;
              if (num == this.fVisibleColCount)
              {
                isLastVisibleCol = true;
                colX = colX - lastOffset;
              }
              if (rightToLeft)
                colX = this.Width - colX - width;
              colOrder = index;
              colWidth = width;
              return true;
            }
          }
          else
            break;
        }
      }
      colOrder = colX = colWidth = 0;
      return false;
    }

    internal int RowToY(int rowIndex)
    {
      return this.RowToY(rowIndex, this.GetHeaderAreaHeight(), this.GetBorderSize());
    }

    private int RowToY(int rowIndex, int headerSize, int borderSize)
    {
      this.CheckRowIndex(rowIndex);
      int num1 = 0;
      int num2 = borderSize + headerSize;
      int num3;
      int num4;
      if (rowIndex >= this.fViewportFirstRowIndex)
      {
        num2 += this.fFrozenRowsHeight;
        if (this.fViewportFirstRowIndex != this.fFrozenRowCount)
          num2 -= this.fViewportFirstRowHiddenHeight;
        num3 = this.fViewportFirstRowIndex;
        num4 = 1;
      }
      else if (rowIndex < this.fFrozenRowCount || rowIndex <= this.fViewportFirstRowIndex / 2)
      {
        num3 = 0;
        num4 = 1;
      }
      else
      {
        if (this.fViewportFirstRowIndex != this.fFrozenRowCount)
          num2 -= this.fViewportFirstRowHiddenHeight;
        num2 += this.fFrozenRowsHeight;
        num3 = this.fViewportFirstRowIndex;
        num4 = -1;
        num1 = -1;
      }
      while (true)
      {
        if (num3 == this.fFrozenRowCount)
        {
          if (rowIndex < this.fViewportFirstRowIndex)
          {
            if (this.IsScrollableVert())
              num2 -= this.fVScrollBar.Value;
          }
          else
          {
            num2 -= this.fViewportFirstRowHiddenHeight;
            num3 = this.fViewportFirstRowIndex;
          }
        }
        if (num3 != rowIndex)
        {
          iGRowData rowDataInternal = this.GetRowDataInternal(num3 + num1);
          if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
            num2 += num4 * rowDataInternal.Height;
          num3 += num4;
        }
        else
          break;
      }
      return num2;
    }

    internal bool GetRowFromY(int y, out int rowIndex, out int rowY, out int rowHeight)
    {
      int num = this.GetBorderSize() + this.GetHeaderAreaHeight();
      if (y >= num)
      {
        for (int rowIndex1 = 0; rowIndex1 < this.fRowCount; ++rowIndex1)
        {
          if (rowIndex1 == this.fFrozenRowCount)
          {
            num -= this.fViewportFirstRowHiddenHeight;
            rowIndex1 = this.fViewportFirstRowIndex;
          }
          iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
          if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          {
            num += rowDataInternal.Height;
            if (num > y)
            {
              rowY = num - rowDataInternal.Height;
              rowIndex = rowIndex1;
              rowHeight = rowDataInternal.Height;
              return true;
            }
          }
        }
      }
      rowIndex = rowY = rowHeight = 0;
      return false;
    }

    private int GetSumOfColWidthsAboveRowText()
    {
      int firstVisibleAboveRowTextColOrder;
      return this.GetSumOfColWidthsAboveRowText(out firstVisibleAboveRowTextColOrder);
    }

    private int GetSumOfColWidthsAboveRowText(out int firstVisibleAboveRowTextColOrder)
    {
      firstVisibleAboveRowTextColOrder = int.MinValue;
      int num = 0;
      int rowTextEndColOrder = this.GetRowTextEndColOrder();
      for (int textStartColNear = this.fRowTextStartColNear; textStartColNear <= rowTextEndColOrder; ++textStartColNear)
      {
        int colIndex = this.fColIdxFromOrd[textStartColNear];
        iGColData colData = this.GetColData(colIndex);
        if (this.IsColVisible(colData.Visible, colData.ShowWhenGrouped, colIndex))
        {
          num += colData.Width;
          if (firstVisibleAboveRowTextColOrder == int.MinValue)
            firstVisibleAboveRowTextColOrder = textStartColNear;
        }
      }
      return num;
    }

    internal Rectangle GetCellBounds(int rowIndex, int colOrder, bool includeLevel, out bool isFirstVisible)
    {
      int y = this.RowToY(rowIndex);
      iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
      int colIndex1 = this.fColIdxFromOrd[colOrder];
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int firstVisibleAboveRowTextColOrder = int.MinValue;
      int x;
      int width;
      int height;
      if (colIndex1 < 1 && this.IsGroupRow(rowDataInternal))
      {
        isFirstVisible = true;
        this.GetGroupRowBounds(rightToLeft, rowDataInternal.Level, rowIndex < this.fFrozenRowCount | includeLevel, out x, out width);
        height = !this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded) ? 0 : rowDataInternal.Height;
      }
      else
      {
        x = this.ColToX(colOrder, rowIndex < this.fFrozenRowCount | includeLevel, out isFirstVisible);
        iGColDisposition colDisposition = this.GetColDisposition(colOrder);
        switch (colDisposition)
        {
          case iGColDisposition.RowText:
            width = this.GetSumOfColWidthsAboveRowText(out firstVisibleAboveRowTextColOrder);
            if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
            {
              y += rowDataInternal.NormalCellHeight;
              height = rowDataInternal.Height - rowDataInternal.NormalCellHeight;
              break;
            }
            height = 0;
            break;
          case iGColDisposition.Auxiliary:
            width = 0;
            height = 0;
            break;
          default:
            iGColData colData = this.GetColData(colIndex1);
            width = !this.IsColVisible(colData.Visible, colData.ShowWhenGrouped, colIndex1) ? 0 : colData.Width;
            height = !this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded) ? 0 : (colDisposition != iGColDisposition.AboveRowText ? rowDataInternal.Height : (rowDataInternal.NormalCellHeight < rowDataInternal.Height ? rowDataInternal.NormalCellHeight : rowDataInternal.Height));
            if (this.fMergedCellCountAll > 0)
            {
              iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex1);
              if (cellDataInternal.SpanCols > 1)
              {
                int num = this.MergedCellExpandWidthDelta(colOrder, cellDataInternal.SpanCols);
                width += num;
                if (rightToLeft)
                  x -= num;
              }
              if (cellDataInternal.SpanRows > 1)
              {
                height += this.MergedCellExpandHeightDelta(rowIndex, cellDataInternal.SpanRows);
                break;
              }
              break;
            }
            break;
        }
        if (colDisposition != iGColDisposition.Auxiliary)
        {
          bool flag;
          int colIndex2;
          if (colDisposition == iGColDisposition.RowText)
          {
            int colIndex3 = this.GetColIndex(firstVisibleAboveRowTextColOrder);
            flag = !this.IsTreeColSpecified() ? firstVisibleAboveRowTextColOrder == this.GetFirstVisibleColOrder() : this.IsTreeCol(colIndex3);
            colIndex2 = !flag ? int.MinValue : colIndex3;
          }
          else
          {
            flag = !this.IsTreeColSpecified() ? isFirstVisible : this.IsTreeCol(colIndex1);
            colIndex2 = !flag ? int.MinValue : colIndex1;
          }
          if (flag)
          {
            if (includeLevel || rowIndex < this.fFrozenRowCount)
            {
              width += this.GetGroupLevelsExtraWidth();
            }
            else
            {
              int widthFromColWidth = this.GetCellWidthFromColWidth(isFirstVisible, colIndex2, 0, rowIndex, rowDataInternal.Level, this.GetGroupObjectColCount());
              if (this.RightToLeft != RightToLeft.Yes)
                x -= widthFromColWidth;
              width += widthFromColWidth;
            }
          }
        }
      }
      return new Rectangle(x, y, width, height);
    }

    internal Rectangle GetCellBounds(int rowIndex, int colOrder, bool includeLevel)
    {
      bool isFirstVisible;
      return this.GetCellBounds(rowIndex, colOrder, includeLevel, out isFirstVisible);
    }

    internal void GetGroupRowBounds(bool rightToLeft, int rowDataLevel, bool includeLevel, out int x, out int width)
    {
      int num = rowDataLevel * this.fLevelIndent;
      x = this.GetBorderSize() + this.fRowHeader.EffectiveWidth();
      if (!includeLevel)
        x = x + num;
      width = this.fVisibleColsWidthPlusGroupObjectLevelArea;
      if (!includeLevel)
        width = width - num;
      if (this.IsLevelAreaScrollableNoTreeCol())
        x = x - this.fHScrollBar.Value;
      else
        width = width - this.fHScrollBar.Value;
      if (!rightToLeft)
        return;
      x = this.Width - x - width;
    }

    internal bool GetCellFromPoint(int x, int y, bool includeLevel, out int rowIndex, out int colIndex, out Rectangle bounds)
    {
      int colOrder;
      int num = this.GetCellFromPointInternal(x, y, includeLevel, out rowIndex, out colOrder, out bounds) ? 1 : 0;
      if (num != 0)
      {
        colIndex = this.fColIdxFromOrd[colOrder];
        return num != 0;
      }
      colIndex = colOrder;
      return num != 0;
    }

    private bool GetCellFromPointInternal(int x, int y, bool includeLevel, out int rowIndex, out int colOrder, out Rectangle bounds)
    {
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int rowY;
      int rowHeight;
      if (!this.GetRowFromY(y, out rowIndex, out rowY, out rowHeight))
      {
        colOrder = 0;
        bounds = Rectangle.Empty;
        return false;
      }
      iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
      int x1;
      int width;
      if (this.IsGroupRow(rowDataInternal))
      {
        this.GetGroupRowBounds(rightToLeft, rowDataInternal.Level, rowIndex < this.fFrozenRowCount, out x1, out width);
        if (x < x1 || x >= x1 + width)
        {
          bounds = Rectangle.Empty;
          rowIndex = 0;
          colOrder = 0;
          return false;
        }
        colOrder = 0;
      }
      else
      {
        if (!this.GetColFromXInternal(x, rowDataInternal.Level, true, out colOrder, out x1, out width))
        {
          bounds = Rectangle.Empty;
          rowIndex = 0;
          return false;
        }
        int colIndex1 = this.fColIdxFromOrd[colOrder];
        if (this.fMergedCellCountAll > 0)
        {
          iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex1);
          if (cellDataInternal.SpanCols < 1)
          {
            colOrder = colOrder + cellDataInternal.SpanCols;
            colIndex1 = this.fColIdxFromOrd[colOrder];
            cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex1);
          }
          if (cellDataInternal.SpanRows < 1)
          {
            rowIndex = rowIndex + cellDataInternal.SpanRows;
            cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex1);
          }
          if (cellDataInternal.SpanCols > 1 || cellDataInternal.SpanRows > 1)
          {
            Rectangle cellBounds = this.GetCellBounds(rowIndex, colOrder, true);
            x1 = cellBounds.X;
            rowY = cellBounds.Y;
            width = cellBounds.Width;
            rowHeight = cellBounds.Height;
          }
        }
        int firstVisibleColOrder = this.GetFirstVisibleColOrder();
        int colDisposition = (int) this.GetColDisposition(colOrder);
        int num1 = 1;
        bool flag = colDisposition == num1 && y >= rowY + rowDataInternal.NormalCellHeight;
        int startVisibleColOrder = this.GetRowTextStartVisibleColOrder();
        if (!includeLevel && rowIndex >= this.fFrozenRowCount && ((!this.IsTreeColSpecified() ? firstVisibleColOrder == colOrder : this.IsTreeCol(colIndex1)) && (!flag || colOrder == startVisibleColOrder)))
        {
          width -= rowDataInternal.Level * this.fLevelIndent;
          if (!rightToLeft)
            x1 += rowDataInternal.Level * this.fLevelIndent;
        }
        int num2 = 1;
        if (colDisposition == num2)
        {
          if (flag)
          {
            rowY += rowDataInternal.NormalCellHeight;
            rowHeight = rowDataInternal.Height - rowDataInternal.NormalCellHeight;
            int num3 = 0;
            for (int index = colOrder - 1; index >= 0 && index >= this.fRowTextStartColNear; --index)
            {
              int colIndex2 = this.fColIdxFromOrd[index];
              iGColData fColData = this.fColDatas[colIndex2];
              if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex2))
              {
                num3 += fColData.Width;
                if ((!this.IsTreeColSpecified() ? firstVisibleColOrder == index : this.IsTreeCol(colIndex2)) && (!flag || index == startVisibleColOrder))
                {
                  num3 += this.GetGroupLevelsExtraWidth();
                  if (!includeLevel && rowIndex >= this.fFrozenRowCount)
                    num3 -= rowDataInternal.Level * this.fLevelIndent;
                }
              }
            }
            if (!rightToLeft)
              x1 -= num3;
            width += num3;
            int num4 = 0;
            int rowTextEndColOrder = this.GetRowTextEndColOrder();
            for (int index = colOrder + 1; index <= rowTextEndColOrder; ++index)
            {
              int colIndex2 = this.fColIdxFromOrd[index];
              iGColData fColData = this.fColDatas[colIndex2];
              if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex1))
              {
                num4 += fColData.Width;
                if ((!this.IsTreeColSpecified() ? firstVisibleColOrder == index : this.IsTreeCol(colIndex2)) && (!flag || index == startVisibleColOrder))
                {
                  num4 += this.GetGroupLevelsExtraWidth();
                  if (!includeLevel && rowIndex >= this.fFrozenRowCount)
                    num4 -= rowDataInternal.Level * this.fLevelIndent;
                }
              }
            }
            if (rightToLeft)
              x1 -= num4;
            width += num4;
            colOrder = 0;
          }
          else
            rowHeight = rowDataInternal.NormalCellHeight;
        }
        if (width <= 0 || x < x1 || x >= x1 + width)
        {
          bounds = Rectangle.Empty;
          rowIndex = 0;
          return false;
        }
      }
      bounds = new Rectangle(x1, rowY, width, rowHeight);
      return true;
    }

    internal void EnsureVisibleCell(int rowIndex, int colIndex)
    {
      this.CheckCellIndices(rowIndex, colIndex);
      iGCellData cellDataInternal = this.GetCellDataInternal(rowIndex, colIndex);
      int rowCount = cellDataInternal.SpanRows > 1 ? cellDataInternal.SpanRows : 1;
      this.EnsureVisibleRowRangeCore(rowIndex, rowCount);
      int colCount = cellDataInternal.SpanCols > 1 ? cellDataInternal.SpanCols : 1;
      this.EnsureVisibleColRangeCore(colIndex, colCount);
    }

    internal void EnsureVisibleCol(int colIndex)
    {
      this.CheckColIndex(colIndex);
      this.EnsureVisibleColRangeCore(colIndex, 1);
    }

    private void EnsureVisibleColRangeCore(int colIndex, int colCount)
    {
      if (!this.fEnsureVisibleAutoHScroll || !this.IsScrollableHorz())
        return;
      int colOrder1 = this.GetColOrder(colIndex);
      if (colOrder1 < this.fFrozenColCount && (!this.IsRowTextDisplayed() || colIndex != 0))
        return;
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      bool isFirstVisible;
      int x = this.ColToX(colOrder1, rightToLeft, this.fFrozenRowCount > 0, out isFirstVisible);
      int borderSize = this.GetBorderSize();
      int num1 = 0;
      switch (this.GetColDisposition(colOrder1))
      {
        case iGColDisposition.RowText:
          num1 = this.GetSumOfColWidthsAboveRowText();
          if (this.fFrozenRowCount > 0 & isFirstVisible)
          {
            num1 += this.GetGroupLevelsExtraWidth();
            break;
          }
          break;
        case iGColDisposition.Auxiliary:
          return;
        default:
          int colOrder2 = this.GetColOrder(colIndex);
          for (int index = 0; index < colCount; ++index)
          {
            int colIndex1 = this.fColIdxFromOrd[colOrder2 + index];
            iGColData colData = this.GetColData(colIndex1);
            if (this.IsColVisible(colData.Visible, colData.ShowWhenGrouped, colIndex1))
              num1 += colData.Width;
          }
          if (this.fFrozenRowCount > 0 & isFirstVisible)
          {
            num1 += this.GetGroupLevelsExtraWidth();
            break;
          }
          break;
      }
      if (rightToLeft)
      {
        int num2;
        int num3 = num2 = x + num1 - (this.Width - borderSize - this.fRowHeader.EffectiveWidth() - this.fFrozenColsWidth);
        if (num2 > 0)
        {
          this.SetHScrollBarValue(this.fHScrollBar.Value - num2, true);
        }
        else
        {
          int num4 = borderSize - x + this.GetVScrollBarWidth(this.fVScrollBar.Visible);
          if (-num3 < num4)
            num4 = -num3;
          if (num4 <= 0)
            return;
          this.SetHScrollBarValue(this.fHScrollBar.Value + num4, true);
        }
      }
      else
      {
        int num2;
        int num3 = num2 = borderSize + this.fRowHeader.EffectiveWidth() + this.fFrozenColsWidth - x;
        if (num2 > 0)
        {
          this.SetHScrollBarValue(this.fHScrollBar.Value - num2, true);
        }
        else
        {
          int num4 = x + num1 - (this.Width - borderSize) + this.GetVScrollBarWidth(this.fVScrollBar.Visible);
          if (-num3 < num4)
            num4 = -num3;
          if (num4 <= 0)
            return;
          this.SetHScrollBarValue(this.fHScrollBar.Value + num4, true);
        }
      }
    }

    internal void EnsureVisibleRow(int rowIndex)
    {
      this.CheckRowIndex(rowIndex);
      this.EnsureVisibleRowRangeCore(rowIndex, 1);
    }

    private void EnsureVisibleRowRangeCore(int rowIndex, int rowCount)
    {
      if (!this.fEnsureVisibleAutoVScroll || !this.IsScrollableVert() || rowIndex < this.fFrozenRowCount)
        return;
      int borderSize = this.GetBorderSize();
      int headerAreaHeight = this.GetHeaderAreaHeight();
      int y = this.RowToY(rowIndex, headerAreaHeight, borderSize);
      int num1 = headerAreaHeight + borderSize + this.fFrozenRowsHeight - y;
      int num2 = num1;
      if (num1 > 0)
      {
        this.SetVScrollBarValue(this.fVScrollBar.Value - num1, true);
      }
      else
      {
        int num3 = y - this.Height + borderSize + this.GetFooterAreaHeight();
        for (int rowIndex1 = rowIndex; rowIndex1 < rowIndex + rowCount; ++rowIndex1)
        {
          iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
          if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
            num3 += rowDataInternal.Height;
        }
        int num4 = num3 + this.GetHScrollBarHeight();
        if (-num2 < num4)
          num4 = -num2;
        if (num4 <= 0)
          return;
        this.SetVScrollBarValue(this.fVScrollBar.Value + num4, true);
      }
    }

    /// <summary>Retrieves the upper near and bottom far cells visible on the screen and their bounds. The coordinates are relative to the upper left corner of the grid.</summary>
    /// <param name="startCell">The leftmost (rightmost in the right-to-left mode) and topmost visible cell.</param>
    /// <param name="startCellBounds">The leftmost (rightmost in the right-to-left mode) and topmost visible cell's bounds. The coordinates are relative to the upper left corner of the grid.</param>
    /// <param name="endCell">The rightmost (leftmost in the right-to-left mode) and bottommost visible cell.</param>
    /// <param name="endCellBounds">The rightmost (leftmost in the right-to-left mode) and bottommost visible cell's bounds. The coordinates are relative to the upper left corner of the grid.</param>
    public void GetStartEndCells(out iGCell startCell, out Rectangle startCellBounds, out iGCell endCell, out Rectangle endCellBounds)
    {
      if (this.fRowCount == 0 || this.fColCount == 0)
      {
        startCell = endCell = (iGCell) null;
        startCellBounds = endCellBounds = Rectangle.Empty;
      }
      else
      {
        int startColOrder;
        int startX;
        int startWidth;
        int endColOrder;
        int endX;
        int endWidth;
        this.GetStartEndVisibleScrollableCol(out startColOrder, out startX, out startWidth, out endColOrder, out endX, out endWidth);
        int startRow;
        int startY;
        int startHeight;
        int endRow;
        int endY;
        int endHeight;
        this.GetStartEndVisibleScrollableRow(out startRow, out startY, out startHeight, out endRow, out endY, out endHeight);
        startCell = new iGCell(this, startRow, this.fColIdxFromOrd[startColOrder]);
        startCellBounds = new Rectangle(startX, startY, startWidth, startHeight);
        endCell = new iGCell(this, endRow, this.fColIdxFromOrd[endColOrder]);
        endCellBounds = new Rectangle(endX, endY, endWidth, endHeight);
      }
    }

    internal void GetStartEndVisibleScrollableCol(out int startColOrder, out int startX, out int startWidth, out int endColOrder, out int endX, out int endWidth)
    {
      startColOrder = 0;
      endColOrder = 0;
      startWidth = 0;
      endWidth = 0;
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int firstColX = this.GetFirstColX(rightToLeft);
      int x = !rightToLeft ? firstColX + this.fFrozenColsWidth : firstColX - this.fFrozenColsWidth;
      int num1 = endX = startX = this.GetScrolledX(x, rightToLeft);
      if (this.fColCount < this.fFrozenColCount)
        return;
      int fFrozenColCount = this.fFrozenColCount;
      bool flag = false;
      iGColData iGcolData = new iGColData();
      int num2 = -1;
      if (rightToLeft)
      {
        int num3 = this.GetBorderSize() + this.GetVScrollBarWidth();
        for (; fFrozenColCount < this.fColCount; ++fFrozenColCount)
        {
          int colIndex = this.fColIdxFromOrd[fFrozenColCount];
          iGcolData = this.fColDatas[colIndex];
          if (this.IsColVisible(iGcolData.Visible, iGcolData.ShowWhenGrouped, colIndex))
          {
            num1 -= iGcolData.Width;
            num2 = fFrozenColCount;
            if (!flag && num1 < x)
            {
              flag = true;
              startColOrder = fFrozenColCount;
              if (this.fFrozenVisibleColCount == 0)
                num1 -= this.GetGroupLevelsExtraWidth();
              startX = num1;
              startWidth = iGcolData.Width;
            }
            if (num1 <= num3)
              break;
          }
        }
      }
      else
      {
        int num3 = this.Width - this.GetBorderSize() - this.GetVScrollBarWidth();
        for (; fFrozenColCount < this.fColCount; ++fFrozenColCount)
        {
          int colIndex = this.fColIdxFromOrd[fFrozenColCount];
          iGcolData = this.fColDatas[colIndex];
          if (this.IsColVisible(iGcolData.Visible, iGcolData.ShowWhenGrouped, colIndex))
          {
            num1 += iGcolData.Width;
            num2 = fFrozenColCount;
            if (!flag && num1 > x)
            {
              flag = true;
              startColOrder = fFrozenColCount;
              if (this.fFrozenVisibleColCount == 0)
                num1 += this.GetGroupLevelsExtraWidth();
              startX = num1 - iGcolData.Width;
              startWidth = iGcolData.Width;
            }
            if (num1 >= num3)
              break;
          }
        }
      }
      if (!flag)
        return;
      endColOrder = num2;
      endX = num1;
      if (!rightToLeft)
        endX = endX - iGcolData.Width;
      endWidth = iGcolData.Width;
    }

    internal void GetStartEndVisibleScrollableRow(out int startRow, out int startY, out int startHeight, out int endRow, out int endY, out int endHeight)
    {
      endRow = startRow = this.fViewportFirstRowIndex;
      startHeight = 0;
      endHeight = 0;
      int borderSize = this.GetBorderSize();
      int num1 = startY = endY = borderSize + this.GetHeaderAreaHeight() + this.fFrozenRowsHeight - this.fViewportFirstRowHiddenHeight;
      int num2 = this.Height - borderSize - this.GetFooterAreaHeight() - this.GetHScrollBarHeight();
      bool flag = false;
      iGRowData iGrowData = new iGRowData();
      for (int viewportFirstRowIndex = this.fViewportFirstRowIndex; viewportFirstRowIndex < this.fRowCount; ++viewportFirstRowIndex)
      {
        iGrowData = this.GetRowDataInternal(viewportFirstRowIndex);
        if (this.IsRowVisibleInternal(iGrowData.Visible, iGrowData.VisibleParentExpanded))
        {
          num1 += iGrowData.Height;
          if (!flag)
          {
            startHeight = iGrowData.Height;
            flag = true;
          }
          endRow = viewportFirstRowIndex;
        }
        if (num1 >= num2)
          break;
      }
      if (!flag)
        return;
      endY = num1 - iGrowData.Height;
      endHeight = iGrowData.Height;
    }

    private int GetGroupBoxColHdrY(int groupIndex, int borderSize)
    {
      return borderSize + 6 + groupIndex * 10;
    }

    internal bool GetGroupBoxColHdrFromPointInternal(Graphics g, int ptX, int ptY, bool rightToLeft, out int colIndex, out int x, out int y, out int width, out int height)
    {
      colIndex = -1;
      x = 0;
      y = 0;
      width = 0;
      height = 0;
      this.AdjustGroupColsWidths(g);
      if (!this.fGroupBoxVisible || this.fLastGroupObject == null)
        return false;
      int borderSize = this.GetBorderSize();
      if (rightToLeft)
        ptX = this.Width - ptX - 1;
      ptX -= borderSize + 6;
      if (ptX < 0)
        return false;
      int num1 = 0;
      int index;
      for (index = 0; index < this.fLastGroupObject.Count; ++index)
      {
        int fGroupColsWidth = this.fGroupColsWidths[index];
        int num2 = num1 + fGroupColsWidth;
        if (ptX < num2)
        {
          colIndex = this.fLastGroupObject.GetColIndexFromSortIndex(index);
          x = num2 - fGroupColsWidth + borderSize + 6;
          if (rightToLeft)
            x = this.Width - x - fGroupColsWidth;
          width = fGroupColsWidth;
          break;
        }
        num1 = num2 + 4;
        if (ptX < num1)
          return false;
      }
      if (colIndex < 0)
        return false;
      int groupColHdrHeight = this.GetGroupColHdrHeight();
      int groupBoxColHdrY = this.GetGroupBoxColHdrY(index, borderSize);
      if (ptY < groupBoxColHdrY || ptY >= groupBoxColHdrY + groupColHdrHeight)
        return false;
      y = groupBoxColHdrY;
      height = groupColHdrHeight;
      return true;
    }

    private Rectangle GetGroupBoxBounds(bool rightToLeft)
    {
      if (!this.fGroupBoxVisible)
        return Rectangle.Empty;
      int borderSize = this.GetBorderSize();
      int vscrollBarWidth = this.GetVScrollBarWidth();
      return new Rectangle(!rightToLeft ? borderSize : borderSize + vscrollBarWidth, borderSize, this.Width - 2 * borderSize - vscrollBarWidth, this.GetGroupBoxHeight());
    }

    private Rectangle GetGroupBoxColHdrBounds(int colIndex)
    {
      this.CheckColIndex(colIndex);
      if (this.fLastGroupObject == null || this.fLastGroupObject.fParams[colIndex].SortOrder == iGSortOrder.None)
        return Rectangle.Empty;
      int sortIndex = this.fLastGroupObject.fParams[colIndex].SortIndex;
      int borderSize = this.GetBorderSize();
      int x = borderSize + 6;
      int width = 0;
      for (int index = 0; index < this.fLastGroupObject.Count; ++index)
      {
        width = this.fGroupColsWidths[index];
        if (index != sortIndex)
          x += width + 4;
        else
          break;
      }
      if (this.RightToLeft == RightToLeft.Yes)
        x = this.Width - x - width;
      int groupColHdrHeight = this.GetGroupColHdrHeight();
      int groupBoxColHdrY = this.GetGroupBoxColHdrY(sortIndex, borderSize);
      return new Rectangle(x, groupBoxColHdrY, width, groupColHdrHeight);
    }

    private int GetGroupIndexToInsert(Graphics g, int x, bool rightToLeft, out int boundX)
    {
      if (rightToLeft)
        x = this.Width - x - 1;
      int borderSize = this.GetBorderSize();
      x -= borderSize + 6;
      this.AdjustGroupColsWidths(g);
      if (this.GetGroupObjectColCount() == 0)
      {
        boundX = borderSize + 6 - 2;
        if (rightToLeft)
          boundX = this.Width - boundX - 1;
        return 0;
      }
      int num = 0;
      int index;
      for (index = 0; index < this.fLastGroupObject.Count; ++index)
      {
        int fGroupColsWidth = this.fGroupColsWidths[index];
        if (x >= num + fGroupColsWidth / 2)
          num += 4 + fGroupColsWidth;
        else
          break;
      }
      boundX = num - 2 + borderSize + 6;
      if (rightToLeft)
        boundX = this.Width - boundX - 1;
      return index;
    }

    internal Rectangle GetColHdrTextAreaBounds(int rowIndex, int colIndex)
    {
      return this.GetColHdrImageAndTextAreaBounds(rowIndex, colIndex, true);
    }

    private Rectangle GetColHdrImageAndTextAreaBounds(int rowIndex, int colIndex, bool excludeImageArea)
    {
      this.CheckColHdrIndices(rowIndex, colIndex);
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int colOrder = this.GetColOrder(colIndex);
      Rectangle colHdrBounds = this.GetColHdrBounds(rowIndex, colOrder);
      int x1 = colHdrBounds.X;
      int y1 = colHdrBounds.Y;
      int width1 = colHdrBounds.Width;
      int height1 = colHdrBounds.Height;
      iGColHdrData colHdrDataInternal = this.GetColHdrDataInternal(rowIndex, colIndex);
      iGColHdrStyle style = colHdrDataInternal.Style;
      iGColHdrStyle colHdrStyle = this.GetColData(colIndex).ColHdrStyle;
      iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType((iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle);
      iGCellDrawTypeFlags stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags((iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle);
      iGCellDrawFlags fromStylesDrawFlags = this.GetPropFromStyles_DrawFlags((iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle);
      IiGDropDownControl stylesDropDownControl = this.GetPropFromStyles_DropDownControl((iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle);
      this.ExcludeGridLinesFromColHdrBounds(rowIndex, colOrder, ref x1, ref y1, ref width1, ref height1, rightToLeft);
      IiGControlPaint controlPaint = this.fCustomControlPaint == null || (this.fCustomControlPaint.SupportedFunctions & iGControlPaintFunctions.Header) != iGControlPaintFunctions.Header ? (IiGControlPaint) this.fHeaderControlPaintStyle.ControlPaint : this.fCustomControlPaint;
      if (this.fHeaderDrawSystem)
      {
        iGIndent headerIndent = controlPaint.GetHeaderIndent(rightToLeft);
        x1 += headerIndent.fLeft;
        width1 -= headerIndent.fLeft + headerIndent.fRight;
        y1 += headerIndent.fTop;
        height1 -= headerIndent.fTop + headerIndent.fBottom;
      }
      this.ExcludeComboButtonFromCellBounds(fromStylesDrawType, stylesDrawTypeFlags, stylesDropDownControl, rightToLeft, ref x1, ref y1, ref width1, ref height1);
      using (Graphics graphics = this.CreateGraphics())
      {
        int sortIndexForDrawing = this.GetColHdrSortIndexForDrawing(rowIndex, colIndex, false);
        Font uniCellFont = this.GetUniCellFont(iGGridSection.Header, rowIndex, colIndex, (iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle, iGControlState.Normal, false, false, false, false);
        int sortAreaWidth = this.GetSortAreaWidth(graphics, sortIndexForDrawing, controlPaint, uniCellFont, style, colHdrStyle, false, false);
        if (rightToLeft)
          x1 += sortAreaWidth;
        width1 -= sortAreaWidth;
      }
      iGIndent stylesContentIndent = this.GetPropFromStyles_ContentIndent((iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle);
      iGIndent indent;
      if (excludeImageArea)
      {
        Size imageSize;
        if (fromStylesDrawType != iGCellDrawType.Check)
        {
          bool drawCellImage;
          int cellImageIndex;
          ImageList cellImageList;
          this.GetUniCellImageParamsInternal(iGGridSection.Header, rowIndex, colIndex, colHdrDataInternal.Value, (object) null, colHdrDataInternal.ImageIndex, (iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle, fromStylesDrawType, stylesDrawTypeFlags, fromStylesDrawFlags, stylesDropDownControl, out drawCellImage, out cellImageIndex, out cellImageList);
          imageSize = !drawCellImage || cellImageList == null || (cellImageIndex < 0 || cellImageIndex >= cellImageList.Images.Count) ? Size.Empty : cellImageList.ImageSize;
        }
        else
          imageSize = Size.Empty;
        indent = this.GetCellTextIndent_NoRightToLeft((iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle, imageSize, stylesContentIndent, this.GetPropFromStyles_ImageAlign((iGStyleBase) style, (iGStyleBase) null, (iGStyleBase) colHdrStyle));
      }
      else
        indent = stylesContentIndent;
      if (rightToLeft)
        indent = iGAligner.RtlTranslateIndent(indent);
      int x2 = x1 + indent.fLeft;
      int width2 = width1 - (indent.fLeft + indent.fRight);
      int y2 = y1 + indent.fTop;
      int height2 = height1 - (indent.fTop + indent.fBottom);
      return new Rectangle(x2, y2, width2, height2);
    }

    internal void ExcludeGridLinesFromColHdrBounds(int rowIndex, int colOrder, ref int x, ref int y, ref int width, ref int height, bool rightToLeft)
    {
      int headerVgridLinesWidth = this.GetHeaderVGridLinesWidth(colOrder);
      int headerHgridLinesWidth = this.GetHeaderHGridLinesWidth(rowIndex);
      if (rightToLeft)
        x = x + headerVgridLinesWidth;
      width = width - headerVgridLinesWidth;
      height = height - headerHgridLinesWidth;
    }

    internal int HeaderRowToY(int rowIndex)
    {
      int num = this.GetBorderSize() + this.GetHeaderAreaHeight();
      for (int index = 0; index <= rowIndex; ++index)
      {
        iGHdrRowData fHeaderRow = this.fHeaderRows[index];
        if (fHeaderRow.Visible)
          num -= fHeaderRow.Height;
      }
      return num;
    }

    internal bool GetHeaderRowFromY(int y, out int rowIndex, out int rowY, out int rowHeight)
    {
      int num = this.GetBorderSize() + this.GetGroupBoxHeight();
      if (y >= num)
      {
        for (int index = this.fHeaderRowCount - 1; index >= 0; --index)
        {
          iGHdrRowData fHeaderRow = this.fHeaderRows[index];
          if (fHeaderRow.Visible)
          {
            num += fHeaderRow.Height;
            if (num > y)
            {
              rowIndex = index;
              rowHeight = fHeaderRow.Height;
              rowY = num - rowHeight;
              return true;
            }
          }
        }
      }
      rowIndex = rowY = rowHeight = 0;
      return false;
    }

    private bool GetColHdrFromPointNoMerge(int ptX, int ptY, out int rowIndex, out int colOrder, out int x, out int y, out int width, out int height, int lastOffset, bool rightToLeft, out bool isLastVisibleCol)
    {
      isLastVisibleCol = false;
      if (!this.GetHeaderRowFromY(ptY, out rowIndex, out y, out height))
      {
        colOrder = width = x = 0;
        return false;
      }
      return this.GetColFromXInternal(ptX, 0, true, out colOrder, out x, out width, lastOffset, rightToLeft, out isLastVisibleCol);
    }

    internal bool GetColHdrFromPoint(int ptX, int ptY, out int rowIndex, out int rowCount, out int colIndex, out int colCount, out Rectangle bounds)
    {
      int colOrder;
      int num = this.GetColHdrFromPointInternal(ptX, ptY, out rowIndex, out rowCount, out colOrder, out colCount, out bounds) ? 1 : 0;
      if (num != 0)
      {
        colIndex = this.GetColIndexOfColHdr(false, false, rowIndex, colOrder);
        return num != 0;
      }
      colIndex = colOrder;
      return num != 0;
    }

    private bool GetColHdrFromPointInternal(int ptX, int ptY, out int rowIndex, out int rowCount, out int colOrder, out int colCount, out Rectangle bounds)
    {
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int x;
      int y;
      int width;
      int height;
      bool isLastVisibleCol;
      if (!this.GetColHdrFromPointNoMerge(ptX, ptY, out rowIndex, out colOrder, out x, out y, out width, out height, 0, rightToLeft, out isLastVisibleCol))
      {
        rowCount = colCount = 0;
        bounds = Rectangle.Empty;
        return false;
      }
      this.Span__GetMergedCellBounds(iGGridSection.Header, ref rowIndex, out rowCount, ref colOrder, out colCount, ref x, ref y, ref width, ref height, rightToLeft);
      bounds = new Rectangle(x, y, width, height);
      return true;
    }

    internal Rectangle GetColHdrBounds(int rowIndex, int colOrder)
    {
      this.CheckColHdrIndices(rowIndex, colOrder);
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      bool isFirstVisible;
      int x = this.ColToX(colOrder, rightToLeft, true, out isFirstVisible);
      int colIndex = this.fColIdxFromOrd[colOrder];
      iGColData fColData = this.fColDatas[colIndex];
      int width = !this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex) ? 0 : fColData.Width;
      if (this.Span__IsCellInFirstVisibleCol(iGGridSection.Header, rowIndex, colOrder))
      {
        int levelsExtraWidth = this.GetGroupLevelsExtraWidth();
        width += levelsExtraWidth;
        if (rightToLeft && !isFirstVisible)
          x -= levelsExtraWidth;
      }
      int y = this.HeaderRowToY(rowIndex);
      iGHdrRowData fHeaderRow = this.fHeaderRows[rowIndex];
      int height = !fHeaderRow.Visible ? 0 : fHeaderRow.Height;
      int rowCount;
      int colCount;
      this.Span__GetMergedCellBounds(iGGridSection.Header, ref rowIndex, out rowCount, ref colOrder, out colCount, ref x, ref y, ref width, ref height, rightToLeft);
      return new Rectangle(x, y, width, height);
    }

    internal Rectangle GetRowHdrBounds(int rowIndex)
    {
      this.CheckRowIndex(rowIndex);
      iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
      int height = !this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded) ? 0 : rowDataInternal.Height;
      return new Rectangle(this.GetRowHeaderAreaLeft(), this.RowToY(rowIndex), this.fRowHeader.EffectiveWidth(), height);
    }

    internal Rectangle GetFooterCellTextAreaBounds(int rowIndex, int colIndex)
    {
      return this.GetFooterCellImageAndTextAreaBounds(rowIndex, colIndex, true);
    }

    private Rectangle GetFooterCellImageAndTextAreaBounds(int rowIndex, int colIndex, bool excludeImageArea)
    {
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int colOrder = this.GetColOrder(colIndex);
      Rectangle footerCellBounds = this.GetFooterCellBounds(rowIndex, colOrder);
      int x1 = footerCellBounds.X;
      int y1 = footerCellBounds.Y;
      int width1 = footerCellBounds.Width;
      int height1 = footerCellBounds.Height;
      iGFooterCellData cellDataInternal = this.GetFooterCellDataInternal(rowIndex, colIndex);
      iGCellStyle cellStyle = this.GetColData(colIndex).CellStyle;
      iGCellDrawType fromStylesDrawType = this.GetPropFromStyles_DrawType((iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle);
      iGCellDrawTypeFlags stylesDrawTypeFlags = this.GetPropFromStyles_DrawTypeFlags((iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle);
      iGCellDrawFlags fromStylesDrawFlags = this.GetPropFromStyles_DrawFlags((iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle);
      int stylesCustomDrawFlags = (int) this.GetPropFromStyles_CustomDrawFlags((iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle);
      IiGDropDownControl cellDropDownControl = this.GetUniCellDropDownControl(iGGridSection.Footer, rowIndex, colIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle, false);
      this.ExcludeGridLinesFromFooterCellBounds(rowIndex, colOrder, ref x1, ref y1, ref width1, ref height1, rightToLeft);
      iGIndent stylesContentIndent = this.GetPropFromStyles_ContentIndent((iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle);
      iGIndent indent;
      if (excludeImageArea)
      {
        Size imageSize;
        if (fromStylesDrawType != iGCellDrawType.Check)
        {
          bool drawCellImage;
          int cellImageIndex;
          ImageList cellImageList;
          this.GetUniCellImageParamsInternal(iGGridSection.Footer, rowIndex, colIndex, cellDataInternal.Value, cellDataInternal.AuxValue, cellDataInternal.ImageIndex, (iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle, fromStylesDrawType, stylesDrawTypeFlags, fromStylesDrawFlags, cellDropDownControl, out drawCellImage, out cellImageIndex, out cellImageList);
          imageSize = !drawCellImage || cellImageList == null || (cellImageIndex < 0 || cellImageIndex >= cellImageList.Images.Count) ? Size.Empty : cellImageList.ImageSize;
        }
        else
          imageSize = Size.Empty;
        indent = this.GetCellTextIndent_NoRightToLeft((iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle, imageSize, stylesContentIndent, this.GetPropFromStyles_ImageAlign((iGStyleBase) cellDataInternal.Style, (iGStyleBase) null, (iGStyleBase) cellStyle));
      }
      else
        indent = stylesContentIndent;
      if (rightToLeft)
        indent = iGAligner.RtlTranslateIndent(indent);
      int x2 = x1 + indent.fLeft;
      int width2 = width1 - (indent.fLeft + indent.fRight);
      int y2 = y1 + indent.fTop;
      int height2 = height1 - (indent.fTop + indent.fBottom);
      return new Rectangle(x2, y2, width2, height2);
    }

    internal void ExcludeGridLinesFromFooterCellBounds(int rowIndex, int colOrder, ref int x, ref int y, ref int width, ref int height, bool rightToLeft)
    {
      int vgridLineWidth = this.GetVGridLineWidth(colOrder, iGColDisposition.Normal, false);
      if (rightToLeft)
        x = x + vgridLineWidth;
      width = width - vgridLineWidth;
      int num = rowIndex == 0 ? this.fFooterSeparatingLine.Width : this.fHGridLinesStyle.Width;
      y = y + num;
      height = height - num;
    }

    internal int FooterRowToY(int rowIndex)
    {
      int num = this.Height - this.GetBorderSize();
      if (this.fHScrollBar.Visible)
        num -= this.fHScrollBar.Height;
      for (int index = this.fFooterRowCount - 1; rowIndex <= index; --index)
      {
        iGFooterRowData fFooterRow = this.fFooterRows[index];
        if (fFooterRow.Visible)
          num -= fFooterRow.Height;
      }
      return num;
    }

    internal Rectangle GetFooterCellBounds(int rowIndex, int colOrder)
    {
      this.CheckFooterCellIndices(rowIndex, colOrder);
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      bool isFirstVisible;
      int x = this.ColToX(colOrder, rightToLeft, true, out isFirstVisible);
      int colIndex = this.fColIdxFromOrd[colOrder];
      iGColData fColData = this.fColDatas[colIndex];
      int width = !this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex) ? 0 : fColData.Width;
      if (this.Span__IsCellInFirstVisibleCol(iGGridSection.Footer, rowIndex, colOrder))
      {
        int levelsExtraWidth = this.GetGroupLevelsExtraWidth();
        width += levelsExtraWidth;
        if (rightToLeft && !isFirstVisible)
          x -= levelsExtraWidth;
      }
      int y = this.FooterRowToY(rowIndex);
      iGFooterRowData fFooterRow = this.fFooterRows[rowIndex];
      int height = !fFooterRow.Visible ? 0 : fFooterRow.Height;
      int rowCount;
      int colCount;
      this.Span__GetMergedCellBounds(iGGridSection.Footer, ref rowIndex, out rowCount, ref colOrder, out colCount, ref x, ref y, ref width, ref height, rightToLeft);
      return new Rectangle(x, y, width, height);
    }

    internal bool GetFooterRowFromY(int y, out int rowIndex, out int rowY, out int rowHeight)
    {
      int num = this.Height - this.GetBorderSize();
      if (this.fHScrollBar.Visible)
        num -= this.fHScrollBar.Height;
      if (y < num)
      {
        for (int index = this.fFooterRowCount - 1; index >= 0; --index)
        {
          iGFooterRowData fFooterRow = this.fFooterRows[index];
          if (fFooterRow.Visible)
          {
            num -= fFooterRow.Height;
            if (num <= y)
            {
              rowIndex = index;
              rowHeight = fFooterRow.Height;
              rowY = num;
              return true;
            }
          }
        }
      }
      rowIndex = rowY = rowHeight = 0;
      return false;
    }

    private bool GetFooterCellFromPointNoMerge(int ptX, int ptY, out int rowIndex, out int colOrder, out int x, out int y, out int width, out int height, int lastOffset, bool rightToLeft, out bool isLastVisibleCol)
    {
      isLastVisibleCol = false;
      if (!this.GetFooterRowFromY(ptY, out rowIndex, out y, out height))
      {
        colOrder = width = x = 0;
        return false;
      }
      return this.GetColFromXInternal(ptX, 0, true, out colOrder, out x, out width, lastOffset, rightToLeft, out isLastVisibleCol);
    }

    private bool GetFooterCellFromPointInternal(int ptX, int ptY, out int rowIndex, out int rowCount, out int colOrder, out int colCount, out Rectangle bounds)
    {
      bool rightToLeft = this.RightToLeft == RightToLeft.Yes;
      int x;
      int y;
      int width;
      int height;
      bool isLastVisibleCol;
      if (!this.GetFooterCellFromPointNoMerge(ptX, ptY, out rowIndex, out colOrder, out x, out y, out width, out height, 0, rightToLeft, out isLastVisibleCol))
      {
        rowCount = colCount = 0;
        bounds = Rectangle.Empty;
        return false;
      }
      this.Span__GetMergedCellBounds(iGGridSection.Footer, ref rowIndex, out rowCount, ref colOrder, out colCount, ref x, ref y, ref width, ref height, rightToLeft);
      bounds = new Rectangle(x, y, width, height);
      return true;
    }

    internal bool GetFooterCellFromPoint(int ptX, int ptY, out int rowIndex, out int rowCount, out int colIndex, out int colCount, out Rectangle bounds)
    {
      int colOrder;
      int num = this.GetFooterCellFromPointInternal(ptX, ptY, out rowIndex, out rowCount, out colOrder, out colCount, out bounds) ? 1 : 0;
      if (num != 0)
      {
        colIndex = this.GetColIndexOfFooterCell(false, false, rowIndex, colOrder);
        return num != 0;
      }
      colIndex = colOrder;
      return num != 0;
    }

    private void InitializeScrollBars()
    {
      this.fVScrollBar = new iGVScrollBar(false, false, true);
      this.HideVScrollBar();
      this.fVScrollBar.SmallChange = 16;
      this.fVScrollBar.ValueChanging += new iGScrollBarValueChangingEventHandler(this.fVScrollBar_ValueChanging);
      this.fVScrollBar.ValueChanged += new EventHandler(this.fVScrollBar_ValueChanged);
      this.fVScrollBar.Invalidated += new InvalidateEventHandler(this.fVScrollBar_Invalidated);
      this.fVScrollBar.MouseDown += new MouseEventHandler(this.AutoScroll_OnScrollBarMouseDown);
      this.fVScrollBar.MouseMove += new MouseEventHandler(this.AutoScroll_OnScrollBarMouseMove);
      this.fVScrollBar.Scroll += new iGScrollEventHandler(this.fVScrollBar_Scroll);
      this.fVScrollBar.CustBtnClick += new iGScrollBarCustomButtonClickEventHandler(this.VScrollBar_CustBtnClick);
      this.fVScrollBar.CustBtnDrawBackground += new iGScrollBarCustomButtonDrawEventHandler(this.VScrollBar_CustBtnDrawBackground);
      this.fVScrollBar.CustBtnDrawForeground += new iGScrollBarCustomButtonDrawEventHandler(this.VScrollBar_CustBtnDrawForeground);
      this.fVScrollBar.CustBtnMouseDown += new iGScrollBarCustomButtonMouseDownUpEventHandler(this.VScrollBar_CustBtnMouseDown);
      this.fVScrollBar.CustBtnMouseUp += new iGScrollBarCustomButtonMouseDownUpEventHandler(this.VScrollBar_CustBtnMouseUp);
      this.fVScrollBar.CustBtnMouseEnter += new iGScrollBarCustomButtonMouseEnterLeaveEventHandler(this.VScrollBar_CustBtnMouseEnter);
      this.fVScrollBar.CustBtnMouseLeave += new iGScrollBarCustomButtonMouseEnterLeaveEventHandler(this.VScrollBar_CustBtnMouseLeave);
      this.fVScrollBar.CustBtnMouseMove += new iGScrollBarCustomButtonMouseMoveEventHandler(this.VScrollBar_CustBtnMouseMove);
      this.Controls.Add((Control) this.fVScrollBar);
      this.fHScrollBar = new iGHScrollBar(false, false, true);
      this.HideHScrollBar();
      this.fHScrollBar.SmallChange = 10;
      this.fHScrollBar.ValueChanging += new iGScrollBarValueChangingEventHandler(this.fHScrollBar_ValueChanging);
      this.fHScrollBar.ValueChanged += new EventHandler(this.fHScrollBar_ValueChanged);
      this.fHScrollBar.Invalidated += new InvalidateEventHandler(this.fHScrollBar_Invalidated);
      this.fHScrollBar.MouseDown += new MouseEventHandler(this.AutoScroll_OnScrollBarMouseDown);
      this.fHScrollBar.MouseMove += new MouseEventHandler(this.AutoScroll_OnScrollBarMouseMove);
      this.fHScrollBar.Scroll += new iGScrollEventHandler(this.fHScrollBar_Scroll);
      this.fHScrollBar.CustBtnClick += new iGScrollBarCustomButtonClickEventHandler(this.HScrollBar_CustBtnClick);
      this.fHScrollBar.CustBtnDrawBackground += new iGScrollBarCustomButtonDrawEventHandler(this.HScrollBar_CustBtnDrawBackground);
      this.fHScrollBar.CustBtnDrawForeground += new iGScrollBarCustomButtonDrawEventHandler(this.HScrollBar_CustBtnDrawForeground);
      this.fHScrollBar.CustBtnMouseDown += new iGScrollBarCustomButtonMouseDownUpEventHandler(this.HScrollBar_CustBtnMouseDown);
      this.fHScrollBar.CustBtnMouseUp += new iGScrollBarCustomButtonMouseDownUpEventHandler(this.HScrollBar_CustBtnMouseUp);
      this.fHScrollBar.CustBtnMouseEnter += new iGScrollBarCustomButtonMouseEnterLeaveEventHandler(this.HScrollBar_CustBtnMouseEnter);
      this.fHScrollBar.CustBtnMouseLeave += new iGScrollBarCustomButtonMouseEnterLeaveEventHandler(this.HScrollBar_CustBtnMouseLeave);
      this.fHScrollBar.CustBtnMouseMove += new iGScrollBarCustomButtonMouseMoveEventHandler(this.HScrollBar_CustBtnMouseMove);
      this.Controls.Add((Control) this.fHScrollBar);
    }

    private void SetHScrollBarVisible(bool value)
    {
      if (this.fHScrollBarVisible == value)
        return;
      this.fHScrollBar.Visible = value;
      this.fHScrollBarVisible = value;
      this.OnHScrollBarVisibleChanged(EventArgs.Empty);
    }

    private void SetVScrollBarVisible(bool value)
    {
      if (this.fVScrollBarVisible == value)
        return;
      this.fVScrollBar.Visible = value;
      this.fVScrollBarVisible = value;
      this.OnVScrollBarVisibleChanged(EventArgs.Empty);
    }

    private void HideHScrollBar()
    {
      this.SetHScrollBarValue(0, true);
      this.fHScrollBar.Maximum = 0;
      this.SetHScrollBarVisible(this.fHScrollBarVisibility == iGScrollBarVisibility.Always);
      this.fAreCellsSrollableHorz = false;
    }

    private void HideVScrollBar()
    {
      this.NullViewportFirstRowVars();
      this.NullVScrollBar();
      this.fVScrollBar.Maximum = 0;
      this.SetVScrollBarVisible(this.fVScrollBarVisibility == iGScrollBarVisibility.Always);
      this.fAreCellsSrollableVert = false;
    }

    private void SetHScrollBarValue(int value, bool prohibitNativeScrollWindow)
    {
      this.fProhibitNativeScrollWindow = prohibitNativeScrollWindow;
      this.fHScrollBar.Value = value;
    }

    private void SetVScrollBarValue(int value, bool prohibitNativeScrollWindow)
    {
      this.fProhibitNativeScrollWindow = prohibitNativeScrollWindow;
      this.fVScrollBar.Value = value;
    }

    private bool IsScrollableVert()
    {
      return this.fAreCellsSrollableVert;
    }

    private bool IsScrollableHorz()
    {
      return this.fAreCellsSrollableHorz;
    }

    private bool CanScrollVert()
    {
      if (this.fAreCellsSrollableVert)
        return this.fVScrollBar.Enabled;
      return false;
    }

    private bool CanScrollHorz()
    {
      if (this.fAreCellsSrollableHorz)
        return this.fHScrollBar.Enabled;
      return false;
    }

    private void fHScrollBar_Invalidated(object sender, InvalidateEventArgs e)
    {
      if (!this.fRedraw || !this.fHScrollBar.SuppressOnPaint)
        return;
      Rectangle invalidRect = e.InvalidRect;
      invalidRect.Offset(this.fHScrollBar.Left, this.fHScrollBar.Top);
      this.Invalidate(invalidRect);
    }

    private void fVScrollBar_Invalidated(object sender, InvalidateEventArgs e)
    {
      if (!this.fRedraw || !this.fVScrollBar.SuppressOnPaint)
        return;
      Rectangle invalidRect = e.InvalidRect;
      invalidRect.Offset(this.fVScrollBar.Left, this.fVScrollBar.Top);
      this.Invalidate(invalidRect);
    }

    private void NullViewportFirstRowVars()
    {
      this.fViewportFirstRowIndex = this.fFrozenRowCount;
      this.fViewportFirstRowHiddenHeight = 0;
      this.fViewportFirstRowVisibleCountBefore = 0;
      for (int rowIndex = 0; rowIndex < this.fFrozenRowCount && rowIndex < this.fRowCount; ++rowIndex)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          this.fViewportFirstRowVisibleCountBefore = this.fViewportFirstRowVisibleCountBefore + 1;
      }
    }

    private void NullVScrollBar()
    {
      this.fOldVScrollValue = 0;
      this.SetVScrollBarValue(0, true);
    }

    internal void GetScrollBarsVisible(out bool hScrollVisible, out bool vScrollVisible)
    {
      if (!this.fRedraw || !this.Visible)
      {
        int scrollableWidth;
        int scrollableHeight;
        int clientWidth;
        int clientHeight;
        this.GetScrollableCellsAndClientAreaSize(this.GetBorderSize(), out scrollableWidth, out scrollableHeight, out clientWidth, out clientHeight);
        this.GetScrollBarsVisible(out hScrollVisible, out vScrollVisible, ref clientWidth, ref clientHeight, scrollableWidth, scrollableHeight);
      }
      else
      {
        hScrollVisible = this.fHScrollBar.Visible;
        vScrollVisible = this.fVScrollBar.Visible;
      }
    }

    private void GetScrollBarsVisible(out bool hScrollVisible, out bool vScrollVisible, ref int clientWidth, ref int clientHeight, int width, int height)
    {
      hScrollVisible = this.GetScrollBarVisible(width, clientWidth, this.fHScrollBarVisibility);
      vScrollVisible = this.GetScrollBarVisible(height, clientHeight, this.fVScrollBarVisibility);
      if (hScrollVisible)
      {
        clientHeight = clientHeight - this.fHScrollBar.Height;
        vScrollVisible = this.GetScrollBarVisible(height, clientHeight, this.fVScrollBarVisibility);
      }
      if (!vScrollVisible)
        return;
      clientWidth = clientWidth - this.fVScrollBar.Width;
      if (hScrollVisible)
        return;
      hScrollVisible = this.GetScrollBarVisible(width, clientWidth, this.fHScrollBarVisibility);
      if (!hScrollVisible)
        return;
      clientHeight = clientHeight - this.fHScrollBar.Height;
    }

    internal bool GetVScrollBarVisible(int headerSize, int borderSize)
    {
      return this.GetScrollBarVisible(this.fVisibleRowsHeight, this.Height - headerSize - 2 * borderSize, this.fVScrollBarVisibility);
    }

    private bool GetScrollBarVisible(int size, int visibleSize, iGScrollBarVisibility visibility)
    {
      if (size > visibleSize || visibility == iGScrollBarVisibility.Always)
        return visibility != iGScrollBarVisibility.Hide;
      return false;
    }

    private int GetVScrollBarWidth()
    {
      return this.GetVScrollBarWidth(this.fVScrollBarVisible);
    }

    private int GetVScrollBarWidth(bool vScrollBarVisible)
    {
      if (vScrollBarVisible)
        return this.fVScrollBar.Width;
      return 0;
    }

    private int GetHScrollBarHeight()
    {
      return this.GetHScrollBarHeight(this.fHScrollBarVisible);
    }

    private int GetHScrollBarHeight(bool hScrollBarVisible)
    {
      if (hScrollBarVisible)
        return this.fHScrollBar.Height;
      return 0;
    }

    private void SetFrozenAreaSizes()
    {
      this.fFrozenRowsHeight = 0;
      for (int rowIndex = 0; rowIndex < this.fFrozenRowCount && rowIndex < this.fRowCount; ++rowIndex)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          this.fFrozenRowsHeight = this.fFrozenRowsHeight + rowDataInternal.Height;
      }
      this.fFrozenColsWidth = 0;
      this.fFrozenVisibleColCount = 0;
      for (int index = 0; index < this.fFrozenColCount && index < this.fColCount; ++index)
      {
        int colIndex = this.fColIdxFromOrd[index];
        iGColData fColData = this.fColDatas[colIndex];
        if (this.IsColVisible(fColData.Visible, fColData.ShowWhenGrouped, colIndex))
        {
          this.fFrozenColsWidth = this.fFrozenColsWidth + fColData.Width;
          this.fFrozenVisibleColCount = this.fFrozenVisibleColCount + 1;
        }
      }
      if (this.fFrozenVisibleColCount <= 0)
        return;
      this.fFrozenColsWidth = this.fFrozenColsWidth + this.GetGroupLevelsExtraWidth();
    }

    private void SetHScrollBarVisibility(bool hScrollBarVisible, bool vScrollBarVisible, int scrollableColsWidth, int scrollableAreaWidth, int borderSize)
    {
      int val2 = scrollableColsWidth - scrollableAreaWidth;
      if (!this.fRedraw)
      {
        if (val2 > 0)
          this.fRedrawOffHScrollBarMaxValue = Math.Min(this.fRedrawOffHScrollBarMaxValue, val2);
        else
          this.fRedrawOffHScrollBarMaxValue = 0;
      }
      else
      {
        if (val2 > 0)
        {
          this.fAreCellsSrollableHorz = true;
          this.fHScrollBar.Maximum = scrollableColsWidth - 1;
          this.fHScrollBar.LargeChange = scrollableAreaWidth;
          if (this.fHScrollBar.Value > val2)
            this.SetHScrollBarValue(val2, true);
        }
        else
          this.HideHScrollBar();
        if (hScrollBarVisible)
        {
          if (this.RightToLeft == RightToLeft.Yes & vScrollBarVisible)
            this.fHScrollBar.Left = borderSize + this.fVScrollBar.Width;
          else
            this.fHScrollBar.Left = borderSize;
          this.LayoutHScrollBar(borderSize, vScrollBarVisible);
          this.fHScrollBar.Locked = this.fHScrollBar.LargeChange == 0 || !this.fAreCellsSrollableHorz;
          this.SetHScrollBarVisible(true);
        }
        else
          this.SetHScrollBarVisible(false);
      }
    }

    private void SetVScrollBarVisibility(bool vScrollBarVisible, bool hScrollBarVisible, int scrollableRowsHeight, int scrollableAreaHeight, int borderSize)
    {
      int val2 = scrollableRowsHeight - scrollableAreaHeight;
      if (!this.fRedraw)
      {
        if (val2 > 0)
          this.fRedrawOffVScrollBarMaxValue = Math.Min(this.fRedrawOffVScrollBarMaxValue, val2);
        else
          this.fRedrawOffVScrollBarMaxValue = 0;
      }
      else
      {
        if (val2 > 0)
        {
          if (!this.fAreCellsSrollableVert)
          {
            this.NullViewportFirstRowVars();
            this.fAreCellsSrollableVert = true;
          }
          this.fVScrollBar.Maximum = scrollableRowsHeight - 1;
          this.fVScrollBar.LargeChange = scrollableAreaHeight;
          if (this.fVScrollBar.Value > val2)
            this.SetVScrollBarValue(val2, true);
        }
        else
          this.HideVScrollBar();
        if (vScrollBarVisible)
        {
          this.fVScrollBar.Top = borderSize;
          this.LayoutVScrollBar(borderSize, hScrollBarVisible);
          this.fVScrollBar.Locked = this.fVScrollBar.LargeChange == 0 || !this.fAreCellsSrollableVert;
          this.SetVScrollBarVisible(true);
        }
        else
          this.SetVScrollBarVisible(false);
      }
    }

    private void GetScrollableCellsAndClientAreaSize(int borderSize, out int scrollableWidth, out int scrollableHeight, out int clientWidth, out int clientHeight)
    {
      scrollableHeight = this.fVisibleRowsHeight - this.fFrozenRowsHeight + this.fMarginAfterLastRow;
      scrollableWidth = this.fVisibleColsWidthPlusGroupObjectLevelArea - this.fFrozenColsWidth + this.fMarginAfterLastCol;
      clientHeight = this.Height - this.GetHeaderAreaHeight() - this.GetFooterAreaHeight() - 2 * borderSize - this.fFrozenRowsHeight;
      clientWidth = this.Width - 2 * borderSize - this.fFrozenColsWidth - this.fRowHeader.EffectiveWidth();
    }

    internal void AdjustScrollBars()
    {
      this.SetFrozenAreaSizes();
      int borderSize = this.GetBorderSize();
      int scrollableWidth;
      int scrollableHeight;
      int clientWidth;
      int clientHeight;
      this.GetScrollableCellsAndClientAreaSize(borderSize, out scrollableWidth, out scrollableHeight, out clientWidth, out clientHeight);
      bool hScrollVisible;
      bool vScrollVisible;
      this.GetScrollBarsVisible(out hScrollVisible, out vScrollVisible, ref clientWidth, ref clientHeight, scrollableWidth, scrollableHeight);
      this.SetVScrollBarVisibility(vScrollVisible, hScrollVisible, scrollableHeight, clientHeight, borderSize);
      this.SetHScrollBarVisibility(hScrollVisible, vScrollVisible, scrollableWidth, clientWidth, borderSize);
    }

    private void LayoutVScrollBar(int borderSize, bool hScrollVisible)
    {
      if (this.RightToLeft == RightToLeft.Yes)
        this.fVScrollBar.Left = borderSize;
      else
        this.fVScrollBar.Left = this.Width - borderSize - this.fVScrollBar.Width;
      int num = this.Height - borderSize - this.fVScrollBar.Top;
      if (hScrollVisible)
        num -= this.fHScrollBar.Height;
      this.fVScrollBar.Height = num;
    }

    private void LayoutHScrollBar(int borderSize, bool vScrollVisible)
    {
      this.fHScrollBar.Top = this.Height - borderSize - this.fHScrollBar.Height;
      int num = this.Width - 2 * borderSize;
      if (vScrollVisible)
        num -= this.fVScrollBar.Width;
      this.fHScrollBar.Width = num;
    }

    private void fHScrollBar_ValueChanging(object sender, iGScrollBarValueChangingEventArgs e)
    {
      this.OnHScrollBarValueChanging(e);
    }

    private void fVScrollBar_ValueChanging(object sender, iGScrollBarValueChangingEventArgs e)
    {
      this.OnVScrollBarValueChanging(e);
    }

    private void fHScrollBar_ValueChanged(object sender, EventArgs e)
    {
      this.CancelAnyEdit();
      if (!this.fRedraw)
        return;
      if ((this.fHScrollBar.SuppressOnPaint || !this.CanUseNativeScrollGeneral() || this.fIsOneOfTheGroupRowsVisible && !this.IsGroupRowContentScrollable() ? 0 : (this.fMergedCellCountAll == 0 ? 1 : 0)) != 0)
      {
        Rectangle scrollableHorzArea = this.GetBoundsOfScrollableHorzArea();
        int nXAmount = this.fOldHScrollValue - this.fHScrollBar.Value;
        if (scrollableHorzArea.Width > Math.Abs(nXAmount))
        {
          if (this.RightToLeft == RightToLeft.Yes)
            nXAmount = -nXAmount;
          iGNativeMethods.iGRECT iGrect = new iGNativeMethods.iGRECT(scrollableHorzArea);
          iGNativeMethods.ScrollWindowEx(this.Handle, nXAmount, 0, ref iGrect, ref iGrect, IntPtr.Zero, IntPtr.Zero, 2);
          this.fScrollWindowVert = false;
          this.Update();
        }
        else
          this.InvalidateAfterScrollHorz();
      }
      else
        this.InvalidateAfterScrollHorz();
      this.fProhibitNativeScrollWindow = false;
      this.fOldHScrollValue = this.fHScrollBar.Value;
      this.MouseOnScroll();
      this.OnHScrollBarValueChanged(EventArgs.Empty);
    }

    private Rectangle GetBoundsOfScrollableHorzArea()
    {
      int borderSize = this.GetBorderSize();
      int num1 = this.fRowHeader.EffectiveWidth();
      int groupBoxHeight = this.GetGroupBoxHeight();
      int vscrollBarWidth = this.GetVScrollBarWidth();
      int x = this.RightToLeft == RightToLeft.Yes ? borderSize + vscrollBarWidth : borderSize + num1 + this.fFrozenColsWidth;
      int num2 = borderSize + groupBoxHeight;
      int num3 = this.Width - 2 * borderSize - num1 - vscrollBarWidth - this.fFrozenColsWidth;
      int num4 = this.Height - 2 * borderSize - groupBoxHeight - this.GetHScrollBarHeight();
      int y = num2;
      int width = num3;
      int height = num4;
      return new Rectangle(x, y, width, height);
    }

    private void InvalidateAfterScrollHorz()
    {
      int borderSize = this.GetBorderSize();
      int num = this.fRowHeader.EffectiveWidth();
      if (this.RightToLeft == RightToLeft.Yes)
        this.Invalidate(Rectangle.FromLTRB(borderSize, borderSize, this.Width - borderSize - num, this.Height - borderSize));
      else
        this.Invalidate(Rectangle.FromLTRB(this.fFrozenColsWidth + borderSize + num, borderSize, this.Width - borderSize, this.Height - borderSize));
    }

    private void fVScrollBar_ValueChanged(object sender, EventArgs e)
    {
      this.CancelAnyEdit();
      if (!this.fRedraw)
        return;
      if (this.fVScrollBar.Value > this.fOldVScrollValue)
        this.AdjustViewportFirstRowVars_Plus(this.fOldVScrollValue - this.fViewportFirstRowHiddenHeight);
      else if (this.fVScrollBar.Value < this.fOldVScrollValue)
        this.AdjustViewportFirstRowVars_Minus(this.fOldVScrollValue - this.fViewportFirstRowHiddenHeight);
      if ((this.fVScrollBar.SuppressOnPaint || !this.CanUseNativeScrollGeneral() ? 0 : (this.fMergedCellCountAll == 0 ? 1 : 0)) != 0)
      {
        Rectangle scrollableVertArea = this.GetBoundsOfScrollableVertArea();
        int nYAmount = this.fOldVScrollValue - this.fVScrollBar.Value;
        if (scrollableVertArea.Height > Math.Abs(nYAmount))
        {
          iGNativeMethods.iGRECT iGrect = new iGNativeMethods.iGRECT(scrollableVertArea);
          iGNativeMethods.ScrollWindowEx(this.Handle, 0, nYAmount, ref iGrect, ref iGrect, IntPtr.Zero, IntPtr.Zero, 2);
          this.fScrollWindowVert = true;
          this.Update();
        }
        else
          this.InvalidateAfterScrollVert();
      }
      else
        this.InvalidateAfterScrollVert();
      this.fProhibitNativeScrollWindow = false;
      this.fOldVScrollValue = this.fVScrollBar.Value;
      this.MouseOnScroll();
      this.OnVScrollBarValueChanged(EventArgs.Empty);
    }

    private Rectangle GetBoundsOfScrollableVertArea()
    {
      Rectangle headerAreaBounds = this.GetCellsAndRowHeaderAreaBounds(true);
      headerAreaBounds.Y += this.fFrozenRowsHeight;
      headerAreaBounds.Height -= this.fFrozenRowsHeight;
      return headerAreaBounds;
    }

    private void InvalidateAfterScrollVert()
    {
      int borderSize = this.GetBorderSize();
      int headerAreaHeight = this.GetHeaderAreaHeight();
      this.Invalidate(Rectangle.FromLTRB(borderSize, headerAreaHeight + borderSize + this.fFrozenRowsHeight, this.Width - borderSize, this.Height - borderSize));
    }

    private bool CanUseNativeScrollGeneral()
    {
      if (!this.fProhibitNativeScrollWindow && this.BackgroundImage == null && ((int) this.BackColor.A == (int) byte.MaxValue && this.ControlHasNoUpdateRegion() && !this.fWatermarkWasDrawn))
        return !this.fDrawCustomBackground;
      return false;
    }

    private bool ControlHasNoUpdateRegion()
    {
      return !iGNativeMethods.GetUpdateRect(this.Handle, IntPtr.Zero, false);
    }

    private void AdjustViewportFirstRowVars_Minus(int top)
    {
      if (this.fIgnoreAdjustViewportFirstRowVars)
        return;
      int num = this.fVScrollBar.Value;
      while (num < top && this.fViewportFirstRowIndex > this.fFrozenRowCount)
      {
        int rowIndex = this.fViewportFirstRowIndex - 1;
        this.fViewportFirstRowIndex = rowIndex;
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
        {
          this.fViewportFirstRowVisibleCountBefore = this.fViewportFirstRowVisibleCountBefore - 1;
          top -= rowDataInternal.Height;
        }
      }
      this.fViewportFirstRowHiddenHeight = num - top;
    }

    private void AdjustViewportFirstRowVars_Plus(int top)
    {
      if (this.fIgnoreAdjustViewportFirstRowVars)
        return;
      int num = this.fVScrollBar.Value;
      iGRowData rowDataInternal = this.GetRowDataInternal(this.fViewportFirstRowIndex);
      if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
        top += rowDataInternal.Height;
      while (num >= top && this.fViewportFirstRowIndex < this.fRowCount - 1)
      {
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          this.fViewportFirstRowVisibleCountBefore = this.fViewportFirstRowVisibleCountBefore + 1;
        int rowIndex = this.fViewportFirstRowIndex + 1;
        this.fViewportFirstRowIndex = rowIndex;
        rowDataInternal = this.GetRowDataInternal(rowIndex);
        if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
          top += rowDataInternal.Height;
      }
      this.fViewportFirstRowHiddenHeight = -top + num;
      if (!this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
        return;
      this.fViewportFirstRowHiddenHeight = this.fViewportFirstRowHiddenHeight + rowDataInternal.Height;
    }

    internal void AdjustScrollsStyle()
    {
      if (this.fScrollBarOpacity == 1.0)
      {
        this.fVScrollBar.SuppressOnPaint = false;
        this.fHScrollBar.SuppressOnPaint = false;
      }
      else
      {
        this.fVScrollBar.SuppressOnPaint = true;
        this.fHScrollBar.SuppressOnPaint = true;
      }
    }

    /// <summary>Determines whether the specified point is over the vertical scroll bar of iGrid.</summary>
    /// <param name="x">The x-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="y">The y-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <returns>A Boolean value that indicates whether the specified point is over the vertical scroll bar.</returns>
    public bool IsPointOverVScrollBar(int x, int y)
    {
      if (this.fVScrollBar.Visible)
        return this.fVScrollBar.Bounds.Contains(x, y);
      return false;
    }

    /// <summary>Determines whether the specified point is over the horizontal scroll bar of iGrid.</summary>
    /// <param name="x">The x-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="y">The y-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <returns>A Boolean value that indicates whether the specified point is over the horizontal scroll bar.</returns>
    public bool IsPointOverHScrollBar(int x, int y)
    {
      if (this.fHScrollBar.Visible)
        return this.fHScrollBar.Bounds.Contains(x, y);
      return false;
    }

    /// <summary>Determines whether the specified point is over iGrid's size box.</summary>
    /// <param name="x">The x-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="y">The y-coordinate of the tested point in iGrid's client coordinates.</param>
    /// <param name="checkDrawSizeBox">A Boolean value that specifies whether to check if the size box is drawn.</param>
    /// <returns>A Boolean value that indicates whether the specified point is over iGrid's size box.</returns>
    public bool IsPointOverSizeBox(int x, int y, bool checkDrawSizeBox)
    {
      if (checkDrawSizeBox)
      {
        if (!this.IsDrawSizeBox())
          return false;
      }
      else if (!this.fHScrollBar.Visible || !this.fVScrollBar.Visible)
        return false;
      if (this.RightToLeft == RightToLeft.Yes)
      {
        if (x <= this.fHScrollBar.Left && y >= this.fVScrollBar.Bottom)
          return true;
      }
      else if (x >= this.fHScrollBar.Right && y >= this.fVScrollBar.Bottom)
        return true;
      return false;
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarWidthChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarWidthChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarWidthChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarWidthChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarHeightChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarHeightChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarHeightChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarHeightChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarVisibleChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarVisibleChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarVisibleChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarVisibleChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarVisibleChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarVisibleChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarVisibleChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarVisibleChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarScroll" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarScroll(iGScrollEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarScroll == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarScroll((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarScroll" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarScroll(iGScrollEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarScroll == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarScroll((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarValueChanging" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarValueChangingEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarValueChanging(iGScrollBarValueChangingEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarValueChanging == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarValueChanging((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarValueChanging" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarValueChangingEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarValueChanging(iGScrollBarValueChangingEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarValueChanging == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarValueChanging((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarValueChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarValueChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarValueChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarValueChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarValueChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarValueChanged(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarValueChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarValueChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarCustomButtonClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarCustomButtonClick(iGScrollBarCustomButtonClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarCustomButtonClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarCustomButtonClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarCustomButtonDrawBackground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonDrawEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarCustomButtonDrawBackground(iGScrollBarCustomButtonDrawEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarCustomButtonDrawBackground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarCustomButtonDrawBackground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarCustomButtonDrawForeground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonDrawEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarCustomButtonDrawForeground(iGScrollBarCustomButtonDrawEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarCustomButtonDrawForeground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarCustomButtonDrawForeground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarCustomButtonMouseDown" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseDownUpEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarCustomButtonMouseDown(iGScrollBarCustomButtonMouseDownUpEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarCustomButtonMouseDown == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarCustomButtonMouseDown((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarCustomButtonMouseUp" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseDownUpEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarCustomButtonMouseUp(iGScrollBarCustomButtonMouseDownUpEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarCustomButtonMouseUp == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarCustomButtonMouseUp((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarCustomButtonMouseEnter" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarCustomButtonMouseEnter(iGScrollBarCustomButtonMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarCustomButtonMouseEnter == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarCustomButtonMouseEnter((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarCustomButtonMouseLeave" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarCustomButtonMouseLeave(iGScrollBarCustomButtonMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarCustomButtonMouseLeave == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarCustomButtonMouseLeave((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.VScrollBarCustomButtonMouseMove" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseMoveEventArgs" /> that contains the event data.</param>
    protected virtual void OnVScrollBarCustomButtonMouseMove(iGScrollBarCustomButtonMouseMoveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.VScrollBarCustomButtonMouseMove == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.VScrollBarCustomButtonMouseMove((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarCustomButtonClick" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonClickEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarCustomButtonClick(iGScrollBarCustomButtonClickEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarCustomButtonClick == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarCustomButtonClick((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarCustomButtonDrawBackground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonDrawEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarCustomButtonDrawBackground(iGScrollBarCustomButtonDrawEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarCustomButtonDrawBackground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarCustomButtonDrawBackground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarCustomButtonDrawForeground" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonDrawEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarCustomButtonDrawForeground(iGScrollBarCustomButtonDrawEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarCustomButtonDrawForeground == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarCustomButtonDrawForeground((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarCustomButtonMouseDown" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseDownUpEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarCustomButtonMouseDown(iGScrollBarCustomButtonMouseDownUpEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarCustomButtonMouseDown == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarCustomButtonMouseDown((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarCustomButtonMouseUp" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseDownUpEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarCustomButtonMouseUp(iGScrollBarCustomButtonMouseDownUpEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarCustomButtonMouseUp == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarCustomButtonMouseUp((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarCustomButtonMouseEnter" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarCustomButtonMouseEnter(iGScrollBarCustomButtonMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarCustomButtonMouseEnter == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarCustomButtonMouseEnter((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarCustomButtonMouseLeave" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseEnterLeaveEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarCustomButtonMouseLeave(iGScrollBarCustomButtonMouseEnterLeaveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarCustomButtonMouseLeave == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarCustomButtonMouseLeave((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.HScrollBarCustomButtonMouseMove" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGScrollBarCustomButtonMouseMoveEventArgs" /> that contains the event data.</param>
    protected virtual void OnHScrollBarCustomButtonMouseMove(iGScrollBarCustomButtonMouseMoveEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.HScrollBarCustomButtonMouseMove == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.HScrollBarCustomButtonMouseMove((object) this, e);
    }

    private void fVScrollBar_Scroll(object sender, iGScrollEventArgs e)
    {
      if (!this.IsSearchAsTypeFilteringActive())
        this.CancelSearchAsType();
      this.OnVScrollBarScroll(e);
    }

    private void fHScrollBar_Scroll(object sender, iGScrollEventArgs e)
    {
      this.OnHScrollBarScroll(e);
    }

    private void VScrollBar_CustBtnDrawBackground(object sender, iGScrollBarCustomButtonDrawEventArgs e)
    {
      this.OnVScrollBarCustomButtonDrawBackground(e);
    }

    private void VScrollBar_CustBtnDrawForeground(object sender, iGScrollBarCustomButtonDrawEventArgs e)
    {
      this.OnVScrollBarCustomButtonDrawForeground(e);
      if (e.Handled || this.fVScrollBar.CustomButtons[e.Index].ImageIndex >= 0)
        return;
      iGActions action = this.fVScrollBar.CustomButtons[e.Index].Action;
      if (!this.DrawActionIconSupported(action))
        return;
      this.DrawActionIcon(e.Graphics, e.Bounds, action, e.State != iGControlState.Disabled);
    }

    private void VScrollBar_CustBtnClick(object sender, iGScrollBarCustomButtonClickEventArgs e)
    {
      this.PerformAction(this.fVScrollBar.CustomButtons[e.Index].Action);
      this.OnVScrollBarCustomButtonClick(e);
    }

    private void VScrollBar_CustBtnMouseDown(object sender, iGScrollBarCustomButtonMouseDownUpEventArgs e)
    {
      this.OnVScrollBarCustomButtonMouseDown(e);
    }

    private void VScrollBar_CustBtnMouseUp(object sender, iGScrollBarCustomButtonMouseDownUpEventArgs e)
    {
      this.OnVScrollBarCustomButtonMouseUp(e);
    }

    private void VScrollBar_CustBtnMouseEnter(object sender, iGScrollBarCustomButtonMouseEnterLeaveEventArgs e)
    {
      this.OnVScrollBarCustomButtonMouseEnter(e);
    }

    private void VScrollBar_CustBtnMouseLeave(object sender, iGScrollBarCustomButtonMouseEnterLeaveEventArgs e)
    {
      this.OnVScrollBarCustomButtonMouseLeave(e);
    }

    private void VScrollBar_CustBtnMouseMove(object sender, iGScrollBarCustomButtonMouseMoveEventArgs e)
    {
      this.OnVScrollBarCustomButtonMouseMove(e);
    }

    private void HScrollBar_CustBtnClick(object sender, iGScrollBarCustomButtonClickEventArgs e)
    {
      this.PerformAction(this.fHScrollBar.CustomButtons[e.Index].Action);
      this.OnHScrollBarCustomButtonClick(e);
    }

    private void HScrollBar_CustBtnDrawBackground(object sender, iGScrollBarCustomButtonDrawEventArgs e)
    {
      this.OnHScrollBarCustomButtonDrawBackground(e);
    }

    private void HScrollBar_CustBtnDrawForeground(object sender, iGScrollBarCustomButtonDrawEventArgs e)
    {
      this.OnHScrollBarCustomButtonDrawForeground(e);
      if (e.Handled || this.fHScrollBar.CustomButtons[e.Index].ImageIndex >= 0)
        return;
      iGActions action = this.fHScrollBar.CustomButtons[e.Index].Action;
      if (!this.DrawActionIconSupported(action))
        return;
      this.DrawActionIcon(e.Graphics, e.Bounds, action, e.State != iGControlState.Disabled);
    }

    private void HScrollBar_CustBtnMouseDown(object sender, iGScrollBarCustomButtonMouseDownUpEventArgs e)
    {
      this.OnHScrollBarCustomButtonMouseDown(e);
    }

    private void HScrollBar_CustBtnMouseUp(object sender, iGScrollBarCustomButtonMouseDownUpEventArgs e)
    {
      this.OnHScrollBarCustomButtonMouseUp(e);
    }

    private void HScrollBar_CustBtnMouseEnter(object sender, iGScrollBarCustomButtonMouseEnterLeaveEventArgs e)
    {
      this.OnHScrollBarCustomButtonMouseEnter(e);
    }

    private void HScrollBar_CustBtnMouseLeave(object sender, iGScrollBarCustomButtonMouseEnterLeaveEventArgs e)
    {
      this.OnHScrollBarCustomButtonMouseLeave(e);
    }

    private void HScrollBar_CustBtnMouseMove(object sender, iGScrollBarCustomButtonMouseMoveEventArgs e)
    {
      this.OnHScrollBarCustomButtonMouseMove(e);
    }

    private int GetVGridLineWidth(int colOrder, int lastVisibleFrozenColOrder, iGColDisposition disposition, bool isGroupRow, int rowTextVisibleEndColOrder)
    {
      if (this.fColIdxFromOrd[colOrder] == this.fLastVisibleColIndex | isGroupRow || disposition == iGColDisposition.RowText && this.fColIdxFromOrd[rowTextVisibleEndColOrder] == this.fLastVisibleColIndex)
        return this.fVLastColGridLineStyle.Width;
      if (colOrder == lastVisibleFrozenColOrder && this.fFrozenColsSeparatingLineStyle.Width > 0)
        return this.fFrozenColsSeparatingLineStyle.Width;
      return this.fVGridLinesStyle.Width;
    }

    private void GetVGridLineWidthAndVisible(bool lastVisibleCol, bool lastVisibleFrozenCol, bool drawVerticalLastCol, bool drawVerticalFrozenSeparating, bool drawVerticalLines, out bool visible, out int width)
    {
      if (lastVisibleCol)
      {
        visible = drawVerticalLastCol;
        width = this.fVLastColGridLineStyle.Width;
      }
      else if (lastVisibleFrozenCol && this.fFrozenColsSeparatingLineStyle.Width > 0)
      {
        visible = drawVerticalFrozenSeparating;
        width = this.fFrozenColsSeparatingLineStyle.Width;
      }
      else
      {
        visible = drawVerticalLines;
        width = this.fVGridLinesStyle.Width;
      }
    }

    private int GetHGridLineWidth(int rowIndex, int lastVisibleFrozenRowIndex, bool isGroupRow, bool aboveRowText)
    {
      if (rowIndex == this.fLastVisibleRowIndex && !aboveRowText)
        return this.fHLastRowGridLineStyle.Width;
      if (rowIndex == lastVisibleFrozenRowIndex && this.fFrozenRowsSeparatingLineStyle.Width > 0 && !aboveRowText)
        return this.fFrozenRowsSeparatingLineStyle.Width;
      if (isGroupRow)
        return this.fGroupRowsGridLinesStyle.Width;
      return this.fHGridLinesStyle.Width;
    }

    private void GetHGridLineWidthAndVisible(int rowIndex, int lastVisibleFrozenRowIndex, bool isGroupRow, bool drawHFrozenSeparating, bool drawHorizontalLines, bool drawHorizontalLastRow, bool drawVerticalLines, bool aboveRowText, out bool visible, out int width)
    {
      if (rowIndex == this.fLastVisibleRowIndex && !aboveRowText)
      {
        visible = drawHorizontalLastRow;
        width = this.fHLastRowGridLineStyle.Width;
      }
      else if (rowIndex == lastVisibleFrozenRowIndex && this.fFrozenRowsSeparatingLineStyle.Width > 0 && !aboveRowText)
      {
        visible = drawHFrozenSeparating;
        width = this.fFrozenRowsSeparatingLineStyle.Width;
      }
      else
      {
        visible = drawHorizontalLines && !aboveRowText | drawVerticalLines;
        width = isGroupRow ? this.fGroupRowsGridLinesStyle.Width : this.fHGridLinesStyle.Width;
      }
    }

    private int GetVGridLineWidth(int colOrder, iGColDisposition disposition, bool isGroupRow)
    {
      return this.GetVGridLineWidth(colOrder, this.GetLastVisibleFrozenColOrder(), disposition, isGroupRow, this.GetRowTextEndVisibleColOrder());
    }

    private int GetHGridLineWidth(int rowIndex, bool aboveRowText, bool isGroupRow)
    {
      return this.GetHGridLineWidth(rowIndex, this.GetLastVisibleFrozenRowIndex(), isGroupRow, aboveRowText);
    }

    internal bool IsGridLineVisible(iGPenStyle style, iGOrientation orientation, bool visibilityCheckStyleWidthOnly)
    {
      if (visibilityCheckStyleWidthOnly)
        return style.Width > 0;
      if (orientation != iGOrientation.Vertical)
      {
        if (orientation == iGOrientation.Horizontal && (this.fGridLinesMode & iGGridLinesMode.Horizontal) != iGGridLinesMode.None)
          return style.Width > 0;
      }
      else if ((this.fGridLinesMode & iGGridLinesMode.Vertical) != iGGridLinesMode.None)
        return style.Width > 0;
      return false;
    }

    internal iGrid.GridLineParams GetGridLineStyleParams(iGPenStyle gridLineStyle, iGOrientation orientation, bool visibilityCheckStyleWidthOnly)
    {
      iGrid.GridLineParams gridLineParams = new iGrid.GridLineParams();
      gridLineParams.Visible = this.IsGridLineVisible(gridLineStyle, orientation, visibilityCheckStyleWidthOnly);
      if (gridLineParams.Visible)
      {
        gridLineParams.Pen = new Pen(gridLineStyle.Color, (float) gridLineStyle.Width);
        gridLineParams.Pen.DashStyle = gridLineStyle.DashStyle;
        gridLineParams.PenOffset = (gridLineStyle.Width + 1) / 2;
        if (gridLineStyle.Width == 1 && gridLineStyle.DashStyle == DashStyle.Solid)
          gridLineParams.PenExtra = -1;
      }
      return gridLineParams;
    }

    private bool IsDrawExtraVGridLineAboveRowText(int colOrder, int rowTextVisibleEndColOrder)
    {
      return colOrder == rowTextVisibleEndColOrder;
    }

    private bool IsDrawHGridLineAboveRowText(bool drawVGridLines, bool drawHGridLines)
    {
      return drawVGridLines & drawHGridLines;
    }

    private int GetHeaderHGridLinesWidth(int rowIndex)
    {
      if (rowIndex == 0 && this.IsGridLineVisible(this.fHeaderSeparatingLine, iGOrientation.Horizontal, true))
        return this.fHeaderSeparatingLine.Width;
      return this.fHeaderHGridLinesStyle.Width;
    }

    private int GetHeaderVGridLinesWidth(int colOrder)
    {
      return this.GetHeaderVGridLinesWidth(colOrder, this.IsGridLineVisible(this.fFrozenColsSeparatingLineStyle, iGOrientation.Vertical, false), this.GetLastVisibleFrozenColOrder());
    }

    private int GetHeaderVGridLinesWidth(int colOrder, bool drawFrColsSeparatingLine, int lastVisibleFrozenColOrder)
    {
      if (drawFrColsSeparatingLine && colOrder == lastVisibleFrozenColOrder)
        return this.fFrozenColsSeparatingLineStyle.Width;
      return this.fHeaderVGridLinesStyle.Width;
    }

    private int GetFooterHGridLinesWidth(int rowIndex)
    {
      if (rowIndex == 0 && this.IsGridLineVisible(this.fFooterSeparatingLine, iGOrientation.Horizontal, true))
        return this.fFooterSeparatingLine.Width;
      return this.fHGridLinesStyle.Width;
    }

    private iGSortOrder GetColSortOrder(int colIndex)
    {
      if (this.fLastGroupObject != null)
      {
        iGSortOrder sortOrder = this.fLastGroupObject.fParams[colIndex].SortOrder;
        if (sortOrder != iGSortOrder.None)
          return sortOrder;
      }
      if (this.fSortObject != null)
        return this.fSortObject.fParams[colIndex].SortOrder;
      return iGSortOrder.None;
    }

    private iGSortType GetColSortType(int colIndex)
    {
      if (this.fLastGroupObject != null)
      {
        iGSortType sortType = this.fLastGroupObject.fParams[colIndex].SortType;
        if (sortType != iGSortType.None)
          return sortType;
      }
      if (this.fSortObject != null)
        return this.fSortObject.fParams[colIndex].SortType;
      return iGSortType.None;
    }

    private int GetSortedNotGroupedColCount()
    {
      if (this.fSortObject == null)
        return 0;
      if (this.fLastGroupObject == null)
        return this.fSortObject.Count;
      int num = 0;
      for (int index = 0; index < this.fColCount; ++index)
      {
        if (this.fSortObject.fParams[index].SortOrder != iGSortOrder.None && this.fLastGroupObject.fParams[index].SortOrder == iGSortOrder.None)
          ++num;
      }
      return num;
    }

    private int GetColHdrSortIndexForDrawing(int rowIndex, int colIndex, bool inGroupBox)
    {
      return this.GetColHdrSortIndexForDrawing(rowIndex, colIndex, inGroupBox, this.GetSortedNotGroupedColCount());
    }

    private int GetColHdrSortIndexForDrawing(int rowIndex, int colIndex, bool inGroupBox, int sortedNotGroupedColCount)
    {
      iGSortOrder sortOrder;
      int sortIndex;
      this.GetColHdrSortInfoForDrawing(rowIndex, colIndex, inGroupBox, sortedNotGroupedColCount, out sortOrder, out sortIndex);
      return sortIndex;
    }

    private void GetColHdrSortInfoForDrawing(int rowIndex, int colIndex, bool inGroupBox, out iGSortOrder sortOrder, out int sortIndex)
    {
      this.GetColHdrSortInfoForDrawing(rowIndex, colIndex, inGroupBox, this.GetSortedNotGroupedColCount(), out sortOrder, out sortIndex);
    }

    private void GetColHdrSortInfoForDrawing(int rowIndex, int colIndex, bool inGroupBox, int sortedNotGroupedColCount, out iGSortOrder sortOrder, out int sortIndex)
    {
      if (inGroupBox)
      {
        this.GetColSortInfoForDrawing(colIndex, inGroupBox, sortedNotGroupedColCount, out sortOrder, out sortIndex);
      }
      else
      {
        int spanColsNear = this.Span__GetSpanColsNear(iGGridSection.Header, rowIndex, colIndex);
        int spanColsFar = this.Span__GetSpanColsFar(iGGridSection.Header, rowIndex, colIndex);
        if (spanColsNear == 1 && spanColsFar == 1)
        {
          this.GetColSortInfoForDrawing(colIndex, inGroupBox, sortedNotGroupedColCount, out sortOrder, out sortIndex);
        }
        else
        {
          sortOrder = iGSortOrder.None;
          int colOrder1 = this.GetColOrder(colIndex);
          for (int colOrder2 = colOrder1 - spanColsNear + 1; colOrder2 <= colOrder1 + spanColsFar - 1; ++colOrder2)
          {
            int colIndex1 = this.GetColIndex(colOrder2);
            if (this.IsColVisible(colIndex1))
            {
              if (sortOrder == iGSortOrder.None)
              {
                sortOrder = this.GetColSortOrder(colIndex1);
                if (sortOrder == iGSortOrder.None)
                  break;
              }
              else if (this.GetColSortOrder(colIndex1) != sortOrder)
              {
                sortOrder = iGSortOrder.None;
                break;
              }
            }
          }
          sortIndex = sortOrder == iGSortOrder.None ? -1 : 0;
        }
      }
    }

    private void GetColSortInfoForDrawing(int colIndex, bool isGroupBox, int sortedNotGroupedColCount, out iGSortOrder sortOrder, out int sortIndex)
    {
      sortIndex = -1;
      sortOrder = iGSortOrder.None;
      if (this.fLastGroupObject != null)
      {
        iGColSortParams fParam = this.fLastGroupObject.fParams[colIndex];
        if (fParam.SortOrder != iGSortOrder.None)
        {
          if (isGroupBox)
          {
            sortIndex = 0;
            sortOrder = fParam.SortOrder;
            return;
          }
          int sortIndex1 = fParam.SortIndex;
          sortIndex = sortIndex1;
          sortOrder = fParam.SortOrder;
          int num = 0;
          for (int colIndex1 = 0; colIndex1 < this.fColCount; ++colIndex1)
          {
            if (this.fLastGroupObject.fParams[colIndex1].SortOrder != iGSortOrder.None)
            {
              if (this.GetColDataInternal(colIndex1).ShowWhenGrouped)
                ++num;
              else if (this.fLastGroupObject.fParams[colIndex1].SortIndex < sortIndex1)
                sortIndex = sortIndex - 1;
            }
          }
          if (num + sortedNotGroupedColCount <= 1)
            return;
          sortIndex = sortIndex + 1;
          return;
        }
      }
      if (this.fSortObject == null)
        return;
      iGColSortParams fParam1 = this.fSortObject.fParams[colIndex];
      sortIndex = fParam1.SortIndex;
      sortOrder = fParam1.SortOrder;
      if (this.fLastGroupObject != null && sortIndex > 0)
      {
        int num = sortIndex;
        for (int index = 0; index < this.fColCount; ++index)
        {
          if (this.fSortObject.fParams[index].SortOrder != iGSortOrder.None && this.fLastGroupObject.fParams[index].SortOrder != iGSortOrder.None && this.fSortObject.fParams[index].SortIndex < num)
            sortIndex = sortIndex - 1;
        }
      }
      if (sortIndex < 0)
        return;
      int num1 = 0;
      if (this.fLastGroupObject != null)
      {
        for (int colIndex1 = 0; colIndex1 < this.fColCount; ++colIndex1)
        {
          if (this.fLastGroupObject.fParams[colIndex1].SortOrder != iGSortOrder.None && this.GetColDataInternal(colIndex1).ShowWhenGrouped)
          {
            ++num1;
            sortIndex = sortIndex + 1;
          }
        }
      }
      if (num1 + sortedNotGroupedColCount <= 1)
        return;
      sortIndex = sortIndex + 1;
    }

    internal bool NeedIndexAdjustAfterValueChange(int rowIndex, int colIndex, iGSortType valueType)
    {
      if (!this.fStaySorted || this.fGroupRowCount > 0 || rowIndex < this.fFrozenRowCount && !this.fSortFrozenRows || !this.GetRowDataInternal(rowIndex).Sortable)
        return false;
      bool flag;
      if (colIndex == -1)
      {
        colIndex = 0;
        flag = true;
      }
      else
        flag = false;
      do
      {
        iGSortType colSortType = this.GetColSortType(colIndex);
        if ((valueType & colSortType) == colSortType)
          return true;
        if (flag)
          ++colIndex;
        else
          break;
      }
      while (colIndex < this.fColCount);
      return false;
    }

    internal bool CustomGroupValuesExist(int colIndex)
    {
      return this.fColDatas[colIndex].CustomGrouping;
    }

    internal object[] GetCustomGroupValuesIfExist(int colIndex)
    {
      if (!this.CustomGroupValuesExist(colIndex))
        return (object[]) null;
      object[] objArray = new object[this.fRowCount];
      for (int rowIndex = this.fRowCount - 1; rowIndex >= 0; --rowIndex)
      {
        if (this.GetRowDataInternal(rowIndex).Type == iGRowType.Normal)
          objArray[rowIndex] = this.DoCustomGroupValue(rowIndex, colIndex);
      }
      return objArray;
    }

    private int GetRowBeforeToInsert(iGRowType rowType, iGCellStyle rowStyle, iGCellData[] cells, int oldPos, int frozenRowCount, bool sortFrozenRows)
    {
      if (rowType != iGRowType.Normal || (this.fSortObject == null || this.fSortObject.Count == 0) && (this.fLastGroupObject == null || this.fLastGroupObject.Count == 0))
        return oldPos;
      IComparer<iGRowNavigator> comparer = (IComparer<iGRowNavigator>) new iGRowNavigatorComparer(this, iGSortObject.GetData(this.fSortObject), rowStyle, cells);
      iGRowNavigator iGrowNavigator = new iGRowNavigator(-1, -1);
      int index;
      if (sortFrozenRows)
      {
        index = 0;
      }
      else
      {
        if (this.fRowCount <= frozenRowCount)
          return this.fRowCount;
        index = frozenRowCount;
      }
      return ~Array.BinarySearch<iGRowNavigator>(this.fRowsMap, index, this.fRowCount - index, iGrowNavigator, comparer);
    }

    private int GetRowBeforeToInsert(iGRowType rowType, iGCellStyle rowStyle, int oldPos)
    {
      return this.GetRowBeforeToInsert(rowType, rowStyle, this.fDefaultCells, oldPos, this.fFrozenRowCount, this.fSortFrozenRows);
    }

    internal void DoDefaultSortInternal(int colOrder, int colCount, Keys keyModifiers, iGSortOrder sortOrder, bool invokeSort)
    {
      this.CheckSortGroupBreakMergedCells();
      if (!this.SortObject.DoDefaultSort(colOrder, colCount, keyModifiers, sortOrder))
        return;
      if (invokeSort)
        this.SortInternal();
      this.InvalidateHeaderIfRedraw();
    }

    private void CheckSortGroupBreakMergedCells()
    {
      if (this.fMergedCellCountVert > 0)
        throw new InvalidOperationException("Sorting/grouping cannot break cells merged vertically");
    }

    /// <summary>Sorts the grid.</summary>
    public void Sort()
    {
      this.CheckSortGroupBreakMergedCells();
      this.SortInternal();
    }

    /// <summary>Sorts the specified range of rows.</summary>
    /// <param name="rowIndex">The zero-based index of the first row in the range to sort.</param>
    /// <param name="rowCount">The number of the rows to sort.</param>
    public void Sort(int rowIndex, int rowCount)
    {
      this.CheckRowIndexAndCount(rowIndex, rowCount, nameof (rowCount));
      this.CheckSortGroupBreakMergedCells();
      this.SortInternal();
    }

    /// <summary>Sorts the specified range of rows.</summary>
    /// <param name="rowKey">The string key of the first row in the range to sort.</param>
    /// <param name="rowCount">The number of the rows to sort.</param>
    public void Sort(string rowKey, int rowCount)
    {
      this.Sort(this.RowKeyToIndex(rowKey, true), rowCount);
    }

    private void SortInternal()
    {
      this.OnBeforeContentsSorted(EventArgs.Empty);
      iGSortData[] groupData;
      iGRowNavigatorMapItem[] map;
      this.SortInternalCore(0, this.fRowCount, out groupData, false, out map);
      this.OnAfterContentsSorted(EventArgs.Empty);
      this.ProcessMouseMove();
    }

    private void SortInternalCore(int rowIndex, int rowCount, out iGSortData[] groupData, bool isGrouping, out iGRowNavigatorMapItem[] map)
    {
      this.CancelSearchAsType();
      groupData = (iGSortData[]) null;
      map = (iGRowNavigatorMapItem[]) null;
      if (rowCount <= 0 || (this.fSortObject == null || this.fSortObject.Count == 0) && (this.fLastGroupObject == null || this.fLastGroupObject.Count == 0))
        return;
      iGSortData[] compoundData;
      iGSortObject.GetData(this.fLastGroupObject, this.fSortObject, true, isGrouping, isGrouping, out compoundData, out groupData);
      iGRowNavigatorMapComparer rowNavigatorMapComparer = new iGRowNavigatorMapComparer(this, compoundData, isGrouping);
      if (!this.fSortFrozenRows && rowIndex < this.fFrozenRowCount)
      {
        if (rowIndex + rowCount <= this.fFrozenRowCount)
          return;
        rowCount -= this.fFrozenRowCount - rowIndex;
        rowIndex = this.fFrozenRowCount;
      }
      map = iGRowNavigatorMapItem.FromRowNavigatorArray(this.fRowsMap, rowIndex, rowCount);
      iGRowNavigatorMapItem[] lastMap = (iGRowNavigatorMapItem[]) null;
      iGHierarchicalRowNavigatorComparer hierarchicalRowNavigatorComparer = (iGHierarchicalRowNavigatorComparer) null;
      if (this.fSortByLevels)
      {
        lastMap = new iGRowNavigatorMapItem[rowCount];
        Array.Copy((Array) map, (Array) lastMap, rowCount);
        hierarchicalRowNavigatorComparer = new iGHierarchicalRowNavigatorComparer(rowNavigatorMapComparer);
      }
      if (this.fGroupRowCount > 0 || this.fNotSortableRowCount > 0)
      {
        int num1 = 0;
        int num2 = rowCount - 1;
        iGRowData iGrowData = new iGRowData();
        while (num1 <= num2)
        {
          int num3;
          for (num3 = num1; num3 <= num2; ++num3)
          {
            iGrowData = this.GetRowDataInternal(rowIndex + num3);
            if (iGrowData.Type != iGRowType.Normal || !iGrowData.Sortable)
              break;
          }
          if (num3 - num1 > 1)
          {
            if (this.fSortByLevels)
            {
              int sortedCount;
              this.SortNormalRowsHierarchically(num1, num3 - num1, this.GetRowDataInternal(num1).Level, out sortedCount, map, lastMap, hierarchicalRowNavigatorComparer, rowNavigatorMapComparer);
            }
            else
              Array.Sort<iGRowNavigatorMapItem>(map, num1, num3 - num1, (IComparer<iGRowNavigatorMapItem>) rowNavigatorMapComparer);
          }
          num1 = num3;
          if (iGrowData.Type != iGRowType.Normal || !iGrowData.Sortable)
            ++num1;
        }
      }
      else if (this.fSortByLevels)
      {
        int sortedCount;
        this.SortNormalRowsHierarchically(0, rowCount, this.GetRowDataInternal(rowIndex).Level, out sortedCount, map, lastMap, hierarchicalRowNavigatorComparer, rowNavigatorMapComparer);
      }
      else
        Array.Sort<iGRowNavigatorMapItem>(map, (IComparer<iGRowNavigatorMapItem>) rowNavigatorMapComparer);
      iGRowNavigatorMapItem.SetRowNavigatorArray(map, this.fRowsMap, rowIndex);
      this.fMergedCells.OnSort(map, rowIndex);
      this.fSelectedCells.OnSort(map, rowIndex);
      this.fSelectedRows.OnSort(map, rowIndex);
      this.fLastSelectedInCellModeRowIndex = -1;
      if (this.fRowKeys.SomeKeysDefined())
      {
        for (int index = 0; index < this.fRowCount; ++index)
        {
          string key = this.GetRowDataInternal(index).Key;
          if (iGKeyManager.IsKeySpecified(key))
            this.fRowKeys.SetItemIndexForKey(index, key);
        }
      }
      if (this.fRedraw)
      {
        this.AdjustScrollBars();
        this.NullViewportFirstRowVars();
        this.AdjustViewportFirstRowVars_Plus(0);
        this.Invalidate();
      }
      this.CurCellOnSort(map, rowIndex);
    }

    private void SortNormalRowsHierarchically(int localRowIndex, int localRowCount, int rowLevel, out int sortedCount, iGRowNavigatorMapItem[] curMap, iGRowNavigatorMapItem[] lastMap, iGHierarchicalRowNavigatorComparer hierarchicalRowNavigatorComparer, iGRowNavigatorMapComparer rowNavigatorMapComparer)
    {
      List<iGHierarchicalRowNavigator> nodes = new List<iGHierarchicalRowNavigator>();
      sortedCount = 0;
      bool flag = false;
      int rowIndexBefore = localRowIndex;
      int num;
      for (num = localRowIndex + 1; num < localRowIndex + localRowCount; ++num)
      {
        int level = this.GetRowDataInternal(num).Level;
        if (level > rowLevel)
        {
          int sortedCount1;
          this.SortNormalRowsHierarchically(num, localRowCount - (num - localRowIndex), level, out sortedCount1, curMap, lastMap, hierarchicalRowNavigatorComparer, rowNavigatorMapComparer);
          num += sortedCount1 - 1;
          flag = true;
        }
        else if (level >= rowLevel)
        {
          nodes.Add(new iGHierarchicalRowNavigator(curMap[rowIndexBefore], rowIndexBefore, num - rowIndexBefore - 1));
          rowIndexBefore = num;
        }
        else
          break;
      }
      nodes.Add(new iGHierarchicalRowNavigator(curMap[rowIndexBefore], rowIndexBefore, num - rowIndexBefore - 1));
      if (num - localRowIndex > 1)
      {
        if (flag)
        {
          this.SortNormalRowsHierarchically(nodes, curMap, lastMap, hierarchicalRowNavigatorComparer);
        }
        else
        {
          Array.Sort<iGRowNavigatorMapItem>(curMap, localRowIndex, num - localRowIndex, (IComparer<iGRowNavigatorMapItem>) rowNavigatorMapComparer);
          Array.Copy((Array) curMap, localRowIndex, (Array) lastMap, localRowIndex, num - localRowIndex);
        }
      }
      sortedCount = num - localRowIndex;
    }

    private void SortNormalRowsHierarchically(List<iGHierarchicalRowNavigator> nodes, iGRowNavigatorMapItem[] curMap, iGRowNavigatorMapItem[] lastMap, iGHierarchicalRowNavigatorComparer hierarchicalRowNavigatorComparer)
    {
      if (nodes.Count == 0)
        return;
      int rowIndexBefore = nodes[0].RowIndexBefore;
      int destinationIndex = rowIndexBefore;
      nodes.Sort((IComparer<iGHierarchicalRowNavigator>) hierarchicalRowNavigatorComparer);
      for (int index = 0; index < nodes.Count; ++index)
      {
        Array.Copy((Array) lastMap, nodes[index].RowIndexBefore, (Array) curMap, destinationIndex, nodes[index].Count + 1);
        destinationIndex += nodes[index].Count + 1;
      }
      Array.Copy((Array) curMap, rowIndexBefore, (Array) lastMap, rowIndexBefore, destinationIndex - rowIndexBefore);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomSort" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomSortEventArgs" /> that contains the event data.</param>
    protected internal virtual void OnCustomSort(iGCustomSortEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomSort == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomSort((object) this, e);
    }

    private bool IsColGrouped(int colIndex)
    {
      if (this.fLastGroupObject != null)
        return (uint) this.fLastGroupObject.fParams[colIndex].SortOrder > 0U;
      return false;
    }

    private void AdjustGroupColsWidths(Graphics g)
    {
      if (this.fLastGroupObject == null || this.fGroupColsWidths != null)
        return;
      int groupObjectColCount = this.GetGroupObjectColCount();
      this.fGroupColsWidths = new int[groupObjectColCount];
      int height;
      iGSortData[] groupData;
      IiGControlPaint controlPaint;
      iGIndent controlPaintIndent;
      bool forceNotPaintControl;
      this.GetGroupBoxDrawParams(this.RightToLeft == RightToLeft.Yes, out height, out groupData, out controlPaint, out controlPaintIndent, out forceNotPaintControl);
      for (int index = 0; index < groupObjectColCount; ++index)
      {
        int colIndex = groupData[index].ColIndex;
        iGColData fColData = this.fColDatas[colIndex];
        iGColHdrData fColHdr = this.fColHdrs[colIndex];
        Font uniCellFont = this.GetUniCellFont(iGGridSection.Header, 0, colIndex, (iGStyleBase) fColHdr.Style, (iGStyleBase) null, (iGStyleBase) fColData.ColHdrStyle, iGControlState.Normal, false, false, false, false);
        int num = this.GetUniCellContentsWidth(iGGridSection.Header, g, uniCellFont, height - controlPaintIndent.fTop - controlPaintIndent.fBottom, int.MinValue, fColHdr.Value, (object) null, fColHdr.ImageIndex, 0, colIndex, (iGStyleBase) fColHdr.Style, (iGStyleBase) null, (iGStyleBase) fColData.ColHdrStyle, true) + this.GetSortAreaWidth(g, 0, controlPaint, uniCellFont, fColHdr.Style, fColData.ColHdrStyle, true, false);
        if (!forceNotPaintControl)
          num += controlPaintIndent.fLeft + controlPaintIndent.fRight;
        this.fGroupColsWidths[index] = num;
      }
    }

    private void NullGroupColsWidths()
    {
      this.fGroupColsWidths = (int[]) null;
    }

    /// <summary>Groups according to the <see cref="P:TenTec.Windows.iGridLib.iGrid.GroupObject" />.</summary>
    public void Group()
    {
      if (this.fStaySorted)
        throw new InvalidOperationException("Cannot create group rows in stay sorted mode");
      if (this.IsTreeColSpecified())
        throw new InvalidOperationException("Cannot create group rows when the tree column is different from the first");
      this.CheckSortGroupBreakMergedCells();
      this.OnBeforeContentsGrouped(EventArgs.Empty);
      this.EmptyMouse();
      this.CancelSearchAsType();
      int colRemovedCount;
      int colAddedCount;
      this.AdjustLastGroupObject(out colRemovedCount, out colAddedCount);
      this.NullGroupColsWidths();
      if (this.fRowCount != 0)
      {
        this.RecreateGroupRows();
        if (!this.fCurCell.IsEmpty)
          this.EnsureVisibleRow(this.fCurCell.RowIndex);
      }
      iGAutoHeightEvents @event = iGAutoHeightEvents.OnResizeCol;
      if (colAddedCount > 0)
        @event |= iGAutoHeightEvents.OnShowCol;
      if (colRemovedCount > 0)
        @event |= iGAutoHeightEvents.OnHideCol;
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(0, 0, true, !this.ShallHeaderAutoHeightOnEvent(@event), !this.ShallFooterAutoHeightOnEvent(@event));
      this.AutoHeightHeaderOnEvent(@event, true);
      this.AutoHeightFooterOnEvent(@event, true);
      this.OnAfterContentsGrouped(EventArgs.Empty);
    }

    private void SetGroupObjPropsFromLastGroupObj()
    {
      if (this.fLastGroupObject == null)
        this.GroupObject.Count = 0;
      else
        this.fLastGroupObject.CopyPropertiesTo(this.GroupObject);
    }

    private void AdjustSortObject()
    {
      if (this.fSortObject != null)
        return;
      this.fSortObject = new iGSortObject(this.fColCount, this, false);
    }

    private void AdjustLastGroupObject(out int colRemovedCount, out int colAddedCount)
    {
      colRemovedCount = colAddedCount = 0;
      if (this.fGroupObject == null)
        return;
      this.AdjustSortObject();
      int num = 0;
      bool flag = false;
      for (int colIndex = 0; colIndex < this.fColCount; ++colIndex)
      {
        iGSortOrder iGsortOrder = this.fLastGroupObject != null ? this.fLastGroupObject.fParams[colIndex].SortOrder : iGSortOrder.None;
        if (iGsortOrder != iGSortOrder.None && this.fGroupObject.fParams[colIndex].SortOrder == iGSortOrder.None)
        {
          if (this.IsColVisible(this.fColDatas[colIndex].Visible, this.fColDatas[colIndex].ShowWhenGrouped, colIndex, false) && !this.fColDatas[colIndex].ShowWhenGrouped)
          {
            if (this.fLastVisibleColIndex < 0 || this.GetColOrder(colIndex) > this.GetColOrder(this.fLastVisibleColIndex))
              this.fLastVisibleColIndex = colIndex;
            this.fVisibleColCount = this.fVisibleColCount + 1;
            this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea + this.fColDatas[colIndex].Width;
          }
          this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea - this.fLevelIndent;
          colRemovedCount = colRemovedCount + 1;
          ++num;
        }
        else if (iGsortOrder == iGSortOrder.None && this.fGroupObject.fParams[colIndex].SortOrder != iGSortOrder.None)
        {
          if (this.IsColVisible(this.fColDatas[colIndex].Visible, this.fColDatas[colIndex].ShowWhenGrouped, colIndex, false) && !this.fColDatas[colIndex].ShowWhenGrouped)
          {
            if (colIndex == this.fLastVisibleColIndex)
              flag = true;
            this.fVisibleColCount = this.fVisibleColCount - 1;
            this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea - this.fColDatas[colIndex].Width;
          }
          this.fVisibleColsWidthPlusGroupObjectLevelArea = this.fVisibleColsWidthPlusGroupObjectLevelArea + this.fLevelIndent;
          colAddedCount = colAddedCount + 1;
          ++num;
        }
      }
      if (this.fLastGroupObject == null)
        this.fLastGroupObject = new iGSortObject(this.fColCount, this, true);
      this.fGroupObject.CopyPropertiesTo(this.fLastGroupObject);
      if (flag)
        this.fLastVisibleColIndex = this.GetLastVisibleColIndex();
      if (num <= 0)
        return;
      if (this.fAutoResizeCols)
        this.NullOldColWidths();
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    private void ClearAutoGroupRows()
    {
      for (int rowIndex = 0; rowIndex < this.fRowCount; ++rowIndex)
      {
        if (this.GetRowDataInternal(rowIndex).Type == iGRowType.AutoGroupRow)
        {
          this.RemoveRowRange(rowIndex, 1);
          --rowIndex;
        }
        else
        {
          this.SetRowVisibleParentExpandedInternal(rowIndex, true);
          this.SetRowLevelAndExpandedInternal(rowIndex, 0, true);
        }
      }
    }

    private void CreateAutoGroupRows(iGSortData[] groupData, iGRowNavigatorMapItem[] map)
    {
      if (groupData == null || groupData.Length == 0 || map == null)
        return;
      iGRowPattern rowPattern = new iGRowPattern();
      rowPattern.fRowData.Visible = true;
      rowPattern.fRowData.Type = iGRowType.AutoGroupRow;
      rowPattern.fRowData.Expanded = this.fDefaultAutoGroupRowExpanded;
      rowPattern.fRowData.Height = this.fDefaultAutoGroupRowHeight;
      rowPattern.fRowData.TreeButton = this.fDefaultAutoGroupRowTreeButton;
      int fFrozenRowCount1 = this.fFrozenRowCount;
      int length = groupData.Length;
      int index = 0;
      int initialRowIndex = map[index].InitialRowIndex;
      iGRowNavigator iGrowNavigator1 = new iGRowNavigator();
      iGPage iGpage1 = (iGPage) null;
      bool flag1 = true;
      int groupIndex = 0;
      int fFrozenRowCount2 = this.fFrozenRowCount;
      while (fFrozenRowCount2 < this.fRowCount)
      {
        if (this.GetRowDataInternal(fFrozenRowCount2).Visible)
        {
          bool flag2 = false;
          if (flag1)
          {
            flag2 = true;
            flag1 = false;
            iGrowNavigator1 = this.fRowsMap[fFrozenRowCount2];
            iGpage1 = this.fPages[iGrowNavigator1.PageIndex];
          }
          else
          {
            iGRowNavigator iGrowNavigator2 = iGrowNavigator1;
            iGPage iGpage2 = iGpage1;
            iGrowNavigator1 = this.fRowsMap[fFrozenRowCount2];
            iGpage1 = this.fPages[iGrowNavigator1.PageIndex];
            iGCellStyle cellStyle1 = iGpage1.GetRowData(iGrowNavigator1.RowIndex).CellStyle;
            iGCellStyle cellStyle2 = iGpage2.GetRowData(iGrowNavigator2.RowIndex).CellStyle;
            for (int sortIndex = 0; sortIndex < length; ++sortIndex)
            {
              int colIndex = groupData[sortIndex].ColIndex;
              iGCellData cellData1 = iGpage1.GetCellData(iGrowNavigator1.RowIndex, colIndex);
              iGCellData cellData2 = iGpage2.GetCellData(iGrowNavigator2.RowIndex, colIndex);
              initialRowIndex = map[index].InitialRowIndex;
              if (iGCellsComparer.CompareCells(this, groupData, sortIndex, cellData1, cellData2, cellStyle1, cellStyle2, fFrozenRowCount2, fFrozenRowCount2 - 1, initialRowIndex, map[index - 1].InitialRowIndex, true, true) != 0)
              {
                groupIndex = sortIndex;
                flag2 = true;
                break;
              }
            }
          }
          if (flag2)
          {
            this.InsertAutoGroupRows(fFrozenRowCount2, initialRowIndex, groupIndex, groupData, rowPattern, this.fDefaultAutoGroupRowExpanded);
            fFrozenRowCount2 += length - groupIndex;
          }
        }
        if (!this.fDefaultAutoGroupRowExpanded)
          this.SetRowVisibleParentExpandedInternal(fFrozenRowCount2, false);
        this.SetRowLevelAndExpandedInternal(fFrozenRowCount2, length, this.fDefaultAutoGroupRowExpanded);
        ++fFrozenRowCount2;
        ++index;
      }
    }

    private void InsertAutoGroupRows(int rowBefore, int oldRowIndex, int groupIndex, iGSortData[] groupData, iGRowPattern rowPattern, bool expanded)
    {
      this.AddRowRange(rowBefore, groupData.Length - groupIndex, rowPattern.fRowData, false);
      int index1 = rowBefore + groupData.Length - groupIndex;
      iGRowNavigator fRows1 = this.fRowsMap[index1];
      iGPage fPage1 = this.fPages[fRows1.PageIndex];
      iGCellStyle cellStyle = fPage1.GetRowData(fRows1.RowIndex).CellStyle;
      int colIndex1 = 0;
      for (int index2 = index1 - 1; index2 >= rowBefore; --index2)
      {
        int index3 = index2 - rowBefore + groupIndex;
        iGRowNavigator fRows2 = this.fRowsMap[index2];
        iGPage fPage2 = this.fPages[fRows2.PageIndex];
        iGSortData iGsortData = groupData[index3];
        int colIndex2 = iGsortData.ColIndex;
        iGCellData cellData = fPage1.GetCellData(fRows1.RowIndex, colIndex2);
        iGColData colDataInternal = this.GetColDataInternal(colIndex2);
        fPage2.SetRowLevel(fRows2.RowIndex, index3);
        if (!expanded && index3 > 0)
          this.SetRowVisibleParentExpandedInternal(index2, false);
        iGCellStyle iGcellStyle = index3 >= this.fAutoGroupRowLevelStyles.Length ? this.fAutoGroupRowLevelStyles[this.fAutoGroupRowLevelStyles.Length - 1] : this.fAutoGroupRowLevelStyles[index3];
        string str1;
        if (this.fPrefixGroupValues)
        {
          iGColHdrData fColHdr = this.fColHdrs[colIndex2];
          str1 = this.GetUniCellTextInternal(iGGridSection.Header, 0, colIndex2, fColHdr.Value, fColHdr.AuxValue, fColHdr.ImageIndex, (iGStyleBase) fColHdr.Style, (iGStyleBase) null, (iGStyleBase) colDataInternal.ColHdrStyle);
          if (str1 != null && str1.Length > 0)
            str1 += ": ";
        }
        else
          str1 = string.Empty;
        if (iGsortData.CustomGroupValues != null)
        {
          object customGroupValue = iGsortData.CustomGroupValues[oldRowIndex];
          string str2 = str1;
          if (customGroupValue != null)
            str2 += customGroupValue.ToString();
          fPage2.SetCellValue(fRows2.RowIndex, colIndex1, (object) str2);
        }
        else
        {
          switch (iGsortData.Type)
          {
            case iGSortType.BySelected:
              if ((this.fRowMode ? (this.GetRowSelectedInternal(index1) ? 1 : 0) : (this.GetCellSelectedInternal(index1, colIndex2) ? 1 : 0)) != 0)
              {
                fPage2.SetCellValue(fRows2.RowIndex, colIndex1, (object) (str1 + "Selected"));
                break;
              }
              fPage2.SetCellValue(fRows2.RowIndex, colIndex1, (object) (str1 + "Not Selected"));
              break;
            case iGSortType.Custom:
            case iGSortType.ByValue:
            case iGSortType.ByText:
              fPage2.SetCellValue(fRows2.RowIndex, colIndex1, (object) (str1 + this.GetUniCellTextInternal(iGGridSection.Cells, index1, colIndex2, cellData.Value, cellData.AuxValue, cellData.ImageIndex, (iGStyleBase) cellData.Style, (iGStyleBase) cellStyle, (iGStyleBase) colDataInternal.CellStyle)));
              break;
            case iGSortType.ByBackColor:
              System.Drawing.Color backColorNoSelected = this.GetUniCellBackColorNoSelected(iGGridSection.Cells, index1, colIndex2, (iGStyleBase) cellData.Style, (iGStyleBase) cellStyle, (iGStyleBase) colDataInternal.CellStyle, iGControlState.Normal, false, false, false, false);
              if (iGcellStyle == null)
                iGcellStyle = iGInternalInfrastructure.GetDefaultGroupRowStyle();
              iGcellStyle = iGcellStyle.Clone();
              iGcellStyle.BackColor = backColorNoSelected;
              break;
            case iGSortType.ByFont:
              Font uniCellFont = this.GetUniCellFont(iGGridSection.Cells, index1, colIndex2, (iGStyleBase) cellData.Style, (iGStyleBase) cellStyle, (iGStyleBase) colDataInternal.CellStyle, iGControlState.Normal, false, false, false, false);
              if (iGcellStyle == null)
                iGcellStyle = iGInternalInfrastructure.GetDefaultGroupRowStyle();
              iGcellStyle = iGcellStyle.Clone();
              iGcellStyle.Font = uniCellFont;
              fPage2.SetCellValue(fRows2.RowIndex, colIndex1, (object) uniCellFont.ToString());
              break;
            case iGSortType.ByImageIndex:
              fPage2.SetCellImageIndex(fRows2.RowIndex, colIndex1, this.GetUniCellImageIndexInternal(iGGridSection.Cells, index1, colIndex2, cellData.Value, cellData.AuxValue, cellData.ImageIndex, (iGStyleBase) cellData.Style, (iGStyleBase) cellStyle, (iGStyleBase) colDataInternal.CellStyle));
              break;
            case iGSortType.ByForeColor:
              System.Drawing.Color foreColorNoSelected = this.GetUniCellForeColorNoSelected(iGGridSection.Cells, index1, colIndex2, (iGStyleBase) cellData.Style, (iGStyleBase) cellStyle, (iGStyleBase) colDataInternal.CellStyle, iGControlState.Normal, false, false, false, false);
              if (iGcellStyle == null)
                iGcellStyle = iGInternalInfrastructure.GetDefaultGroupRowStyle();
              iGcellStyle = iGcellStyle.Clone();
              iGcellStyle.ForeColor = foreColorNoSelected;
              fPage2.SetCellValue(fRows2.RowIndex, colIndex1, (object) foreColorNoSelected.ToString());
              break;
            case iGSortType.ByAuxValue:
              fPage2.SetCellValue(fRows2.RowIndex, colIndex1, (object) (str1 + cellData.AuxValue.ToString()));
              break;
            case iGSortType.ByTextNoCase:
              string str3 = this.GetUniCellTextInternal(iGGridSection.Cells, index1, colIndex2, cellData.Value, cellData.AuxValue, cellData.ImageIndex, (iGStyleBase) cellData.Style, (iGStyleBase) cellStyle, (iGStyleBase) colDataInternal.CellStyle);
              if (str3 != null)
                str3 = str3.ToUpper();
              fPage2.SetCellValue(fRows2.RowIndex, colIndex1, (object) (str1 + str3));
              break;
          }
        }
        fPage2.SetCellStyle(fRows2.RowIndex, colIndex1, iGcellStyle);
        this.DoAfterAutoGroupRowCreated(index2, index1, colIndex2);
      }
    }

    private void RecreateGroupRows()
    {
      bool raiseCurCellChanged = false;
      bool raiseCurRowChanged = false;
      bool raiseSelChanged = false;
      bool flag = false;
      this.BeginUpdate();
      try
      {
        if (this.fLastGroupObject != null)
          this.ClearAutoGroupRows();
        iGSortData[] groupData;
        iGRowNavigatorMapItem[] map;
        this.SortInternalCore(0, this.fRowCount, out groupData, true, out map);
        if (this.fLastGroupObject != null)
          this.CreateAutoGroupRows(groupData, map);
        if (this.fLastGroupObject != null && !this.fCurCell.IsEmpty && this.fLastGroupObject.fParams[this.fCurCell.ColIndex].SortOrder != iGSortOrder.None && (!this.fRowMode || this.fRowModeHasCurCell))
          this.SetCurCellNoEvents(iGCellNavigator.Empty, true, true, true, ref raiseCurCellChanged, ref raiseCurRowChanged, ref raiseSelChanged);
        if (!this.fCurCell.IsEmpty && !this.fDefaultAutoGroupRowExpanded | flag)
        {
          int levelAutoGrouRow = this.FindTopLevelAutoGrouRow(this.fCurCell.RowIndex);
          if (levelAutoGrouRow >= 0)
            this.SetCurCellNoEvents(new iGCellNavigator(levelAutoGrouRow, 0), true, true, true, ref raiseCurCellChanged, ref raiseCurRowChanged, ref raiseSelChanged);
        }
        if (raiseSelChanged)
          this.DoSelectionChanged();
        if (raiseCurCellChanged)
          this.DoCurCellChanged();
        if (!raiseCurRowChanged)
          return;
        this.DoCurRowChanged();
      }
      finally
      {
        this.EndUpdate();
      }
    }

    private int FindTopLevelAutoGrouRow(int rowIndex)
    {
      for (int rowIndex1 = rowIndex; rowIndex1 >= 0; --rowIndex1)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
        if (rowDataInternal.Type == iGRowType.AutoGroupRow && rowDataInternal.Level == 0)
          return rowIndex1;
      }
      return -1;
    }

    private void DoDefaultGroupInternal(int colIndex)
    {
      this.SetGroupObjPropsFromLastGroupObj();
      iGSortOrder iGsortOrder = this.fGroupObject.fParams[colIndex].SortOrder != iGSortOrder.Ascending ? iGSortOrder.Ascending : iGSortOrder.Descending;
      this.fGroupObject.fParams[colIndex].SortOrder = iGsortOrder;
      this.Group();
    }

    private bool GetRowBeforeVisibleParentExpanded(int rowIndex, int level)
    {
      if (level == 0)
        return true;
      for (--rowIndex; rowIndex >= 0; --rowIndex)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
        if (rowDataInternal.Visible)
        {
          if (rowDataInternal.Level == level)
            return rowDataInternal.VisibleParentExpanded;
          if (rowDataInternal.Level < level)
            return rowDataInternal.Expanded;
        }
      }
      return true;
    }

    internal void ExpandCollapseRow(int rowIndex, iGRowData rowData, bool expand)
    {
      if (rowData.Expanded == expand)
        return;
      bool adjustScrollBars = false;
      this.SetRowExpandedInternal(rowIndex, expand);
      if (!rowData.VisibleParentExpanded)
        return;
      for (int groupRowIndex = rowIndex + 1; groupRowIndex < this.fRowCount; ++groupRowIndex)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(groupRowIndex);
        if (rowDataInternal.Level > rowData.Level)
        {
          adjustScrollBars = this.SetRowVisibleParentExpandedInternal(groupRowIndex, expand);
          if (!rowDataInternal.Expanded)
            this.SkipRows(ref groupRowIndex, rowDataInternal.Level);
        }
        else
          break;
      }
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(!adjustScrollBars);
      this.RefreshGridAndScrollBarsIfRedraw(adjustScrollBars);
    }

    internal void ExpandCollapseAll(bool expand)
    {
      int val2 = int.MaxValue;
      for (int fFrozenRowCount = this.fFrozenRowCount; fFrozenRowCount < this.fRowCount; ++fFrozenRowCount)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(fFrozenRowCount);
        val2 = Math.Min(rowDataInternal.Level, val2);
        rowDataInternal.Expanded = expand;
        this.SetRowDataNoVisibleHeightTypeSortableChange(fFrozenRowCount, rowDataInternal);
        if (rowDataInternal.Level != val2)
          this.SetRowVisibleParentExpandedInternal(fFrozenRowCount, expand);
      }
      if (this.fAutoResizeCols)
        this.DoAutoResizeCols(false);
      this.RefreshGridAndScrollBarsIfRedraw();
    }

    internal void SkipRows(ref int groupRowIndex, int level)
    {
      groupRowIndex = groupRowIndex + 1;
      while (groupRowIndex < this.fRowCount)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(groupRowIndex);
        if (!rowDataInternal.Visible || rowDataInternal.Level > level)
          groupRowIndex = groupRowIndex + 1;
        else
          break;
      }
      groupRowIndex = groupRowIndex - 1;
    }

    internal void OnGroupBoxHintTextChanged()
    {
      this.InvalidateHeaderIfRedraw();
    }

    private object DoCustomGroupValue(int rowIndex, int colIndex)
    {
      iGCustomGroupValueEventArgs e = new iGCustomGroupValueEventArgs(rowIndex, colIndex - 1);
      this.OnCustomGroupValue(e);
      return e.Value;
    }

    private bool DoBeforeRowStateChanged(int rowIndex, bool expanded)
    {
      iGBeforeRowStateChangedEventArgs e = new iGBeforeRowStateChangedEventArgs(rowIndex, expanded);
      this.OnBeforeRowStateChanged(e);
      return e.DoDefault;
    }

    private void DoAfterRowStateChanged(int rowIndex, bool expanded)
    {
      this.OnAfterRowStateChanged(new iGAfterRowStateChangedEventArgs(rowIndex, expanded));
    }

    private void DoAfterAutoGroupRowCreated(int autoGroupRowIndex, int groupedRowIndex, int groupedColIndex)
    {
      this.OnAfterAutoGroupRowCreated(new iGAfterAutoGroupRowCreatedEventArgs(autoGroupRowIndex, groupedRowIndex, groupedColIndex - 1));
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CustomGroupValue" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCustomGroupValueEventArgs" /> that contains the event data.</param>
    protected virtual void OnCustomGroupValue(iGCustomGroupValueEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CustomGroupValue == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CustomGroupValue((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.BeforeContentsGrouped" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnBeforeContentsGrouped(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.BeforeContentsGrouped == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.BeforeContentsGrouped((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.BeforeContentsSorted" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnBeforeContentsSorted(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.BeforeContentsSorted == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.BeforeContentsSorted((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.AfterContentsGrouped" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnAfterContentsGrouped(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.AfterContentsGrouped == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.AfterContentsGrouped((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.AfterContentsSorted" /> event.</summary>
    /// <param name="e">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
    protected virtual void OnAfterContentsSorted(EventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.AfterContentsSorted == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.AfterContentsSorted((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.BeforeRowStateChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGBeforeRowStateChangedEventArgs" /> that contains the event data.</param>
    protected virtual void OnBeforeRowStateChanged(iGBeforeRowStateChangedEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.BeforeRowStateChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.BeforeRowStateChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.AfterRowStateChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGAfterRowStateChangedEventArgs" /> that contains the event data.</param>
    protected virtual void OnAfterRowStateChanged(iGAfterRowStateChangedEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.AfterRowStateChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.AfterRowStateChanged((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.AfterAutoGroupRowCreated" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGAdjustTreeButtonLocationEventArgs" /> that contains the event data.</param>
    protected virtual void OnAfterAutoGroupRowCreated(iGAfterAutoGroupRowCreatedEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.AfterAutoGroupRowCreated == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.AfterAutoGroupRowCreated((object) this, e);
    }

    internal Rectangle GetCellsAreaBoundsNoRowHdr()
    {
      return this.GetCellsAndRowHeaderAreaBounds(false);
    }

    internal Rectangle GetCellsAreaBoundsNoRowHdr(bool rightToLeft)
    {
      return this.GetCellsAndRowHeaderAreaBounds(false, rightToLeft);
    }

    private Rectangle GetCellsAndRowHeaderAreaBounds(bool includeRowHdr)
    {
      return this.GetCellsAndRowHeaderAreaBounds(includeRowHdr, this.RightToLeft == RightToLeft.Yes);
    }

    private Rectangle GetCellsAndRowHeaderAreaBounds(bool includeRowHdr, bool rightToLeft)
    {
      Rectangle boundsNoRighToLeft = this.GetCellsAndRowHeaderAreaBounds_NoRighToLeft(includeRowHdr);
      if (rightToLeft)
        boundsNoRighToLeft.X = this.Width - boundsNoRighToLeft.X - boundsNoRighToLeft.Width;
      return boundsNoRighToLeft;
    }

    private Rectangle GetCellsAndRowHeaderAreaBounds_NoRighToLeft(bool includeRowHdr)
    {
      int borderSize = this.GetBorderSize();
      int x = !includeRowHdr ? this.GetCellsAreaLeft_NoRightToLeft() : this.GetRowHeaderAreaLeft_NoRighToLeft();
      int headerAreaTopEdge = this.GetCellsAndRowHeaderAreaTopEdge();
      bool hScrollVisible;
      bool vScrollVisible;
      this.GetScrollBarsVisible(out hScrollVisible, out vScrollVisible);
      int vscrollBarWidth = this.GetVScrollBarWidth(vScrollVisible);
      int hscrollBarHeight = this.GetHScrollBarHeight(hScrollVisible);
      return new Rectangle(x, headerAreaTopEdge, this.Width - x - vscrollBarWidth - borderSize, this.Height - headerAreaTopEdge - hscrollBarHeight - borderSize - this.GetFooterAreaHeight());
    }

    private int GetCellsAndRowHeaderAreaTopEdge()
    {
      return this.GetHeaderAreaTop() + this.GetHeaderAreaHeight();
    }

    private int GetCellsAreaLeft_NoRightToLeft()
    {
      return this.GetBorderSize() + this.fRowHeader.EffectiveWidth();
    }

    private Rectangle GetFrozenColsAreaBounds()
    {
      return this.GetFrozenColsAreaBounds(this.RightToLeft == RightToLeft.Yes);
    }

    private Rectangle GetFrozenColsAreaBounds(bool rightToLeft)
    {
      Rectangle boundsNoRightToLeft = this.GetFrozenColsAreaBounds_NoRightToLeft();
      if (rightToLeft)
        boundsNoRightToLeft.X = this.Width - boundsNoRightToLeft.X - boundsNoRightToLeft.Width;
      return boundsNoRightToLeft;
    }

    private Rectangle GetNonFrozenCellsAreaBounds()
    {
      return this.GetNonFrozenCellsAreaBounds(this.RightToLeft == RightToLeft.Yes);
    }

    private Rectangle GetNonFrozenCellsAreaBounds(bool rightToLeft)
    {
      Rectangle boundsNoRightToLeft = this.GetNonFrozenCellsAreaBounds_NoRightToLeft();
      if (rightToLeft)
        boundsNoRightToLeft.X = this.Width - boundsNoRightToLeft.X - boundsNoRightToLeft.Width;
      return boundsNoRightToLeft;
    }

    private Rectangle GetNonFrozenCellsAreaBounds_NoRightToLeft()
    {
      Rectangle boundsNoRighToLeft = this.GetCellsAndRowHeaderAreaBounds_NoRighToLeft(false);
      boundsNoRighToLeft.X += this.fFrozenColsWidth;
      boundsNoRighToLeft.Width -= this.fFrozenColsWidth;
      boundsNoRighToLeft.Y += this.fFrozenRowsHeight;
      boundsNoRighToLeft.Height -= this.fFrozenRowsHeight;
      return boundsNoRighToLeft;
    }

    private Rectangle GetFrozenColsAreaBounds_NoRightToLeft()
    {
      int leftNoRightToLeft = this.GetCellsAreaLeft_NoRightToLeft();
      int headerAreaTopEdge = this.GetCellsAndRowHeaderAreaTopEdge();
      int borderSize = this.GetBorderSize();
      bool hScrollVisible;
      bool vScrollVisible;
      this.GetScrollBarsVisible(out hScrollVisible, out vScrollVisible);
      int hscrollBarHeight = this.GetHScrollBarHeight(hScrollVisible);
      int y = headerAreaTopEdge;
      int fFrozenColsWidth = this.fFrozenColsWidth;
      int height = this.Height - headerAreaTopEdge - hscrollBarHeight - borderSize;
      return new Rectangle(leftNoRightToLeft, y, fFrozenColsWidth, height);
    }

    private bool FindNextSibling(int rowLevel, ref int rowIndex)
    {
      if (rowIndex < this.fFrozenRowCount)
        throw new ArgumentException(nameof (rowIndex));
      int rowIndex1;
      for (rowIndex1 = rowIndex; rowIndex1 < this.fRowCount; ++rowIndex1)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
        if (rowDataInternal.Level == rowLevel)
        {
          rowIndex = rowIndex1;
          return true;
        }
        if (rowDataInternal.Level < rowLevel)
        {
          rowIndex = rowIndex1;
          return false;
        }
      }
      rowIndex = rowIndex1;
      return false;
    }

    private bool FindPrevSibling(int rowLevel, ref int rowIndex)
    {
      if (rowIndex >= this.fRowCount)
        throw new ArgumentException(nameof (rowIndex));
      int rowIndex1;
      for (rowIndex1 = rowIndex; rowIndex1 < this.fRowCount; ++rowIndex1)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
        if (rowDataInternal.Level == rowLevel)
        {
          rowIndex = rowIndex1;
          return true;
        }
        if (rowDataInternal.Level < rowLevel)
        {
          rowIndex = rowIndex1;
          return false;
        }
      }
      rowIndex = rowIndex1;
      return false;
    }

    private bool FindFirstChild(int rowLevel, ref int rowIndex)
    {
      if (rowIndex < this.fFrozenRowCount)
        throw new ArgumentException(nameof (rowIndex));
      int rowIndex1;
      for (rowIndex1 = rowIndex; rowIndex1 < this.fRowCount; ++rowIndex1)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
        if (rowDataInternal.Level == rowLevel + 1)
        {
          rowIndex = rowIndex1;
          return true;
        }
        if (rowDataInternal.Level <= rowLevel)
        {
          rowIndex = rowIndex1;
          return false;
        }
      }
      rowIndex = rowIndex1;
      return false;
    }

    private bool FindParent(int rowLevel, ref int rowIndex)
    {
      if (rowIndex >= this.fRowCount)
        throw new ArgumentException(nameof (rowIndex));
      int rowIndex1;
      for (rowIndex1 = rowIndex; rowIndex1 >= this.fFrozenRowCount; --rowIndex1)
      {
        iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex1);
        if (rowDataInternal.Level == rowLevel - 1)
        {
          rowIndex = rowIndex1;
          return true;
        }
        if (rowDataInternal.Level < rowLevel)
        {
          rowIndex = rowIndex1;
          return false;
        }
      }
      rowIndex = rowIndex1;
      return false;
    }

    internal static void CheckSpanColsValue(int value)
    {
      if (value < 1)
        throw new ArgumentOutOfRangeException(nameof (value), "Value cannot be less than or equal to zero");
    }

    internal static void CheckSpanRowsValue(int value)
    {
      if (value < 1)
        throw new ArgumentOutOfRangeException(nameof (value), "Value cannot be less than or equal to zero");
    }

    private void DoRequestCellElemControlToolTipText(int rowIndex, int colIndex, iGElemControl elemControl, ref string text)
    {
      iGRequestElemControlToolTipTextEventArgs e = new iGRequestElemControlToolTipTextEventArgs(rowIndex, colIndex - 1, elemControl, text);
      this.OnRequestCellElemControlToolTipText(e);
      text = e.Text;
    }

    private void DoRequestColHdrElemControlToolTipText(int rowIndex, int colIndex, iGElemControl elemControl, ref string text)
    {
      iGRequestElemControlToolTipTextEventArgs e = new iGRequestElemControlToolTipTextEventArgs(rowIndex, colIndex - 1, elemControl, text);
      this.OnRequestColHdrElemControlToolTipText(e);
      text = e.Text;
    }

    private void DoRequestCellToolTipText(int rowIndex, int colIndex, ref string text)
    {
      iGRequestCellToolTipTextEventArgs e = new iGRequestCellToolTipTextEventArgs(rowIndex, colIndex - 1, text);
      this.OnRequestCellToolTipText(e);
      text = e.Text;
    }

    private void DoRequestColHdrToolTipText(int rowIndex, int colIndex, iGColHdrKind kind, ref string text)
    {
      iGRequestColHdrToolTipTextEventArgs e = new iGRequestColHdrToolTipTextEventArgs(rowIndex, colIndex - 1, kind, text);
      this.OnRequestColHdrToolTipText(e);
      text = e.Text;
    }

    private void DoRequestFooterCellToolTipText(int rowIndex, int colIndex, iGFooterCellKind kind, ref string text)
    {
      iGRequestFooterCellToolTipTextEventArgs e = new iGRequestFooterCellToolTipTextEventArgs(rowIndex, colIndex - 1, kind, text);
      this.OnRequestFooterCellToolTipText(e);
      text = e.Text;
    }

    private void DoCellDynamicContents(int rowIndex, int colIndex, ref string text, ref int imageIndex, ref CheckState checkState)
    {
      iGCellDynamicContentsEventArgs e = new iGCellDynamicContentsEventArgs(rowIndex, colIndex - 1, text, imageIndex, checkState);
      this.OnCellDynamicContents(e);
      text = e.Text;
      imageIndex = e.ImageIndex;
      checkState = e.CheckState;
    }

    private void DoAdjustTreeButtonLocation(ref int buttonY, int buttonHeight, int placeY, int placeHeight)
    {
      iGAdjustTreeButtonLocationEventArgs e = new iGAdjustTreeButtonLocationEventArgs(buttonY, buttonHeight, placeY, placeHeight);
      this.OnAdjustTreeButtonLocation(e);
      buttonY = e.ButtonY;
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestCellElemControlToolTipText" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestElemControlToolTipTextEventArgs" /> that contains the event data.</param>
    protected virtual void OnRequestCellElemControlToolTipText(iGRequestElemControlToolTipTextEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestCellElemControlToolTipText == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestCellElemControlToolTipText((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestColHdrElemControlToolTipText" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestElemControlToolTipTextEventArgs" /> that contains the event data.</param>
    protected virtual void OnRequestColHdrElemControlToolTipText(iGRequestElemControlToolTipTextEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestColHdrElemControlToolTipText == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestColHdrElemControlToolTipText((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestCellToolTipText" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestCellToolTipTextEventArgs" /> that contains the event data.</param>
    protected virtual void OnRequestCellToolTipText(iGRequestCellToolTipTextEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestCellToolTipText == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestCellToolTipText((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestColHdrToolTipText" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestColHdrToolTipTextEventArgs" /> that contains the event data.</param>
    protected virtual void OnRequestColHdrToolTipText(iGRequestColHdrToolTipTextEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestColHdrToolTipText == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestColHdrToolTipText((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RequestFooterCellToolTipText" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRequestFooterCellToolTipTextEventArgs" /> that contains the event data.</param>
    protected virtual void OnRequestFooterCellToolTipText(iGRequestFooterCellToolTipTextEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RequestFooterCellToolTipText == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RequestFooterCellToolTipText((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.CellDynamicContents" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGCellDynamicContentsEventArgs" /> that contains the event data.</param>
    protected virtual void OnCellDynamicContents(iGCellDynamicContentsEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.CellDynamicContents == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.CellDynamicContents((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.AdjustTreeButtonLocation" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGAfterAutoGroupRowCreatedEventArgs" /> that contains the event data.</param>
    protected virtual void OnAdjustTreeButtonLocation(iGAdjustTreeButtonLocationEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.AdjustTreeButtonLocation == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.AdjustTreeButtonLocation((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColsAdded" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColSetChangeEventArgs" /> that contains the event data.</param>
    protected virtual void OnColsAdded(iGColSetChangeEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColsAdded == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColsAdded((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColsRemoving" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColSetChangeEventArgs" /> that contains the event data.</param>
    protected virtual void OnColsRemoving(iGColSetChangeEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColsRemoving == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColsRemoving((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.ColsRemoved" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGColSetChangeEventArgs" /> that contains the event data.</param>
    protected virtual void OnColsRemoved(iGColSetChangeEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.ColsRemoved == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.ColsRemoved((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowsAdded" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowSetChangeEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowsAdded(iGRowSetChangeEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowsAdded == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowsAdded((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowsRemoving" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowSetChangeEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowsRemoving(iGRowSetChangeEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowsRemoving == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowsRemoving((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowsRemoved" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowSetChangeEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowsRemoved(iGRowSetChangeEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowsRemoved == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowsRemoved((object) this, e);
    }

    /// <summary>Raises the <see cref="E:TenTec.Windows.iGridLib.iGrid.RowVisibleChanged" /> event.</summary>
    /// <param name="e">An <see cref="T:TenTec.Windows.iGridLib.iGRowVisibleChangedEventArgs" /> that contains the event data.</param>
    protected virtual void OnRowVisibleChanged(iGRowVisibleChangedEventArgs e)
    {
      // ISSUE: reference to a compiler-generated field
      if (this.RowVisibleChanged == null)
        return;
      // ISSUE: reference to a compiler-generated field
      this.RowVisibleChanged((object) this, e);
    }

    /// <summary>Gets or sets a <see cref="T:System.Drawing.Text.TextRenderingHint">System.Drawing.Text.TextRenderingHint</see> value specifying the rendering mode for all texts displayed inside iGrid.</summary>
    /// <value>The rendering mode for all texts displayed inside iGrid. The default value is <see cref="F:System.Drawing.Text.TextRenderingHint.SystemDefault" />.</value>
    [DefaultValue(TextRenderingHint.SystemDefault)]
    [Category("Appearance")]
    [Description("Gets or sets the rendering mode for all texts displayed in iGrid.")]
    public TextRenderingHint TextRenderingHint
    {
      get
      {
        return this.fTextRenderingHint;
      }
      set
      {
        this.fTextRenderingHint = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Specifies whether the values of the scroll bars are adjusted after every operation that may affect the positions of the scroll boxes even if iGrid updates are turned off.</summary>
    /// <value>A Boolean value that specifies whether the values of the scroll bars are adjusted after every operation that may affect the positions of the scroll boxes even if iGrid updates are turned off. The default is True.</value>
    [DefaultValue(true)]
    [Category("Behavior")]
    [Description("Specifies whether to change the scroll bar values even if iGrid updates are turned off.")]
    public bool AdjustScrollBarValuesRedrawOff
    {
      get
      {
        return this.fAdjustScrollBarValuesRedrawOff;
      }
      set
      {
        this.fAdjustScrollBarValuesRedrawOff = value;
      }
    }

    /// <summary>Gets or sets the width of the empty area after the last column.</summary>
    /// <value>A non-negative integer value that specifies the width of the empty space after the last column. The default value is 0.</value>
    [DefaultValue(0)]
    [Category("Appearance")]
    [Description("Specifies the size of empty space after the last column.")]
    public int MarginAfterLastCol
    {
      get
      {
        return this.fMarginAfterLastCol;
      }
      set
      {
        if (value < 0)
          throw new ArgumentOutOfRangeException();
        this.fMarginAfterLastCol = value;
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    /// <summary>Gets or sets the height of the empty area after the last row.</summary>
    /// <value>A non-negative integer value that specifies the height of the empty space after the last row. The default value is 0.</value>
    [DefaultValue(0)]
    [Category("Appearance")]
    [Description("Specifies the size of empty space after the last row.")]
    public int MarginAfterLastRow
    {
      get
      {
        return this.fMarginAfterLastRow;
      }
      set
      {
        if (value < 0)
          throw new ArgumentOutOfRangeException();
        this.fMarginAfterLastRow = value;
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    /// <summary>Specifies whether to scroll the grid automatically in the horizontal direction to display the current cell without clipping.</summary>
    /// <value>A Boolean value that specifies whether to scroll the grid automatically in the horizontal direction to display the current cell without clipping.</value>
    [DefaultValue(true)]
    [Category("Behavior")]
    [Description("Specifies whether to scroll the grid automatically in the horizontal direction to fully display the current cell.")]
    public bool EnsureVisibleAutoHScroll
    {
      get
      {
        return this.fEnsureVisibleAutoHScroll;
      }
      set
      {
        this.fEnsureVisibleAutoHScroll = value;
      }
    }

    /// <summary>Specifies whether to scroll the grid automatically in the vertical direction to display the current cell without clipping.</summary>
    /// <value>A Boolean value that specifies whether to scroll the grid automatically in the vertical direction to display the current cell without clipping.</value>
    [DefaultValue(true)]
    [Category("Behavior")]
    [Description("Specifies whether to scroll the grid automatically in the vertical direction to fully display the current cell.")]
    public bool EnsureVisibleAutoVScroll
    {
      get
      {
        return this.fEnsureVisibleAutoVScroll;
      }
      set
      {
        this.fEnsureVisibleAutoVScroll = value;
      }
    }

    /// <summary>Gets or sets a password character which should be used instead of the system one.</summary>
    /// <value>The password character which should be used instead of the system one. The default is the zero-code character which means the system setting is used.</value>
    [DefaultValue('\0')]
    [Category("Behavior")]
    [Description("Gets or sets the custom character used to mask characters of a password.")]
    public char PasswordChar
    {
      get
      {
        return this.fPasswordChar;
      }
      set
      {
        if ((int) this.fPasswordChar == (int) value)
          return;
        this.fPasswordChar = value;
        this.SetPasswordCharEffective();
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets the object which allows you to set up the grid lines.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGGridLines" /> object that allows you to set up the grid lines.</value>
    [Category("Appearance")]
    [Description("Exposes the set of the grid lines’ properties.")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    public iGGridLines GridLines
    {
      get
      {
        if (this.fGridLines == null)
          this.fGridLines = new iGGridLines(this);
        return this.fGridLines;
      }
    }

    /// <summary>Gets the object which allows you to save and restore the grid's columns layout, sort, and group data.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGLayout" /> object that provides you with the layout functionality.</value>
    [Browsable(false)]
    [EditorBrowsable(EditorBrowsableState.Always)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    public iGLayout LayoutObject
    {
      get
      {
        return this.fLayout;
      }
    }

    /// <summary>Gets the bounds of the grid's area excluding the group box, header, border, and scroll bars. The coordinates are relative to the upper left corner of the grid.</summary>
    /// <value>The coordinates of the area intended to display the cells in it.</value>
    [Browsable(false)]
    public Rectangle CellsAreaBounds
    {
      get
      {
        return this.GetCellsAreaBoundsNoRowHdr();
      }
    }

    /// <summary>Gets or sets a value indicating the grid's behavior when the user moves the mouse pointer and the left mouse button is pressed.</summary>
    /// <value>One of the <see cref="T:TenTec.Windows.iGridLib.iGPressedMouseMoveMode" /> values. The default is <see cref="F:TenTec.Windows.iGridLib.iGPressedMouseMoveMode.Selection" />.</value>
    [DefaultValue(iGPressedMouseMoveMode.Selection)]
    [Category("Behavior")]
    [Description("Determines the grid's behavior when the user moves the mouse pointer and the left mouse button is pressed.")]
    public iGPressedMouseMoveMode PressedMouseMoveMode
    {
      get
      {
        return this.fPressedMouseMoveMode;
      }
      set
      {
        this.fPressedMouseMoveMode = value;
      }
    }

    /// <summary>Gets or sets a value indicating whether the row text cells are visible. The row text cells can be visible only in row mode.</summary>
    /// <value>True if the row text cells are visible; otherwise. False. The default is False.</value>
    [DefaultValue(false)]
    [Category("Behavior")]
    [Description("Determines whether the row text cells are visible. The row text cells can be visible only in row mode.")]
    public bool RowTextVisible
    {
      get
      {
        return this.fRowTextVisible;
      }
      set
      {
        if (this.fRowTextVisible == value)
          return;
        if (this.IsRowTextEnabled(this.fRowMode, value) && this.fRowTextStartColNear < this.fFrozenColCount)
          throw new ArgumentException("Frozen area columns edge cannot break row text cells");
        if (this.IsRowTextDisplayed(this.fRowMode, value, this.fRowTextStartColNear, this.fRowTextEndColFar, this.fColCount) && this.WillMergedCellsIntersectRowTexts(this.fRowTextStartColNear, this.fRowTextEndColFar, this.fColIdxFromOrd, int.MaxValue, 0))
          throw new ArgumentException("Row text cells and merged cells cannot overlap");
        bool flag = this.IsRowTextDisplayed();
        this.fRowTextVisible = value;
        if (!this.fRedraw || this.IsRowTextDisplayed() == flag)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the column the row text cell starts at. Its value specifies how many columns should be omitted from the left (or right in right-to-left mode).</summary>
    /// <value>The number of columns to omit from the left (or right in right-to-left mode). The default is 0.</value>
    [Category("Behavior")]
    [DefaultValue(0)]
    [Description("Specifies the column the row text cell starts at. Its value specifies how many columns should be omitted from the left (or right in right-to-left mode).")]
    public int RowTextStartColNear
    {
      get
      {
        return this.fRowTextStartColNear - 1;
      }
      set
      {
        if (value < 0)
          throw new ArgumentOutOfRangeException();
        ++value;
        if (value == this.fRowTextStartColNear)
          return;
        if (this.IsRowTextEnabled() && value < this.fFrozenColCount)
          throw new ArgumentException("Frozen area columns edge cannot break row text cells");
        if (this.IsRowTextDisplayed(this.fRowMode, this.fRowTextVisible, value, this.fRowTextEndColFar, this.fColCount) && this.WillMergedCellsIntersectRowTexts(value, this.fRowTextEndColFar, this.fColIdxFromOrd, int.MaxValue, 0))
          throw new ArgumentException("Row text cells and merged cells cannot overlap");
        this.fRowTextStartColNear = value;
        if (!this.fRedraw || !this.IsRowTextEnabled())
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the column the row text cell ends at. Its value specifies how many columns should be omitted from the right (or left in right-to-left mode).</summary>
    /// <value>The number of columns to omit from the right (or left in right-to-left mode). The default is 0.</value>
    [DefaultValue(0)]
    [Category("Behavior")]
    [Description("Specifies the column the row text cell ends at. Its value specifies how many columns should be omitted from the right (or left in right-to-left mode).")]
    public int RowTextEndColFar
    {
      get
      {
        return this.fRowTextEndColFar;
      }
      set
      {
        if (value < 0)
          throw new ArgumentOutOfRangeException();
        if (value == this.fRowTextEndColFar)
          return;
        if (this.IsRowTextDisplayed(this.fRowMode, this.fRowTextVisible, this.fRowTextStartColNear, value, this.fColCount) && this.WillMergedCellsIntersectRowTexts(this.fRowTextStartColNear, value, this.fColIdxFromOrd, int.MaxValue, 0))
          throw new ArgumentException("Row text cells and merged cells cannot overlap");
        this.fRowTextEndColFar = value;
        if (!this.fRedraw || !this.IsRowTextEnabled())
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the background color of the controls in the cells (the combo buttons and check boxes). If not set, the <see cref="P:System.Windows.Forms.Control.BackColor" /> property of the parent control is used.</summary>
    /// <value>A color. The default is <see cref="F:System.Drawing.Color.Empty" /> which means that the <see cref="P:System.Windows.Forms.Control.BackColor" /> of the parent control is used.</value>
    [Category("Appearance")]
    [Description("The background color of the controls in the cells (the combo buttons and check boxes). If not set, the BackColor property of the parent control is used.")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    public System.Drawing.Color CellCtrlBackColor
    {
      get
      {
        if ((this.fSpecifiedColors & iGSpecifiedColors.CellsBackColor) == iGSpecifiedColors.None)
          return System.Drawing.Color.Empty;
        return this.fCellControlPaintStyle.BackColor;
      }
      set
      {
        if (this.fCellControlPaintStyle.BackColor == value)
          return;
        this.SetCellCtrlBackColorDirect(value);
      }
    }

    /// <summary>Gets or sets the foreground color of the controls in the cells (the arrows in the combo buttons and the ticks in the check boxes). If not set, the <see cref="P:System.Windows.Forms.Control.ForeColor" /> property is used.</summary>
    /// <value>A color. The default is <see cref="F:System.Drawing.Color.Empty" /> which means that the <see cref="P:System.Windows.Forms.Control.ForeColor" /> property is used.</value>
    [Category("Appearance")]
    [Description("The foreground color of the controls in the cells (the arrows in the combo buttons and the ticks in the check boxes). If not set, the ForeColor property is used.")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    public System.Drawing.Color CellCtrlForeColor
    {
      get
      {
        if ((this.fSpecifiedColors & iGSpecifiedColors.CellsForeColor) == iGSpecifiedColors.None)
          return System.Drawing.Color.Empty;
        return this.fCellControlPaintStyle.ForeColor;
      }
      set
      {
        if (this.fCellControlPaintStyle.ForeColor == value)
          return;
        this.SetCellCtrlForeColorDirect(value);
      }
    }

    /// <summary>Gets or sets a value indicating whether to use the OS visual styles if they are available to display the controls in the cells (the combo buttons, check boxes, and ellipsis buttons).</summary>
    /// <value>True if the OS visual styles are used; otherwise, False. The default is True.</value>
    [Category("Appearance")]
    [DefaultValue(true)]
    [Description("Determines whether to use the Windows visual styles if they are available to dispalay the controls in the cells (the combo buttons and check boxes).")]
    public bool UseXPStyles
    {
      get
      {
        return this.fCellControlPaintStyle.UseXP;
      }
      set
      {
        if (this.fCellControlPaintStyle.UseXP == value)
          return;
        this.fCellControlPaintStyle.UseXP = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the style of the controls in the cells (the combo buttons and check boxes).</summary>
    /// <value>One of the <see cref="T:TenTec.Windows.iGridLib.iGControlPaintAppearance" /> enumeration values. The default is <see cref="F:TenTec.Windows.iGridLib.iGControlPaintAppearance.Style3D" />.</value>
    [Category("Appearance")]
    [DefaultValue(iGControlPaintAppearance.Style3D)]
    [Description("The style of the controls in the cells (the combo buttons and check boxes).")]
    public iGControlPaintAppearance Appearance
    {
      get
      {
        return this.fCellControlPaintStyle.Appearance;
      }
      set
      {
        if (this.fCellControlPaintStyle.Appearance == value)
          return;
        this.fCellControlPaintStyle.Appearance = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>This member overrides <see cref="P:System.Windows.Forms.Control.Text" />.</summary>
    /// <value>The text associated with this control.</value>
    [Browsable(false)]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public new string Text
    {
      get
      {
        return base.Text;
      }
      set
      {
        base.Text = value;
      }
    }

    /// <summary>Gets or sets the background color of the cells area.</summary>
    /// <value>The background color of the cells area. The default is <see cref="P:System.Drawing.SystemColors.Window" />.</value>
    public override System.Drawing.Color BackColor
    {
      get
      {
        return base.BackColor;
      }
      set
      {
        this.SetStyle(ControlStyles.SupportsTransparentBackColor, (int) value.A != (int) byte.MaxValue);
        base.BackColor = value;
      }
    }

    /// <summary>Gets or sets the foreground color of the cells area.</summary>
    /// <value>The foreground color of the cells area. The default is <see cref="P:System.Drawing.SystemColors.WindowText" />.</value>
    public override System.Drawing.Color ForeColor
    {
      get
      {
        return base.ForeColor;
      }
      set
      {
        base.ForeColor = value;
      }
    }

    /// <summary>Gets or sets the color of the <see cref="F:TenTec.Windows.iGridLib.iGBorderStyle.Flat" /> and <see cref="F:TenTec.Windows.iGridLib.iGBorderStyle.Standard" /> borders.</summary>
    /// <value>A color. The default is <see cref="P:System.Drawing.SystemColors.ControlDark" />.</value>
    [Category("Appearance")]
    [Description("The color of the Flat and Standard border.")]
    public System.Drawing.Color BorderColor
    {
      get
      {
        return this.fBorderColor;
      }
      set
      {
        if (this.fBorderColor == value)
          return;
        this.fBorderColor = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the style of the border.</summary>
    /// <value>One of the <see cref="T:TenTec.Windows.iGridLib.iGBorderStyle" /> enumeration members. The default is <see cref="F:TenTec.Windows.iGridLib.iGBorderStyle.System" />.</value>
    [DefaultValue(iGBorderStyle.System)]
    [Category("Appearance")]
    [Description("The style of the border.")]
    public iGBorderStyle BorderStyle
    {
      get
      {
        return this.fBorderStyle;
      }
      set
      {
        if (this.fBorderStyle == value)
          return;
        this.fBorderStyle = value;
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    /// <summary>Gets or sets the width of the <see cref="F:TenTec.Windows.iGridLib.iGBorderStyle.Flat" /> border.</summary>
    /// <value>The width of the grid's border. The default is 1.</value>
    [DefaultValue(1)]
    [Category("Appearance")]
    [Description("The width of the Flat border.")]
    public int BorderWidth
    {
      get
      {
        return this.fBorderWidth;
      }
      set
      {
        if (value <= 0)
          throw new ArgumentOutOfRangeException();
        if (this.fBorderWidth == value)
          return;
        this.fBorderWidth = value;
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    protected override Size DefaultSize
    {
      get
      {
        return iGrid.cDefaultSize;
      }
    }

    /// <summary>Gets or sets the images to display in the cells.</summary>
    /// <value>An image list used to display images in the grid.</value>
    [Category("Appearance")]
    [DefaultValue(null)]
    [Description("The images to display in the cells.")]
    public ImageList ImageList
    {
      get
      {
        return this.fImageList;
      }
      set
      {
        if (this.fImageList == value)
          return;
        this.fImageList = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>The color of the text displayed in the disabled cells.</summary>
    /// <value>A color.</value>
    [Category("Appearance")]
    [Description("The color of the text displayed in the disabled cells.")]
    public System.Drawing.Color ForeColorDisabled
    {
      get
      {
        return this.fForeColorDisabled;
      }
      set
      {
        if (this.fForeColorDisabled == value)
          return;
        this.fForeColorDisabled = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the background color of the cells in the even rows.</summary>
    /// <value>A color. The default is <see cref="F:System.Drawing.Color.Empty" /> which means that the <see cref="P:TenTec.Windows.iGridLib.iGrid.BackColor" /> of the grid is used.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The background color of the cells in the even rows.")]
    public System.Drawing.Color BackColorEvenRows
    {
      get
      {
        return this.fBackColorEvenRows;
      }
      set
      {
        if (this.fBackColorEvenRows == value)
          return;
        this.fBackColorEvenRows = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the background color of the cells in the odd rows.</summary>
    /// <value>A color. The default is <see cref="F:System.Drawing.Color.Empty" /> which means that the <see cref="P:TenTec.Windows.iGridLib.iGrid.BackColor" /> of the grid is used.</value>
    [Category("Appearance")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColorEmptyAsNotSetConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The background color of the cells in the odd rows.")]
    public System.Drawing.Color BackColorOddRows
    {
      get
      {
        return this.fBackColorOddRows;
      }
      set
      {
        if (this.fBackColorOddRows == value)
          return;
        this.fBackColorOddRows = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets the cursor that is displayed when the mouse pointer is over the grid.</summary>
    /// <value>A <see cref="T:System.Windows.Forms.Cursor" /> object that represents the cursor to display when the mouse pointer is over the control.</value>
    public override Cursor Cursor
    {
      get
      {
        if (this.fCursor == (Cursor) null)
          return base.Cursor;
        return this.fCursor;
      }
      set
      {
        base.Cursor = value;
      }
    }

    /// <summary>Gets or sets a value indicating whether a column should be resized immediately as the user is dragging the edge of the column's header.</summary>
    /// <value>True if the columns should be resized immediately; otherwise, False.</value>
    [Category("Behavior")]
    [DefaultValue(true)]
    [Description("Determines whether a column should be resized immediately as the user is dragging the edge of the column's header.")]
    public bool ImmediateColResizing
    {
      get
      {
        return this.fImmediateColResizing;
      }
      set
      {
        this.fImmediateColResizing = value;
      }
    }

    /// <summary>Gets or sets a value indicating whether the combo and ellipsis buttons are displayed only in the current cell or in all the cells.</summary>
    /// <value>True if controls are shows in all the cells; otherwise, False. The default is True.</value>
    [Category("Appearance")]
    [DefaultValue(true)]
    [Description("Determines whether the combo button is displayed only in the current cell or in all the cells with the Combo style.")]
    public bool ShowControlsInAllCells
    {
      get
      {
        return this.fShowControlsInAllCells;
      }
      set
      {
        if (value == this.fShowControlsInAllCells)
          return;
        this.fShowControlsInAllCells = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    internal iGPenStyle FrozenRowsSeparatingLine
    {
      get
      {
        return this.fFrozenRowsSeparatingLineStyle;
      }
      set
      {
        if (value == null)
          throw new ArgumentNullException();
        this.fFrozenRowsSeparatingLineStyle = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    internal iGPenStyle FrozenColsSeparatingLine
    {
      get
      {
        return this.fFrozenColsSeparatingLineStyle;
      }
      set
      {
        if (value == null)
          throw new ArgumentNullException();
        this.fFrozenColsSeparatingLineStyle = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets a value determining whether the cells, column headers, and scroll bar elements indicate hot state.</summary>
    /// <value>True if the controls indicate their hot state; otherwise, False.</value>
    [DefaultValue(true)]
    [Description("Determines whether the cells, column headers, and scroll bar elements indicate hot state.")]
    [Category("Appearance")]
    public bool HotTracking
    {
      get
      {
        return this.fHotTracking;
      }
      set
      {
        this.fHotTracking = value;
        this.fHScrollBar.HotTracking = value;
        this.fVScrollBar.HotTracking = value;
      }
    }

    /// <summary>Gets or sets the image to be drawn on the ellipsis buttons. If not specified, an ellipsis will be drawn.</summary>
    /// <value>The image that is displayed in all the ellipsis buttons in the grid. The default is null (Noting in VB) that means that the ellipsis buttons display the standard ellipsis image.</value>
    [DefaultValue(null)]
    [Description("Determines the image to be drawn on the ellipsis buttons. If not specified an ellipsis will be drawn.")]
    [Category("Appearance")]
    public Image EllipsisButtonGlyph
    {
      get
      {
        return this.fEllipsisButtonGlyph;
      }
      set
      {
        this.fEllipsisButtonGlyph = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    internal bool DoNotFocusOnMouseDown
    {
      get
      {
        return this.fDoNotFocusOnMouseDown;
      }
      set
      {
        this.fDoNotFocusOnMouseDown = value;
        this.fVScrollBar.DoNotFocusOnMouseDown = value;
        this.fHScrollBar.DoNotFocusOnMouseDown = value;
      }
    }

    /// <summary>Gets or sets the distance the mouse pointer should be moved to start the drag-and-drop operation.</summary>
    /// <value>An integer value.</value>
    [DefaultValue(4)]
    [Description("Determines the distance the mouse pointer should be moved to start the drag-and-drop operation.")]
    [Category("Behavior")]
    public int StartDragCellDelta
    {
      get
      {
        return this.fStartDragCellDelta;
      }
      set
      {
        this.fStartDragCellDelta = value;
      }
    }

    /// <summary>Gets the object which provides you with the properties which allow you to set and get the standard user interface strings.</summary>
    /// <value>An instance of the <see cref="T:TenTec.Windows.iGridLib.iGUIStrings" /> class.</value>
    [Description("Allows you to specify standard strings used in iGrid user interface.")]
    [Category("Misc")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Localizable(true)]
    public iGUIStrings UIStrings
    {
      get
      {
        return this.fUIStrings;
      }
    }

    /// <summary>Gets the object which allows you to set up the frozen rows and columns.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGFrozenArea" /> object that allows to adjust the frozen area.</value>
    [Category("iGrid Areas")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [Description("The set of properties which allow you to set up the frozen rows and columns.")]
    public iGFrozenArea FrozenArea
    {
      get
      {
        if (this.fFrozenArea == null)
          this.fFrozenArea = new iGFrozenArea(this);
        return this.fFrozenArea;
      }
    }

    internal int FrozenRowCount
    {
      get
      {
        return this.fFrozenRowCount;
      }
      set
      {
        if (value < 0)
          throw new ArgumentOutOfRangeException(nameof (value), "Value cannot be negative");
        if (this.fFrozenRowCount == value)
          return;
        if (0 < value && value < this.fRowCount && !this.CanSeparateRows(value))
          throw new ArgumentException("Frozen area edge cannot break merged cells");
        int num1 = value - this.fFrozenRowCount;
        this.fFrozenRowCount = value;
        if (this.IsScrollableVert())
        {
          if (this.fViewportFirstRowIndex < this.fFrozenRowCount)
          {
            this.NullViewportFirstRowVars();
            this.NullVScrollBar();
          }
          else if (num1 > 0)
          {
            int rowIndex = this.fFrozenRowCount - 1;
            for (; num1 > 0; --num1)
            {
              iGRowData rowDataInternal = this.GetRowDataInternal(rowIndex);
              if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
                this.fViewportFirstRowHiddenHeight = this.fViewportFirstRowHiddenHeight + rowDataInternal.Height;
              --rowIndex;
            }
            this.AdjustViewportFirstRowVars_Plus(this.fVScrollBar.Value - this.fViewportFirstRowHiddenHeight);
          }
          else
          {
            int num2 = num1;
            int fFrozenRowCount = this.fFrozenRowCount;
            for (; num2 < 0; ++num2)
            {
              iGRowData rowDataInternal = this.GetRowDataInternal(fFrozenRowCount);
              if (this.IsRowVisibleInternal(rowDataInternal.Visible, rowDataInternal.VisibleParentExpanded))
                this.fViewportFirstRowHiddenHeight = this.fViewportFirstRowHiddenHeight - rowDataInternal.Height;
              ++fFrozenRowCount;
            }
            this.AdjustViewportFirstRowVars_Minus(this.fVScrollBar.Value - this.fViewportFirstRowHiddenHeight);
          }
        }
        if (num1 < 0 && this.fStaySorted && !this.fSortFrozenRows)
          this.AdjustRowsToStaySorted(this.fFrozenRowCount, this.fFrozenRowCount - num1 - 1);
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    internal int FrozenColCount
    {
      get
      {
        return this.fFrozenColCount - 1;
      }
      set
      {
        if (value < 0)
          throw new ArgumentOutOfRangeException(nameof (value), "Value cannot be negative");
        ++value;
        if (this.fFrozenColCount == value)
          return;
        if (this.IsRowTextEnabled() && this.fRowTextStartColNear < value)
          throw new ArgumentException("Frozen area columns edge cannot break row text cells");
        if (value > 1 && value < this.fColCount && !this.CanSeparateCols(this.fColIdxFromOrd[value - 1], this.fColIdxFromOrd[value], (bool[]) null))
          throw new ArgumentException("Frozen area edge cannot break merged cells");
        this.fFrozenColCount = value;
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    /// <summary>Gets the object representing the common parameters for the vertical and horizontal scroll bars.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGScrollBarSettings" /> object that represents the scroll bars' settings.</value>
    [Category("iGrid Areas")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Description("The common parameters for the both vertical and horizontal scroll bars.")]
    public iGScrollBarSettings ScrollBarSettings
    {
      get
      {
        if (this.fScrollBarSettings == null)
          this.fScrollBarSettings = new iGScrollBarSettings(this);
        return this.fScrollBarSettings;
      }
    }

    /// <summary>Gets the object which allows you to set up the vertical scroll bar.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGScrollBar" /> object that represents the vertical scroll bar.</value>
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Category("iGrid Areas")]
    [Description("The set of the properties which allow you to set up the vertical scroll bar.")]
    public iGScrollBar VScrollBar
    {
      get
      {
        if (this.fVScrollObject == null)
          this.fVScrollObject = new iGScrollBar(this, true);
        return this.fVScrollObject;
      }
    }

    /// <summary>Gets the object which allows you to set up the horizontal scroll bar.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGScrollBar" /> object that represents the horizontal scroll bar.</value>
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Category("iGrid Areas")]
    [Description("The set of the properties which allow you to set up the horizontal scroll bar.")]
    public iGScrollBar HScrollBar
    {
      get
      {
        if (this.fHScrollObject == null)
          this.fHScrollObject = new iGScrollBar(this, false);
        return this.fHScrollObject;
      }
    }

    internal bool SortFrozenRows
    {
      get
      {
        return this.fSortFrozenRows;
      }
      set
      {
        if (this.fSortFrozenRows == value)
          return;
        this.fSortFrozenRows = value;
        if (!this.fStaySorted || !this.fSortFrozenRows)
          return;
        if (this.fRowCount > this.fFrozenRowCount)
        {
          this.AdjustRowsToStaySorted(0, this.fFrozenRowCount - 1);
          this.RefreshGridAndScrollBarsIfRedraw();
        }
        else
          this.Sort();
      }
    }

    private void AdjustRowsToStaySorted(int rowIndexStart, int rowIndexEnd)
    {
      iGCellData[] cells = new iGCellData[this.fColCount];
      for (int index = rowIndexEnd; index >= rowIndexStart; --index)
      {
        this.GetRowCells(index, cells);
        iGRowData rowDataInternal = this.GetRowDataInternal(index);
        int rowBeforeToInsert = this.GetRowBeforeToInsert(rowDataInternal.Type, rowDataInternal.CellStyle, cells, index, index + 1, false);
        if (rowBeforeToInsert != index)
          this.MoveRowsInternal(index, 1, rowBeforeToInsert - 1, false);
      }
    }

    /// <summary>Gets or sets a value indicating whether a row changes its index according to the <see cref="P:TenTec.Windows.iGridLib.iGrid.SortObject" /> when the <see cref="P:TenTec.Windows.iGridLib.iGCell.Value" /> or other meaningful property of a cell in this row is changed.</summary>
    /// <value>True if the grid is in the stay-sorted mode; otherwise, False.</value>
    [Category("Behavior")]
    [DefaultValue(false)]
    [Description("Determines whether a row changes its index according to the SortObject when the Value or other meaningful property of a cell in this row is changed.")]
    public bool StaySorted
    {
      get
      {
        return this.fStaySorted;
      }
      set
      {
        if (this.fStaySorted == value)
          return;
        if (value)
        {
          if (this.fGroupRowCount > 0)
            throw new Exception("This mode is not available if the grid contains group rows");
          if (this.fSortByLevels)
            throw new Exception("Stay sorted mode is not compatible with hierarchical sort");
        }
        this.fStaySorted = value;
        if (!value)
          return;
        this.Sort();
      }
    }

    /// <summary>This property is used to specify what column of iGrid will display the tree.</summary>
    /// <value>An <see cref="T:TenTec.Windows.iGridLib.iGCol" /> instance that represents the column which displays the tree. The default is a null reference (Nothing in VB) that means the tree is displayed in the very first visible column of iGrid.NET.</value>
    [Category("Behavior")]
    [Description("The column which the tree buttons and branches are displayed in.")]
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGColListConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Visible)]
    public iGCol TreeCol
    {
      get
      {
        if (!this.IsTreeColSpecified())
          return (iGCol) null;
        return new iGCol(this, this.fTreeColIndex);
      }
      set
      {
        int colOrderOrIndex;
        if (value == null)
        {
          colOrderOrIndex = -1;
        }
        else
        {
          colOrderOrIndex = value.fIndex;
          if (this.IsExtraCol(colOrderOrIndex))
            throw new ArgumentException("The row text column cannot contain tree");
        }
        if (this.fTreeColIndex == colOrderOrIndex)
          return;
        if (colOrderOrIndex != -1 && this.fGroupRowCount > 0)
          throw new Exception("This mode is not available if the grid contains group rows");
        this.fTreeColIndex = colOrderOrIndex;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets the collection of the objects used to define the sort criteria.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGSortObject" /> object that stores the sorting criteria of the grid.</value>
    [Browsable(false)]
    public iGSortObject SortObject
    {
      get
      {
        this.AdjustSortObject();
        return this.fSortObject;
      }
    }

    /// <summary>Gets the collection of the objects used to define the grouping criteria.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGSortObject" /> that stores the group criteria.</value>
    [Browsable(false)]
    public iGSortObject GroupObject
    {
      get
      {
        if (this.fGroupObject == null)
          this.fGroupObject = new iGSortObject(this.fColCount, this, true);
        return this.fGroupObject;
      }
    }

    internal bool GroupBoxVisible
    {
      get
      {
        return this.fGroupBoxVisible;
      }
      set
      {
        if (this.fGroupBoxVisible == value)
          return;
        this.fGroupBoxVisible = value;
        if (this.fAutoResizeCols)
          this.DoAutoResizeCols(0, 0, false, true, true);
        this.RefreshGridAndScrollBarsIfRedraw();
      }
    }

    /// <summary>Gets the object which allows you to set up the group box.</summary>
    /// <value>The <see cref="T:TenTec.Windows.iGridLib.iGGroupBox" /> object that represents the group box.</value>
    [TypeConverter("TenTec.Windows.iGridLib.Design.iGExpandableTypeConverter, TenTec.Windows.iGridLib.iGrid.Design.v6.0, Version=6.0.37.0")]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [Category("iGrid Areas")]
    [Description("The set of properties which allow you to set up the group box.")]
    public iGGroupBox GroupBox
    {
      get
      {
        if (this.fGroupBoxObject == null)
          this.fGroupBoxObject = new iGGroupBox(this);
        return this.fGroupBoxObject;
      }
    }

    /// <summary>Gets or sets a value indicating whether to scroll the group rows horizontally.</summary>
    /// <value>True if the group rows are scrolled; otherwise, False. The default is False.</value>
    [Category("Behavior")]
    [DefaultValue(false)]
    [Description("Determines whether to scroll the group rows horizontally.")]
    public bool ScrollGroupRows
    {
      get
      {
        return this.fScrollGroupRows;
      }
      set
      {
        if (this.fScrollGroupRows == value)
          return;
        this.fScrollGroupRows = value;
        if (!this.fRedraw)
          return;
        this.Invalidate();
      }
    }

    /// <summary>Gets or sets a value indicating whether to take into account row levels when sorting.</summary>
    /// <value>True if the row level is taken into account when sorting; otherwise, False. The default is False.</value>
    [DefaultValue(false)]
    [Category("Behavior")]
    [Description("Determines whether to take into account row levels when sorting.")]
    public bool SortByLevels
    {
      get
      {
        return this.fSortByLevels;
      }
      set
      {
        if (this.fStaySorted)
          throw new Exception("Cannot sort hierarchically in stay sorted mode");
        this.fSortByLevels = value;
      }
    }

    /// <summary>Gets or sets a value indicating whether to include a column name in the text of the automatically created group rows if possible.</summary>
    /// <value>True if the column name is included in the automatically created group rows; otherwise, False. The default is True.</value>
    [DefaultValue(true)]
    [Category("Behavior")]
    [Description("Determines whether to include a column name in the text of the automatically created group rows if possible.")]
    public bool PrefixGroupValues
    {
      get
      {
        return this.fPrefixGroupValues;
      }
      set
      {
        this.fPrefixGroupValues = value;
      }
    }

    /// <summary>Gets or sets a value indicating whether to take into account the header and/or cells of the column when adjusting its width.</summary>
    /// <value>One of <see cref="T:TenTec.Windows.iGridLib.iGAutoWidthColMode" /> enumeration values. The default is <see cref="F:TenTec.Windows.iGridLib.iGAutoWidthColMode.HeaderAndCells" />.</value>
    [Category("Behavior")]
    [DefaultValue(iGAutoWidthColMode.HeaderAndCells)]
    [Description("Determines whether to take into account the header and/or cells of the column when adjusting its width.")]
    public iGAutoWidthColMode AutoWidthColMode
    {
      get
      {
        return this.fAutoWidthColMode;
      }
      set
      {
        this.fAutoWidthColMode = value;
      }
    }

    /// <summary>Gets or sets a value indicating whether to keep the width of all the columns equal to the width of the grid's client area.</summary>
    /// <value>True if the auto resizing mode is on; otherwise, False. The default is False.</value>
    [DefaultValue(false)]
    [Category("Behavior")]
    [Description("Determines whether to keep the width of all the columns equal to the width of the grid's client area.")]
    public bool AutoResizeCols
    {
      get
      {
        return this.fAutoResizeCols;
      }
      set
      {
        if (this.fAutoResizeCols == value)
          return;
        this.fAutoResizeCols = value;
        if (!this.fAutoResizeCols)
          return;
        this.NullOldColWidths();
        this.DoAutoResizeCols(true);
      }
    }

    /// <summary>Gets or sets a value indicating whether to take into account a row's header and/or cells when automatically when adjusting its height.</summary>
    /// <value>One of the <see cref="T:TenTec.Windows.iGridLib.iGAutoHeightRowMode" /> enumeration values.</value>
    [Category("Behavior")]
    [DefaultValue(iGAutoHeightRowMode.RowHdrAndCells)]
    [Description("Determines whether to take into account the row header and/or cells of a row when adjusting its height.")]
    public iGAutoHeightRowMode AutoHeightRowMode
    {
      get
      {
        return this.fAutoHeightRowMode;
      }
      set
      {
        this.fAutoHeightRowMode = value;
      }
    }

    /// <summary>Occurs before a tree button is drawn, and allows you to modify its position.</summary>
    [Category("Appearance")]
    [Description("Occurs when the grid is determining a tree button's Y-coordinate. Allows you to customize the Y-coordinate.")]
    public event iGAdjustTreeButtonLocationEventHandler AdjustTreeButtonLocation;

    /// <summary>Occurs when the width of the vertical scroll bar is changed.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the width of the vertical scroll bar is changed.")]
    public event EventHandler VScrollBarWidthChanged;

    /// <summary>Occurs when the height of the horizontal scroll bar is changed.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the height of the horizontal scroll bar is changed.")]
    public event EventHandler HScrollBarHeightChanged;

    /// <summary>Occurs when the vertical scroll bar is shown or hided.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the vertical scroll bar is shown or hided.")]
    public event EventHandler VScrollBarVisibleChanged;

    /// <summary>Occurs when the horizontal scroll bar is shown or hided.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the horizontal scroll bar is shown or hided.")]
    public event EventHandler HScrollBarVisibleChanged;

    /// <summary>Occurs when the scroll box of the vertical scroll bar has been moved by a mouse action.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the scroll box of the vertical scroll bar has been moved by either a mouse or keyboard action.")]
    public event iGScrollEventHandler VScrollBarScroll;

    /// <summary>Occurs when the scroll box of the horizontal scroll bar has been moved by a mouse action.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the scroll box of the horizontal scroll bar has been moved by either a mouse or keyboard action.")]
    public event iGScrollEventHandler HScrollBarScroll;

    /// <summary>Occurs when the <see cref="P:TenTec.Windows.iGridLib.iGScrollBar.Value" /> property of the vertical scroll bar is about to be changed by the user or programmatically.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the Value property of the vertical scroll bar is about to change, either by the user or programmatically.")]
    public event iGScrollBarValueChangingEventHandler VScrollBarValueChanging;

    /// <summary>Occurs when the <see cref="P:TenTec.Windows.iGridLib.iGScrollBar.Value" /> property of the horizontal scroll bar is about to be changed by the user or programmatically.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the Value property of the horizontal scroll bar is about to change, either by the user or programmatically.")]
    public event iGScrollBarValueChangingEventHandler HScrollBarValueChanging;

    /// <summary>Occurs when the <see cref="P:TenTec.Windows.iGridLib.iGScrollBar.Value" /> property of the vertical scroll bar is about to be changed, either by the user or programmatically.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the Value property of the vertical scroll bar has changed, either by the user or programmatically.")]
    public event EventHandler VScrollBarValueChanged;

    /// <summary>Occurs when the <see cref="P:TenTec.Windows.iGridLib.iGScrollBar.Value" /> property of the horizontal scroll bar has been changed, either by the user or programmatically.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the Value property of the horizontal scroll bar has changed, either by the user or programmatically.")]
    public event EventHandler HScrollBarValueChanged;

    /// <summary>Occurs when the foreground of a custom button of the vertical scroll bar is redrawn.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the foreground of a custom button of the vertical scroll bar is redrawn.")]
    public event iGScrollBarCustomButtonDrawEventHandler VScrollBarCustomButtonDrawForeground;

    /// <summary>Occurs when the background of a custom button of the vertical scroll bar is redrawn.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the background of a custom button of the vertical scroll bar is redrawn.")]
    public event iGScrollBarCustomButtonDrawEventHandler VScrollBarCustomButtonDrawBackground;

    /// <summary>Occurs when the mouse pointer is over a custom button of the vertical scroll bar and a mouse button is pressed.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer is over a custom button of the vertical scroll bar and a mouse button is pressed.")]
    public event iGScrollBarCustomButtonMouseDownUpEventHandler VScrollBarCustomButtonMouseDown;

    /// <summary>Occurs when the mouse pointer is over a custom button of the vertical scroll bar and a mouse button is released.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer is over a custom button of the vertical scroll bar and a mouse button is released.")]
    public event iGScrollBarCustomButtonMouseDownUpEventHandler VScrollBarCustomButtonMouseUp;

    /// <summary>Occurs when the mouse pointer enters a custom button of the vertical scroll bar.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer enters a custom button of the vertical scroll bar.")]
    public event iGScrollBarCustomButtonMouseEnterLeaveEventHandler VScrollBarCustomButtonMouseEnter;

    /// <summary>Occurs when the mouse pointer leaves a custom button of the vertical scroll bar.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer leaves a custom button of the vertical scroll bar.")]
    public event iGScrollBarCustomButtonMouseEnterLeaveEventHandler VScrollBarCustomButtonMouseLeave;

    /// <summary>Occurs when the mouse pointer moves over a custom button of the vertical scroll bar.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer moves over a custom button of the vertical scroll bar.")]
    public event iGScrollBarCustomButtonMouseMoveEventHandler VScrollBarCustomButtonMouseMove;

    /// <summary>Occurs when a custom button of the vertical scroll bar is clicked.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when a custom button of the vertical scroll bar is clicked.")]
    public event iGScrollBarCustomButtonClickEventHandler VScrollBarCustomButtonClick;

    /// <summary>Occurs when the foreground of a custom button of the horizontal scroll bar is redrawn.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the foreground of a custom button of the horizontal scroll bar is redrawn.")]
    public event iGScrollBarCustomButtonDrawEventHandler HScrollBarCustomButtonDrawForeground;

    /// <summary>Occurs when the background of a custom button of the horizontal scroll bar is redrawn.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the background of a custom button of the horizontal scroll bar is redrawn.")]
    public event iGScrollBarCustomButtonDrawEventHandler HScrollBarCustomButtonDrawBackground;

    /// <summary>Occurs when the mouse pointer is over a custom button of the horizontal scroll bar and a mouse button is pressed.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer is over a custom button of the horizontal scroll bar and a mouse button is pressed.")]
    public event iGScrollBarCustomButtonMouseDownUpEventHandler HScrollBarCustomButtonMouseDown;

    /// <summary>Occurs when the mouse pointer is over a custom button of the horizontal scroll bar and a mouse button is released.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer is over a custom button of the horizontal scroll bar and a mouse button is released.")]
    public event iGScrollBarCustomButtonMouseDownUpEventHandler HScrollBarCustomButtonMouseUp;

    /// <summary>Occurs when the mouse pointer enters a custom button of the horizontal scroll bar.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer enters a custom button of the horizontal scroll bar.")]
    public event iGScrollBarCustomButtonMouseEnterLeaveEventHandler HScrollBarCustomButtonMouseEnter;

    /// <summary>Occurs when the mouse pointer leaves a custom button of the horizontal scroll bar.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer leaves a custom button of the horizontal scroll bar.")]
    public event iGScrollBarCustomButtonMouseEnterLeaveEventHandler HScrollBarCustomButtonMouseLeave;

    /// <summary>Occurs when the mouse pointer moves over a custom button of the horizontal scroll bar.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when the mouse pointer moves over a custom button of the horizontal scroll bar.")]
    public event iGScrollBarCustomButtonMouseMoveEventHandler HScrollBarCustomButtonMouseMove;

    /// <summary>Occurs when a custom button of the horizontal scroll bar is clicked.</summary>
    [Category("Scroll Bars")]
    [Description("Occurs when a custom button of the horizontal scroll bar is clicked.")]
    public event iGScrollBarCustomButtonClickEventHandler HScrollBarCustomButtonClick;

    /// <summary>Occurs every time when iGrid needs to obtain the text and image which are displayed in a cell.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when iGrid needs to get the text and image which are displayed in a cell. Use this event to dynamically specify them.")]
    public event iGCellDynamicContentsEventHandler CellDynamicContents;

    /// <summary>Occurs when the grid determines the width of a custom draw cell.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when the grid needs the width enough to display the contents of a custom draw cell without clipping.")]
    public event iGCustomDrawCellGetWidthEventHandler CustomDrawCellGetWidth;

    /// <summary>Occurs when the grid determines the height of a custom draw cell.</summary>
    [Category("Cell Appearance")]
    [Description("Occurs when the grid needs the height enough to display the contents of a custom draw cell without clipping.")]
    public event iGCustomDrawCellGetHeightEventHandler CustomDrawCellGetHeight;

    /// <summary>Occurs when the mouse pointer enters a cell and allows you to dynamically specify whether the cell has a tool tip, and if it has, specify the tip text.</summary>
    [Category("ToolTips")]
    [Description("Occurs when the mouse pointer enters a cell, and iGrid is determining whether a tool tip should be displayed for this cell.")]
    public event iGRequestCellToolTipTextEventHandler RequestCellToolTipText;

    /// <summary>Occurs when the mouse pointer enters a column header (header cell) and allows you to dynamically specify whether the column header has a tool tip, and if it has, specify the tip text.</summary>
    [Category("ToolTips")]
    [Description("Occurs when the mouse pointer enters a column header, and iGrid is determining whether a tool tip should be displayed for this column header.")]
    public event iGRequestColHdrToolTipTextEventHandler RequestColHdrToolTipText;

    /// <summary>Occurs when the mouse pointer enters a footer cell and allows you to dynamically specify whether this cell has a tool tip and its text.</summary>
    [Category("ToolTips")]
    [Description("Occurs when the mouse pointer enters a footer cell, and iGrid is determining whether a tool tip should be displayed for this cell.")]
    public event iGRequestFooterCellToolTipTextEventHandler RequestFooterCellToolTipText;

    /// <summary>Occurs when the mouse pointer enters an elementary control inside a cell and allows you to specify this control's own tool tip which differs from the cell tool tip.</summary>
    [Category("ToolTips")]
    [Description("Occurs when the mouse pointer enters an elementary control (such as combo btton) in a cell, and iGrid is determining whether a tool tip should be displayed for it.")]
    public event iGRequestElemControlToolTipTextEventHandler RequestCellElemControlToolTipText;

    /// <summary>Occurs when the mouse pointer enters an elementary control inside a column header and allows you to specify this control's own tool tip which differs from the column header tool tip.</summary>
    [Category("ToolTips")]
    [Description("Occurs when the mouse pointer enters a control (such as combo btton) in a column header, and iGrid is determining whether a tool tip should be displayed for it.")]
    public event iGRequestElemControlToolTipTextEventHandler RequestColHdrElemControlToolTipText;

    /// <summary>Occurs when the grid requires the custom group value of a cell in a column with custom grouping.</summary>
    [Category("Sorting and Grouping")]
    [Description("Occurs when the grid requires the custom group value of a cell in a column with custom grouping.")]
    public event iGCustomGroupValueEventHandler CustomGroupValue;

    /// <summary>Occurs when the grid requires to compare cells while sorting by custom criterion.</summary>
    [Category("Sorting and Grouping")]
    [Description("Occurs when the grid requires to compare cells while sorting by custom criterion.")]
    public event iGCustomSortEventHandler CustomSort;

    /// <summary>Occurs before the rows are grouped by a column.</summary>
    [Category("Sorting and Grouping")]
    [Description("Occurs before the rows are grouped by a column.")]
    public event EventHandler BeforeContentsGrouped;

    /// <summary>Occurs after the rows have been grouped by a column.</summary>
    [Category("Sorting and Grouping")]
    [Description("Occurs after the rows have been grouped by a column.")]
    public event EventHandler AfterContentsGrouped;

    /// <summary>Occurs before the rows are sorted by a column.</summary>
    [Category("Sorting and Grouping")]
    [Description("Occurs before the rows are sorted by a column.")]
    public event EventHandler BeforeContentsSorted;

    /// <summary>Occurs after the rows have been sorted by a column.</summary>
    [Category("Sorting and Grouping")]
    [Description("Occurs after the rows have been sorted by a column.")]
    public event EventHandler AfterContentsSorted;

    /// <summary>Occurs before the user collapse/expand a group of rows.</summary>
    [Category("Sorting and Grouping")]
    [Description("Occurs before the user collapse/expand a group of rows.")]
    public event iGBeforeRowStateChangedEventHandler BeforeRowStateChanged;

    /// <summary>Occurs after the user has collapsed/expanded a group of rows.</summary>
    [Category("Sorting and Grouping")]
    [Description("Occurs after the user has collapsed or expanded a group of rows.")]
    public event iGAfterRowStateChangedEventHandler AfterRowStateChanged;

    /// <summary>Occurs after a group row has been automatically created while grouping.</summary>
    [Category("Sorting and Grouping")]
    [Description("Occurs after a group row has been automatically created while grouping.")]
    public event iGAfterAutoGroupRowCreatedEventHandler AfterAutoGroupRowCreated;

    /// <summary>Occurs after the user has pressed the left or right mouse button over a cell and moved the mouse pointer more than 4 pixels in any direction (you can change the distance by using the <see cref="P:TenTec.Windows.iGridLib.iGrid.StartDragCellDelta" /> property).</summary>
    [Category("Drag Drop")]
    [Description("Occurs after the user has pressed the left or right mouse button over a cell and moved the mouse pointer more than 4 pixels in any direction. Use this event to start drag-and-drop operations.")]
    public event iGStartDragCellEventHandler StartDragCell;

    /// <summary>Occurs when a column or a range of columns have been added to iGrid.</summary>
    [Category("Columns")]
    [Description("Occurs when a new column or a bunch of columns has been added to the grid.")]
    public event iGColSetChangeEventHandler ColsAdded;

    /// <summary>Occurs when a column or a range of columns are about to be removed from iGrid.</summary>
    [Category("Columns")]
    [Description("Occurs when a column or a bunch of columns is about to be deleted.")]
    public event iGColSetChangeEventHandler ColsRemoving;

    /// <summary>Occurs when a column or a range of columns have been removed from iGrid.</summary>
    [Category("Columns")]
    [Description("Occurs when a column or a bunch of columns has been deleted.")]
    public event iGColSetChangeEventHandler ColsRemoved;

    /// <summary>Occurs when a new row or rows are added.</summary>
    [Category("Rows")]
    [Description("Occurs when a new row or a bunch of rows has been added to the grid.")]
    public event iGRowSetChangeEventHandler RowsAdded;

    /// <summary>Occurs when a row or a range of rows are about to be removed from iGrid.</summary>
    [Category("Rows")]
    [Description("Occurs when a row or a bunch of rows is about to be deleted.")]
    public event iGRowSetChangeEventHandler RowsRemoving;

    /// <summary>Occurs when one row or a range of rows is removed.</summary>
    [Category("Rows")]
    [Description("Occurs when a row or a bunch of rows has been deleted.")]
    public event iGRowSetChangeEventHandler RowsRemoved;

    /// <summary>Occurs when the visibility of a row has been changed.</summary>
    [Category("Rows")]
    [Description("Occurs when a row is hidden or shown through its Visible property.")]
    public event iGRowVisibleChangedEventHandler RowVisibleChanged;

    private enum iGCellKindAsMerged
    {
      Normal,
      MergedRoot,
      MergedNonRoot,
    }

    private struct Span__SectionRowInfo
    {
      public bool Visible;
      public int Height;
    }

    private struct GESTURENOTIFYSTRUCT
    {
      public uint cbSize;
      public uint dwFlags;
      public IntPtr hwndTarget;
      public iGrid.POINTS ptsLocation;
      public uint dwInstanceID;
    }

    private struct GESTURECONFIG
    {
      public int dwID;
      public int dwWant;
      public int dwBlock;
    }

    private struct POINTS
    {
      public short x;
      public short y;
    }

    private struct GESTUREINFO
    {
      public int cbSize;
      public int dwFlags;
      public int dwID;
      public IntPtr hwndTarget;
      [MarshalAs(UnmanagedType.Struct)]
      internal iGrid.POINTS ptsLocation;
      public int dwInstanceID;
      public int dwSequenceID;
      public long ullArguments;
      public int cbExtraArgs;
    }

    private struct iGCellContents
    {
      public bool DrawText;
      public string Text;
      public bool DrawImage;
      public int ImageIndex;
      public ImageList ImageList;
      public CheckState CheckState;
    }

    private class RowToResizeInfo
    {
      public int Index;
      public int Y;
      public int Height;
      public int MinHeight;
      public int MaxHeight;
    }

    private delegate void iGDrawTransparentDelegate(Graphics g, int x, int y);

    internal class GridLineParams
    {
      public bool Visible;
      public Pen Pen;
      public int PenOffset;
      public int PenExtra;
    }
  }
}
